<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Blogs</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#ffffff"><meta name="application-name" content="Edward&#039;s Blogs"><meta name="msapplication-TileImage" content="/source/icon.jpg"><meta name="msapplication-TileColor" content="#ffffff"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Edward&#039;s Blogs"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Blogs"><meta property="og:url" content="https://mr-xiongyq.github.io/"><meta property="og:site_name" content="Blogs"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://mr-xiongyq.github.io/img/og_image.png"><meta property="article:author" content="Xiongyuqi"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://mr-xiongyq.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://mr-xiongyq.github.io"},"headline":"Blogs","image":["https://mr-xiongyq.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Xiongyuqi"},"publisher":{"@type":"Organization","name":"Blogs","logo":{"@type":"ImageObject","url":"https://mr-xiongyq.github.io/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/6.0.0/css/all.min.css"><link rel="stylesheet" href="https://npm.elemecdn.com/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.lug.ustc.edu.cn/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://npm.elemecdn.com/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://npm.elemecdn.com/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://npm.elemecdn.com/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.1.1"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Blogs" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item is-active" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" target="_blank" rel="noopener" href="https://github.com/Mr-xiongyq">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="GitHub上下载" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-06-27T07:03:20.000Z" title="2024/6/27 15:03:20">2024-06-27</time>发表</span><span class="level-item"><time dateTime="2024-06-27T07:11:39.085Z" title="2024/6/27 15:11:39">2024-06-27</time>更新</span><span class="level-item">24 分钟读完 (大约3528个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/06/27/%E9%9D%A2%E7%BB%8F2-attention-%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/">面经2-attention(注意力机制)</a></p><div class="content"><h2 id="1-通俗的解释什么是attention"><a href="#1-通俗的解释什么是attention" class="headerlink" title="1.通俗的解释什么是attention"></a>1.通俗的解释什么是attention</h2><p>注意力机制（Attention Mechanism）是深度学习中一种非常重要的技术，它帮助模型更好地“关注”输入数据中的重要部分。为了更通俗地解释，我们可以用一个简单的类比来帮助理解。</p>
<h3 id="类比：读书做笔记"><a href="#类比：读书做笔记" class="headerlink" title="类比：读书做笔记"></a>类比：读书做笔记</h3><p>假设你在阅读一本书，并且需要在阅读过程中做一些笔记。书中的内容非常多，但你不能也不需要记住每一个字。那么你会怎么做呢？你会重点关注那些对你来说重要的信息。注意力机制就像你在读书时选择性地关注重要内容一样。</p>
<h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><ol>
<li><p><strong>输入信息</strong>：</p>
<ul>
<li>你有一本书（输入数据），每一页上有很多文字（输入序列）。</li>
</ul>
</li>
<li><p><strong>关键内容</strong>：</p>
<ul>
<li>你要做笔记，所以你需要找到哪些内容是最重要的，比如关键的段落、句子或单词。</li>
</ul>
</li>
<li><p><strong>注意力权重</strong>：</p>
<ul>
<li>你给每个句子或段落分配一个重要性分数（权重）。更重要的内容分数更高，不太重要的内容分数更低。</li>
</ul>
</li>
<li><p><strong>加权求和</strong>：</p>
<ul>
<li>你根据这些分数来决定每段内容在你笔记中的重要性。重要性高的内容，你会详细记下（加权求和后保留更多信息），重要性低的内容，你会略过或简要记下。</li>
</ul>
</li>
</ol>
<h3 id="在深度学习中的应用"><a href="#在深度学习中的应用" class="headerlink" title="在深度学习中的应用"></a>在深度学习中的应用</h3><p>在深度学习中，注意力机制通过以下步骤工作：</p>
<ol>
<li><p><strong>输入序列</strong>：</p>
<ul>
<li>模型接收一段输入序列，比如一句话的每个单词的表示（向量）。</li>
</ul>
</li>
<li><p><strong>计算注意力分数</strong>：</p>
<ul>
<li>模型计算每个单词对当前处理单词的重要性，类似于你给每段内容分配一个重要性分数。</li>
</ul>
</li>
<li><p><strong>生成注意力权重</strong>：</p>
<ul>
<li>使用这些分数通过一个softmax函数转化为注意力权重，这些权重和分数可以理解为“关注度”。</li>
</ul>
</li>
<li><p><strong>加权求和</strong>：</p>
<ul>
<li>对输入序列中的所有单词的表示进行加权求和，权重高的单词对最终表示的影响更大。</li>
</ul>
</li>
</ol>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>假设你在翻译一个句子：”The cat sat on the mat.”</p>
<p>在翻译时，模型需要决定哪些单词对当前正在翻译的单词最重要。例如，在翻译“sat”时，模型可能会发现“cat”和“mat”也很重要，因为它们在语义上相关。这时，注意力机制会给“cat”和“mat”更高的权重，而给其他不太相关的单词更低的权重。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>注意力机制帮助模型在处理大量信息时，更加高效地聚焦于最相关和重要的部分。这不仅提高了模型的性能，也使得模型在处理复杂任务时更加灵活和精确。就像你在读书时会重点标记和记住重要的部分一样，注意力机制使得模型在处理数据时能够有效地“注意”到关键信息。</p>
<h2 id="2-注意力机制的计算"><a href="#2-注意力机制的计算" class="headerlink" title="2.注意力机制的计算"></a>2.注意力机制的计算</h2><p>注意力机制（Attention Mechanism）在深度学习中的计算方法主要包括三个步骤：计算注意力分数、生成注意力权重、加权求和。以下是详细的计算过程，以自注意力（Self-Attention）为例进行解释。</p>
<h3 id="1-输入表示"><a href="#1-输入表示" class="headerlink" title="1. 输入表示"></a>1. 输入表示</h3><p>假设我们有一个输入序列，表示为矩阵 (X)，其中每一行是输入序列中一个词的向量表示。对于一个长度为 (n) 的序列，每个词的向量维度为 (d)，输入矩阵 (X) 的形状为 (n \times d)。</p>
<h3 id="2-计算查询（Query）、键（Key）和值（Value）"><a href="#2-计算查询（Query）、键（Key）和值（Value）" class="headerlink" title="2. 计算查询（Query）、键（Key）和值（Value）"></a>2. 计算查询（Query）、键（Key）和值（Value）</h3><p>首先，我们需要为每个输入向量计算查询（Query）、键（Key）和值（Value）向量。这是通过三个不同的线性变换完成的。假设 (W_Q)、(W_K) 和 (W_V) 分别是查询、键和值的权重矩阵，它们的形状都是 (d \times d_k)。</p>
<p>[ Q &#x3D; XW_Q ]<br>[ K &#x3D; XW_K ]<br>[ V &#x3D; XW_V ]</p>
<p>其中，(Q)、(K) 和 (V) 分别是查询、键和值的矩阵，它们的形状都是 (n \times d_k)。</p>
<h3 id="3-计算注意力分数（Attention-Scores）"><a href="#3-计算注意力分数（Attention-Scores）" class="headerlink" title="3. 计算注意力分数（Attention Scores）"></a>3. 计算注意力分数（Attention Scores）</h3><p>接下来，我们计算查询和键的点积来得到注意力分数。注意力分数表示每个词对其他词的重要性。</p>
<p>[ \text{scores} &#x3D; QK^T ]</p>
<p>这里，(\text{scores}) 的形状是 (n \times n)，表示每个词对其他所有词的注意力分数。</p>
<h3 id="4-生成注意力权重（Attention-Weights）"><a href="#4-生成注意力权重（Attention-Weights）" class="headerlink" title="4. 生成注意力权重（Attention Weights）"></a>4. 生成注意力权重（Attention Weights）</h3><p>为了使得注意力分数更稳定，我们会对其进行缩放，除以 (\sqrt{d_k})。接下来，应用softmax函数将注意力分数转化为注意力权重，这些权重表示每个词对其他词的注意力分配。</p>
<p>[ \text{scaled_scores} &#x3D; \frac{QK^T}{\sqrt{d_k}} ]<br>[ \text{weights} &#x3D; \text{softmax}(\text{scaled_scores}) ]</p>
<p>注意力权重矩阵 (\text{weights}) 的形状也是 (n \times n)。</p>
<h3 id="5-加权求和（Weighted-Sum）"><a href="#5-加权求和（Weighted-Sum）" class="headerlink" title="5. 加权求和（Weighted Sum）"></a>5. 加权求和（Weighted Sum）</h3><p>最后，使用注意力权重对值（Value）向量进行加权求和，得到最终的输出。</p>
<p>[ \text{output} &#x3D; \text{weights}V ]</p>
<p>输出矩阵 (\text{output}) 的形状是 (n \times d_k)。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>注意力机制的计算过程可以总结为以下几个步骤：</p>
<ol>
<li><p><strong>计算查询、键和值</strong>：<br>[ Q &#x3D; XW_Q, \quad K &#x3D; XW_K, \quad V &#x3D; XW_V ]</p>
</li>
<li><p><strong>计算注意力分数</strong>：<br>[ \text{scores} &#x3D; QK^T ]</p>
</li>
<li><p><strong>缩放注意力分数并应用softmax</strong>：<br>[ \text{scaled_scores} &#x3D; \frac{\text{scores}}{\sqrt{d_k}}, \quad \text{weights} &#x3D; \text{softmax}(\text{scaled_scores}) ]</p>
</li>
<li><p><strong>计算加权求和</strong>：<br>[ \text{output} &#x3D; \text{weights}V ]</p>
</li>
</ol>
<p>这个过程实现了从输入序列到输出序列的自适应权重计算，使得模型能够关注到输入序列中的重要部分。这种机制在各种任务（如机器翻译、文本生成、图像处理等）中都表现出了强大的性能。</p>
<h2 id="3-注意力机制的k-q相似度计算都有哪些方法，各自有什么优缺点"><a href="#3-注意力机制的k-q相似度计算都有哪些方法，各自有什么优缺点" class="headerlink" title="3.注意力机制的k,q相似度计算都有哪些方法，各自有什么优缺点"></a>3.注意力机制的k,q相似度计算都有哪些方法，各自有什么优缺点</h2><p>在注意力机制中，查询（Query，Q）和键（Key，K）之间的相似度计算是核心步骤，用于确定注意力权重。不同的相似度计算方法有不同的优缺点。以下是几种常见的方法及其优缺点：</p>
<h3 id="1-点积相似度（Dot-Product-Similarity）"><a href="#1-点积相似度（Dot-Product-Similarity）" class="headerlink" title="1. 点积相似度（Dot-Product Similarity）"></a>1. 点积相似度（Dot-Product Similarity）</h3><h4 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h4><p>[ \text{score}(Q, K) &#x3D; Q \cdot K^T ]</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li><strong>计算简单</strong>：点积相似度计算非常高效，尤其是在硬件加速（如GPU）上可以充分利用矩阵乘法的优化。</li>
<li><strong>常用方法</strong>：点积相似度是Transformer模型中的默认选择，被广泛使用和验证。</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li><strong>维度影响</strong>：随着向量维度增加，点积值可能会变得很大，导致softmax函数的梯度过小。为此，通常需要缩放因子（如 (\sqrt{d_k})）来稳定计算。</li>
</ul>
<h3 id="2-缩放点积相似度（Scaled-Dot-Product-Similarity）"><a href="#2-缩放点积相似度（Scaled-Dot-Product-Similarity）" class="headerlink" title="2. 缩放点积相似度（Scaled Dot-Product Similarity）"></a>2. 缩放点积相似度（Scaled Dot-Product Similarity）</h3><h4 id="计算方法-1"><a href="#计算方法-1" class="headerlink" title="计算方法"></a>计算方法</h4><p>[ \text{score}(Q, K) &#x3D; \frac{Q \cdot K^T}{\sqrt{d_k}} ]</p>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul>
<li><strong>稳定梯度</strong>：通过缩放因子 (\sqrt{d_k}) 减少了随着维度增加而导致的梯度消失问题。</li>
<li><strong>广泛应用</strong>：在Transformer模型中被默认使用，性能稳定。</li>
</ul>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li><strong>需要缩放</strong>：虽然解决了梯度问题，但增加了一步额外的缩放计算。</li>
</ul>
<h3 id="3-余弦相似度（Cosine-Similarity）"><a href="#3-余弦相似度（Cosine-Similarity）" class="headerlink" title="3. 余弦相似度（Cosine Similarity）"></a>3. 余弦相似度（Cosine Similarity）</h3><h4 id="计算方法-2"><a href="#计算方法-2" class="headerlink" title="计算方法"></a>计算方法</h4><p>[ \text{score}(Q, K) &#x3D; \frac{Q \cdot K^T}{|Q| |K|} ]</p>
<h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ul>
<li><strong>归一化相似度</strong>：将向量的相似度归一化到[-1, 1]之间，消除了向量长度对相似度的影响。</li>
<li><strong>可解释性强</strong>：余弦相似度在各种应用中都有较好的解释性。</li>
</ul>
<h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li><strong>计算复杂度</strong>：需要计算向量的范数，增加了计算复杂度。</li>
<li><strong>性能问题</strong>：在某些场景下，余弦相似度的效果可能不如点积相似度。</li>
</ul>
<h3 id="4-加性注意力（Additive-Attention-或-Bahdanau-Attention）"><a href="#4-加性注意力（Additive-Attention-或-Bahdanau-Attention）" class="headerlink" title="4. 加性注意力（Additive Attention 或 Bahdanau Attention）"></a>4. 加性注意力（Additive Attention 或 Bahdanau Attention）</h3><h4 id="计算方法-3"><a href="#计算方法-3" class="headerlink" title="计算方法"></a>计算方法</h4><p>[ \text{score}(Q, K) &#x3D; w^T \tanh(W_Q Q + W_K K + b) ]<br>其中，(w)、(W_Q)、(W_K) 和 (b) 是可训练的参数。</p>
<h4 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h4><ul>
<li><strong>灵活性高</strong>：通过可训练参数，可以更灵活地学习不同类型的相似度。</li>
<li><strong>广泛应用</strong>：特别是在早期的Seq2Seq模型中应用广泛。</li>
</ul>
<h4 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li><strong>计算开销大</strong>：涉及更多的参数和非线性操作（tanh），计算开销较大。</li>
<li><strong>复杂度高</strong>：相比点积相似度，计算更复杂。</li>
</ul>
<h3 id="5-高斯注意力（Gaussian-Attention）"><a href="#5-高斯注意力（Gaussian-Attention）" class="headerlink" title="5. 高斯注意力（Gaussian Attention）"></a>5. 高斯注意力（Gaussian Attention）</h3><h4 id="计算方法-4"><a href="#计算方法-4" class="headerlink" title="计算方法"></a>计算方法</h4><p>[ \text{score}(Q, K) &#x3D; \exp\left(-\frac{|Q - K|^2}{2\sigma^2}\right) ]</p>
<h4 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h4><ul>
<li><strong>平滑注意力分布</strong>：使用高斯函数计算相似度，可以产生更加平滑的注意力分布。</li>
<li><strong>与距离相关</strong>：自然地反映了向量之间的欧氏距离。</li>
</ul>
<h4 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li><strong>参数选择</strong>：需要选择合适的 (\sigma) 值，参数选择不当可能导致效果不佳。</li>
<li><strong>计算开销大</strong>：计算欧氏距离和指数函数增加了计算开销。</li>
</ul>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>每种相似度计算方法都有其特定的优缺点，选择哪种方法通常取决于具体应用场景和需求：</p>
<ul>
<li><strong>点积相似度和缩放点积相似度</strong>：计算简单高效，适用于大多数Transformer模型。</li>
<li><strong>余弦相似度</strong>：适用于需要归一化相似度的场景，但计算复杂度较高。</li>
<li><strong>加性注意力</strong>：灵活性高，但计算开销大，适用于需要灵活相似度计算的应用。</li>
<li><strong>高斯注意力</strong>：平滑分布和距离相关，但计算复杂度和参数选择是挑战。</li>
</ul>
<p>实际应用中，缩放点积相似度是最常用和有效的方法，尤其是在Transformer架构中。</p>
<h2 id="4-attention的计算中为什么要除以根号dk"><a href="#4-attention的计算中为什么要除以根号dk" class="headerlink" title="4.attention的计算中为什么要除以根号dk"></a>4.attention的计算中为什么要除以根号dk</h2><p>在注意力机制的计算中，将点积相似度除以 (\sqrt{d_k}) 是为了稳定计算过程，防止数值溢出。这一步骤通常称为<strong>缩放点积相似度</strong>（Scaled Dot-Product Attention）。以下是详细的原因和解释：</p>
<h3 id="原因和解释"><a href="#原因和解释" class="headerlink" title="原因和解释"></a>原因和解释</h3><h4 id="1-避免数值不稳定"><a href="#1-避免数值不稳定" class="headerlink" title="1. 避免数值不稳定"></a>1. 避免数值不稳定</h4><ul>
<li><p><strong>高维点积值过大</strong>：</p>
<ul>
<li>在高维空间中，向量的点积值随着维度的增加会变得很大。这是因为点积的结果是多个元素乘积的累加，维度越高，累加的值越大。假设两个向量 (Q) 和 (K) 的每个元素都是均值为零、方差为1的独立随机变量，那么它们的点积 (\sum_{i&#x3D;1}^{d_k} Q_i K_i) 的方差是 (d_k)。随着 (d_k) 增加，点积的值会越来越大。</li>
</ul>
</li>
<li><p><strong>softmax梯度消失</strong>：</p>
<ul>
<li>在计算注意力权重时，点积相似度值作为输入会被传递到softmax函数中。如果这些值很大，softmax函数的输出会变得极端，即接近0或1。这会导致梯度消失问题，使得模型在训练过程中难以有效更新参数。</li>
</ul>
</li>
</ul>
<h4 id="2-缩放稳定计算"><a href="#2-缩放稳定计算" class="headerlink" title="2. 缩放稳定计算"></a>2. 缩放稳定计算</h4><ul>
<li><strong>缩放因子 (\sqrt{d_k})</strong>：<ul>
<li>为了避免上述问题，我们在计算点积相似度后，除以 (\sqrt{d_k})。这一缩放因子将点积相似度值缩小到一个更合理的范围，防止值过大。</li>
<li>具体地，缩放后的值更接近于均值为0、方差为1的标准正态分布。这使得softmax函数的输入值不会太大，从而生成的注意力权重更加平滑，梯度更新也更稳定。</li>
</ul>
</li>
</ul>
<h3 id="数学解释"><a href="#数学解释" class="headerlink" title="数学解释"></a>数学解释</h3><p>假设 (Q) 和 (K) 是维度为 (d_k) 的向量：<br>[ \text{score}(Q, K) &#x3D; Q \cdot K^T &#x3D; \sum_{i&#x3D;1}^{d_k} Q_i K_i ]</p>
<p>如果 (Q_i) 和 (K_i) 的元素是均值为0、方差为1的随机变量，那么点积的结果的期望值为0，但方差为 (d_k)：<br>[ \text{Var}(Q \cdot K^T) &#x3D; d_k ]</p>
<p>为了使得点积相似度的方差不随 (d_k) 增加，我们将其除以 (\sqrt{d_k})：<br>[ \text{scaled_score}(Q, K) &#x3D; \frac{Q \cdot K^T}{\sqrt{d_k}} ]</p>
<p>这将点积的方差标准化为1，输入到softmax函数的值范围更加稳定。</p>
<h3 id="例子和效果"><a href="#例子和效果" class="headerlink" title="例子和效果"></a>例子和效果</h3><p>例如，在维度 (d_k &#x3D; 64) 的情况下，如果不进行缩放，点积的值可能会变得很大（例如，在0到64之间）。经过softmax后，权重会极端化，导致某些注意力权重接近1，而其他接近0。这种极端的权重分布会使模型的学习变得困难。而通过缩放因子 (\sqrt{64} &#x3D; 8)，点积值会被缩小到一个更合理的范围（例如，在0到8之间），使得softmax输出的权重更平滑，梯度更稳定。</p>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>将点积相似度除以 (\sqrt{d_k}) 的目的是为了：</p>
<ol>
<li>防止高维向量点积值过大导致的数值不稳定问题。</li>
<li>生成更平滑的注意力权重分布，避免softmax输出的极端化，稳定梯度更新过程。</li>
</ol>
<p>这一步骤是Transformer模型中的一个重要细节，确保了注意力机制在高维情况下的有效性和稳定性。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-06-27T06:53:24.000Z" title="2024/6/27 14:53:24">2024-06-27</time>发表</span><span class="level-item"><time dateTime="2024-06-27T08:05:46.950Z" title="2024/6/27 16:05:46">2024-06-27</time>更新</span><span class="level-item">20 分钟读完 (大约2951个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/06/27/%E9%9D%A2%E7%BB%8F/">面经</a></p><div class="content"><h2 id="1-Transformer模型的结构"><a href="#1-Transformer模型的结构" class="headerlink" title="1. Transformer模型的结构"></a>1. Transformer模型的结构</h2><p>Transformer模型是由Vaswani等人在2017年提出的一种深度学习模型，主要用于自然语言处理任务，如翻译、文本生成等。Transformer模型的核心架构由编码器（Encoder）和解码器（Decoder）组成。以下是Transformer模型的详细结构：</p>
<h3 id="1-编码器（Encoder）"><a href="#1-编码器（Encoder）" class="headerlink" title="1. 编码器（Encoder）"></a>1. 编码器（Encoder）</h3><p>编码器部分由N个相同的编码器层（Encoder Layer）堆叠而成。每个编码器层包括两个子层：</p>
<h4 id="a-多头自注意力机制（Multi-Head-Self-Attention-Mechanism）"><a href="#a-多头自注意力机制（Multi-Head-Self-Attention-Mechanism）" class="headerlink" title="a. 多头自注意力机制（Multi-Head Self-Attention Mechanism）"></a>a. 多头自注意力机制（Multi-Head Self-Attention Mechanism）</h4><ul>
<li><strong>输入</strong>：一组向量表示（如单词的词嵌入）。</li>
<li><strong>输出</strong>：对输入向量进行加权求和，以捕捉全局依赖关系。</li>
<li><strong>多头机制</strong>：通过多个注意力头（Attention Heads）来捕捉不同子空间的特征。</li>
</ul>
<h4 id="b-前馈神经网络（Feed-Forward-Neural-Network）"><a href="#b-前馈神经网络（Feed-Forward-Neural-Network）" class="headerlink" title="b. 前馈神经网络（Feed-Forward Neural Network）"></a>b. 前馈神经网络（Feed-Forward Neural Network）</h4><ul>
<li>包含两个线性变换层和一个激活函数（通常是ReLU）。</li>
<li><strong>输入</strong>：经过多头自注意力机制后的输出。</li>
<li><strong>输出</strong>：经过非线性变换后的表示。</li>
</ul>
<p>每个子层后都有一个残差连接（Residual Connection）和层归一化（Layer Normalization）。</p>
<h3 id="2-解码器（Decoder）"><a href="#2-解码器（Decoder）" class="headerlink" title="2. 解码器（Decoder）"></a>2. 解码器（Decoder）</h3><p>解码器部分也由N个相同的解码器层（Decoder Layer）堆叠而成。每个解码器层包括三个子层：</p>
<h4 id="a-多头自注意力机制（Masked-Multi-Head-Self-Attention-Mechanism）"><a href="#a-多头自注意力机制（Masked-Multi-Head-Self-Attention-Mechanism）" class="headerlink" title="a. 多头自注意力机制（Masked Multi-Head Self-Attention Mechanism）"></a>a. 多头自注意力机制（Masked Multi-Head Self-Attention Mechanism）</h4><ul>
<li>类似于编码器中的多头自注意力机制，但这里的自注意力是被掩盖的，以确保解码过程中当前词只能关注到之前的词。</li>
</ul>
<h4 id="b-编码器-解码器注意力机制（Encoder-Decoder-Attention-Mechanism）"><a href="#b-编码器-解码器注意力机制（Encoder-Decoder-Attention-Mechanism）" class="headerlink" title="b. 编码器-解码器注意力机制（Encoder-Decoder Attention Mechanism）"></a>b. 编码器-解码器注意力机制（Encoder-Decoder Attention Mechanism）</h4><ul>
<li><strong>输入</strong>：编码器的输出和解码器自注意力的输出。</li>
<li><strong>输出</strong>：结合编码器信息和当前解码步骤信息的表示。</li>
</ul>
<h4 id="c-前馈神经网络（Feed-Forward-Neural-Network）"><a href="#c-前馈神经网络（Feed-Forward-Neural-Network）" class="headerlink" title="c. 前馈神经网络（Feed-Forward Neural Network）"></a>c. 前馈神经网络（Feed-Forward Neural Network）</h4><ul>
<li>与编码器中的前馈神经网络类似。</li>
</ul>
<p>每个子层后也有残差连接和层归一化。</p>
<h3 id="3-位置编码（Positional-Encoding）"><a href="#3-位置编码（Positional-Encoding）" class="headerlink" title="3. 位置编码（Positional Encoding）"></a>3. 位置编码（Positional Encoding）</h3><p>由于Transformer没有卷积和循环结构，它使用位置编码来注入关于序列顺序的信息。这些位置编码是添加到输入向量中的。</p>
<h3 id="4-全局架构"><a href="#4-全局架构" class="headerlink" title="4. 全局架构"></a>4. 全局架构</h3><ul>
<li><strong>编码器</strong>：将输入序列编码为一组隐层表示。</li>
<li><strong>解码器</strong>：基于编码器的表示和之前生成的词，生成输出序列。</li>
</ul>
<h3 id="注意力机制（Attention-Mechanism）"><a href="#注意力机制（Attention-Mechanism）" class="headerlink" title="注意力机制（Attention Mechanism）"></a>注意力机制（Attention Mechanism）</h3><p>Transformer的核心是注意力机制，特别是自注意力机制。以下是其关键步骤：</p>
<ol>
<li><p><strong>计算注意力分数（Scores）</strong>：<br>  <mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -2.308ex;" xmlns="http://www.w3.org/2000/svg" width="41.428ex" height="5.741ex" role="img" focusable="false" viewBox="0 -1517.7 18311.4 2537.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mtext"><path data-c="41" d="M255 0Q240 3 140 3Q48 3 39 0H32V46H47Q119 49 139 88Q140 91 192 245T295 553T348 708Q351 716 366 716H376Q396 715 400 709Q402 707 508 390L617 67Q624 54 636 51T687 46H717V0H708Q699 3 581 3Q458 3 437 0H427V46H440Q510 46 510 64Q510 66 486 138L462 209H229L209 150Q189 91 189 85Q189 72 209 59T259 46H264V0H255ZM447 255L345 557L244 256Q244 255 345 255H447Z"></path><path data-c="74" d="M27 422Q80 426 109 478T141 600V615H181V431H316V385H181V241Q182 116 182 100T189 68Q203 29 238 29Q282 29 292 100Q293 108 293 146V181H333V146V134Q333 57 291 17Q264 -10 221 -10Q187 -10 162 2T124 33T105 68T98 100Q97 107 97 248V385H18V422H27Z" transform="translate(750,0)"></path><path data-c="74" d="M27 422Q80 426 109 478T141 600V615H181V431H316V385H181V241Q182 116 182 100T189 68Q203 29 238 29Q282 29 292 100Q293 108 293 146V181H333V146V134Q333 57 291 17Q264 -10 221 -10Q187 -10 162 2T124 33T105 68T98 100Q97 107 97 248V385H18V422H27Z" transform="translate(1139,0)"></path><path data-c="65" d="M28 218Q28 273 48 318T98 391T163 433T229 448Q282 448 320 430T378 380T406 316T415 245Q415 238 408 231H126V216Q126 68 226 36Q246 30 270 30Q312 30 342 62Q359 79 369 104L379 128Q382 131 395 131H398Q415 131 415 121Q415 117 412 108Q393 53 349 21T250 -11Q155 -11 92 58T28 218ZM333 275Q322 403 238 411H236Q228 411 220 410T195 402T166 381T143 340T127 274V267H333V275Z" transform="translate(1528,0)"></path><path data-c="6E" d="M41 46H55Q94 46 102 60V68Q102 77 102 91T102 122T103 161T103 203Q103 234 103 269T102 328V351Q99 370 88 376T43 385H25V408Q25 431 27 431L37 432Q47 433 65 434T102 436Q119 437 138 438T167 441T178 442H181V402Q181 364 182 364T187 369T199 384T218 402T247 421T285 437Q305 442 336 442Q450 438 463 329Q464 322 464 190V104Q464 66 466 59T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z" transform="translate(1972,0)"></path><path data-c="74" d="M27 422Q80 426 109 478T141 600V615H181V431H316V385H181V241Q182 116 182 100T189 68Q203 29 238 29Q282 29 292 100Q293 108 293 146V181H333V146V134Q333 57 291 17Q264 -10 221 -10Q187 -10 162 2T124 33T105 68T98 100Q97 107 97 248V385H18V422H27Z" transform="translate(2528,0)"></path><path data-c="69" d="M69 609Q69 637 87 653T131 669Q154 667 171 652T188 609Q188 579 171 564T129 549Q104 549 87 564T69 609ZM247 0Q232 3 143 3Q132 3 106 3T56 1L34 0H26V46H42Q70 46 91 49Q100 53 102 60T104 102V205V293Q104 345 102 359T88 378Q74 385 41 385H30V408Q30 431 32 431L42 432Q52 433 70 434T106 436Q123 437 142 438T171 441T182 442H185V62Q190 52 197 50T232 46H255V0H247Z" transform="translate(2917,0)"></path><path data-c="6F" d="M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z" transform="translate(3195,0)"></path><path data-c="6E" d="M41 46H55Q94 46 102 60V68Q102 77 102 91T102 122T103 161T103 203Q103 234 103 269T102 328V351Q99 370 88 376T43 385H25V408Q25 431 27 431L37 432Q47 433 65 434T102 436Q119 437 138 438T167 441T178 442H181V402Q181 364 182 364T187 369T199 384T218 402T247 421T285 437Q305 442 336 442Q450 438 463 329Q464 322 464 190V104Q464 66 466 59T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z" transform="translate(3695,0)"></path></g><g data-mml-node="mo" transform="translate(4251,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(4640,0)"><path data-c="1D444" d="M399 -80Q399 -47 400 -30T402 -11V-7L387 -11Q341 -22 303 -22Q208 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435Q740 255 592 107Q529 47 461 16L444 8V3Q444 2 449 -24T470 -66T516 -82Q551 -82 583 -60T625 -3Q631 11 638 11Q647 11 649 2Q649 -6 639 -34T611 -100T557 -165T481 -194Q399 -194 399 -87V-80ZM636 468Q636 523 621 564T580 625T530 655T477 665Q429 665 379 640Q277 591 215 464T153 216Q153 110 207 59Q231 38 236 38V46Q236 86 269 120T347 155Q372 155 390 144T417 114T429 82T435 55L448 64Q512 108 557 185T619 334T636 468ZM314 18Q362 18 404 39L403 49Q399 104 366 115Q354 117 347 117Q344 117 341 117T337 118Q317 118 296 98T274 52Q274 18 314 18Z"></path></g><g data-mml-node="mo" transform="translate(5431,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(5875.7,0)"><path data-c="1D43E" d="M285 628Q285 635 228 637Q205 637 198 638T191 647Q191 649 193 661Q199 681 203 682Q205 683 214 683H219Q260 681 355 681Q389 681 418 681T463 682T483 682Q500 682 500 674Q500 669 497 660Q496 658 496 654T495 648T493 644T490 641T486 639T479 638T470 637T456 637Q416 636 405 634T387 623L306 305Q307 305 490 449T678 597Q692 611 692 620Q692 635 667 637Q651 637 651 648Q651 650 654 662T659 677Q662 682 676 682Q680 682 711 681T791 680Q814 680 839 681T869 682Q889 682 889 672Q889 650 881 642Q878 637 862 637Q787 632 726 586Q710 576 656 534T556 455L509 418L518 396Q527 374 546 329T581 244Q656 67 661 61Q663 59 666 57Q680 47 717 46H738Q744 38 744 37T741 19Q737 6 731 0H720Q680 3 625 3Q503 3 488 0H478Q472 6 472 9T474 27Q478 40 480 43T491 46H494Q544 46 544 71Q544 75 517 141T485 216L427 354L359 301L291 248L268 155Q245 63 245 58Q245 51 253 49T303 46H334Q340 37 340 35Q340 19 333 5Q328 0 317 0Q314 0 280 1T180 2Q118 2 85 2T49 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Z"></path></g><g data-mml-node="mo" transform="translate(6764.7,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(7209.3,0)"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"></path></g><g data-mml-node="mo" transform="translate(7978.3,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(8645.1,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mtext" transform="translate(9700.9,0)"><path data-c="73" d="M295 316Q295 356 268 385T190 414Q154 414 128 401Q98 382 98 349Q97 344 98 336T114 312T157 287Q175 282 201 278T245 269T277 256Q294 248 310 236T342 195T359 133Q359 71 321 31T198 -10H190Q138 -10 94 26L86 19L77 10Q71 4 65 -1L54 -11H46H42Q39 -11 33 -5V74V132Q33 153 35 157T45 162H54Q66 162 70 158T75 146T82 119T101 77Q136 26 198 26Q295 26 295 104Q295 133 277 151Q257 175 194 187T111 210Q75 227 54 256T33 318Q33 357 50 384T93 424T143 442T187 447H198Q238 447 268 432L283 424L292 431Q302 440 314 448H322H326Q329 448 335 442V310L329 304H301Q295 310 295 316Z"></path><path data-c="6F" d="M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z" transform="translate(394,0)"></path><path data-c="66" d="M273 0Q255 3 146 3Q43 3 34 0H26V46H42Q70 46 91 49Q99 52 103 60Q104 62 104 224V385H33V431H104V497L105 564L107 574Q126 639 171 668T266 704Q267 704 275 704T289 705Q330 702 351 679T372 627Q372 604 358 590T321 576T284 590T270 627Q270 647 288 667H284Q280 668 273 668Q245 668 223 647T189 592Q183 572 182 497V431H293V385H185V225Q185 63 186 61T189 57T194 54T199 51T206 49T213 48T222 47T231 47T241 46T251 46H282V0H273Z" transform="translate(894,0)"></path><path data-c="74" d="M27 422Q80 426 109 478T141 600V615H181V431H316V385H181V241Q182 116 182 100T189 68Q203 29 238 29Q282 29 292 100Q293 108 293 146V181H333V146V134Q333 57 291 17Q264 -10 221 -10Q187 -10 162 2T124 33T105 68T98 100Q97 107 97 248V385H18V422H27Z" transform="translate(1200,0)"></path><path data-c="6D" d="M41 46H55Q94 46 102 60V68Q102 77 102 91T102 122T103 161T103 203Q103 234 103 269T102 328V351Q99 370 88 376T43 385H25V408Q25 431 27 431L37 432Q47 433 65 434T102 436Q119 437 138 438T167 441T178 442H181V402Q181 364 182 364T187 369T199 384T218 402T247 421T285 437Q305 442 336 442Q351 442 364 440T387 434T406 426T421 417T432 406T441 395T448 384T452 374T455 366L457 361L460 365Q463 369 466 373T475 384T488 397T503 410T523 422T546 432T572 439T603 442Q729 442 740 329Q741 322 741 190V104Q741 66 743 59T754 49Q775 46 803 46H819V0H811L788 1Q764 2 737 2T699 3Q596 3 587 0H579V46H595Q656 46 656 62Q657 64 657 200Q656 335 655 343Q649 371 635 385T611 402T585 404Q540 404 506 370Q479 343 472 315T464 232V168V108Q464 78 465 68T468 55T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z" transform="translate(1589,0)"></path><path data-c="61" d="M137 305T115 305T78 320T63 359Q63 394 97 421T218 448Q291 448 336 416T396 340Q401 326 401 309T402 194V124Q402 76 407 58T428 40Q443 40 448 56T453 109V145H493V106Q492 66 490 59Q481 29 455 12T400 -6T353 12T329 54V58L327 55Q325 52 322 49T314 40T302 29T287 17T269 6T247 -2T221 -8T190 -11Q130 -11 82 20T34 107Q34 128 41 147T68 188T116 225T194 253T304 268H318V290Q318 324 312 340Q290 411 215 411Q197 411 181 410T156 406T148 403Q170 388 170 359Q170 334 154 320ZM126 106Q126 75 150 51T209 26Q247 26 276 49T315 109Q317 116 318 175Q318 233 317 233Q309 233 296 232T251 223T193 203T147 166T126 106Z" transform="translate(2422,0)"></path><path data-c="78" d="M201 0Q189 3 102 3Q26 3 17 0H11V46H25Q48 47 67 52T96 61T121 78T139 96T160 122T180 150L226 210L168 288Q159 301 149 315T133 336T122 351T113 363T107 370T100 376T94 379T88 381T80 383Q74 383 44 385H16V431H23Q59 429 126 429Q219 429 229 431H237V385Q201 381 201 369Q201 367 211 353T239 315T268 274L272 270L297 304Q329 345 329 358Q329 364 327 369T322 376T317 380T310 384L307 385H302V431H309Q324 428 408 428Q487 428 493 431H499V385H492Q443 385 411 368Q394 360 377 341T312 257L296 236L358 151Q424 61 429 57T446 50Q464 46 499 46H516V0H510H502Q494 1 482 1T457 2T432 2T414 3Q403 3 377 3T327 1L304 0H295V46H298Q309 46 320 51T331 63Q331 65 291 120L250 175Q249 174 219 133T185 88Q181 83 181 74Q181 63 188 55T206 46Q208 46 208 23V0H201Z" transform="translate(2922,0)"></path></g><g data-mml-node="mrow" transform="translate(13317.6,0)"><g data-mml-node="mo" transform="translate(0 -0.5)"><path data-c="28" d="M701 -940Q701 -943 695 -949H664Q662 -947 636 -922T591 -879T537 -818T475 -737T412 -636T350 -511T295 -362T250 -186T221 17T209 251Q209 962 573 1361Q596 1386 616 1405T649 1437T664 1450H695Q701 1444 701 1441Q701 1436 681 1415T629 1356T557 1261T476 1118T400 927T340 675T308 359Q306 321 306 250Q306 -139 400 -430T690 -924Q701 -936 701 -940Z"></path></g><g data-mml-node="mfrac" transform="translate(736,0)"><g data-mml-node="mrow" transform="translate(220,676)"><g data-mml-node="mi"><path data-c="1D444" d="M399 -80Q399 -47 400 -30T402 -11V-7L387 -11Q341 -22 303 -22Q208 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435Q740 255 592 107Q529 47 461 16L444 8V3Q444 2 449 -24T470 -66T516 -82Q551 -82 583 -60T625 -3Q631 11 638 11Q647 11 649 2Q649 -6 639 -34T611 -100T557 -165T481 -194Q399 -194 399 -87V-80ZM636 468Q636 523 621 564T580 625T530 655T477 665Q429 665 379 640Q277 591 215 464T153 216Q153 110 207 59Q231 38 236 38V46Q236 86 269 120T347 155Q372 155 390 144T417 114T429 82T435 55L448 64Q512 108 557 185T619 334T636 468ZM314 18Q362 18 404 39L403 49Q399 104 366 115Q354 117 347 117Q344 117 341 117T337 118Q317 118 296 98T274 52Q274 18 314 18Z"></path></g><g data-mml-node="msup" transform="translate(791,0)"><g data-mml-node="mi"><path data-c="1D43E" d="M285 628Q285 635 228 637Q205 637 198 638T191 647Q191 649 193 661Q199 681 203 682Q205 683 214 683H219Q260 681 355 681Q389 681 418 681T463 682T483 682Q500 682 500 674Q500 669 497 660Q496 658 496 654T495 648T493 644T490 641T486 639T479 638T470 637T456 637Q416 636 405 634T387 623L306 305Q307 305 490 449T678 597Q692 611 692 620Q692 635 667 637Q651 637 651 648Q651 650 654 662T659 677Q662 682 676 682Q680 682 711 681T791 680Q814 680 839 681T869 682Q889 682 889 672Q889 650 881 642Q878 637 862 637Q787 632 726 586Q710 576 656 534T556 455L509 418L518 396Q527 374 546 329T581 244Q656 67 661 61Q663 59 666 57Q680 47 717 46H738Q744 38 744 37T741 19Q737 6 731 0H720Q680 3 625 3Q503 3 488 0H478Q472 6 472 9T474 27Q478 40 480 43T491 46H494Q544 46 544 71Q544 75 517 141T485 216L427 354L359 301L291 248L268 155Q245 63 245 58Q245 51 253 49T303 46H334Q340 37 340 35Q340 19 333 5Q328 0 317 0Q314 0 280 1T180 2Q118 2 85 2T49 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Z"></path></g><g data-mml-node="mi" transform="translate(974,363) scale(0.707)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g></g></g><g data-mml-node="msqrt" transform="translate(464.2,-855.6)"><g transform="translate(853,0)"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mi" transform="translate(553,-150) scale(0.707)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g></g></g><g data-mml-node="mo" transform="translate(0,35.6)"><path data-c="221A" d="M95 178Q89 178 81 186T72 200T103 230T169 280T207 309Q209 311 212 311H213Q219 311 227 294T281 177Q300 134 312 108L397 -77Q398 -77 501 136T707 565T814 786Q820 800 834 800Q841 800 846 794T853 782V776L620 293L385 -193Q381 -200 366 -200Q357 -200 354 -197Q352 -195 256 15L160 225L144 214Q129 202 113 190T95 178Z"></path></g><rect width="971.4" height="60" x="853" y="775.6"></rect></g><rect width="2512.8" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(3488.8,0) translate(0 -0.5)"><path data-c="29" d="M34 1438Q34 1446 37 1448T50 1450H56H71Q73 1448 99 1423T144 1380T198 1319T260 1238T323 1137T385 1013T440 864T485 688T514 485T526 251Q526 134 519 53Q472 -519 162 -860Q139 -885 119 -904T86 -936T71 -949H56Q43 -949 39 -947T34 -937Q88 -883 140 -813Q428 -430 428 251Q428 453 402 628T338 922T245 1146T145 1309T46 1425Q44 1427 42 1429T39 1433T36 1436L34 1438Z"></path></g></g><g data-mml-node="mi" transform="translate(17542.4,0)"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"></path></g></g></g></svg></mjx-container><br>其中，( Q ) 是查询矩阵，( K ) 是键矩阵，( V ) 是值矩阵，( d_k ) 是键向量的维度。</p>
</li>
<li><p><strong>多头注意力（Multi-Head Attention）</strong>：<br>通过并行的多个注意力头来学习不同的特征表示：<br><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="58.68ex" height="2.626ex" role="img" focusable="false" viewBox="0 -910.8 25936.7 1160.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mtext"><path data-c="4D" d="M132 622Q125 629 121 631T105 634T62 637H29V683H135Q221 683 232 682T249 675Q250 674 354 398L458 124L562 398Q666 674 668 675Q671 681 683 682T781 683H887V637H854Q814 636 803 634T785 622V61Q791 51 802 49T854 46H887V0H876Q855 3 736 3Q605 3 596 0H585V46H618Q660 47 669 49T688 61V347Q688 424 688 461T688 546T688 613L687 632Q454 14 450 7Q446 1 430 1T410 7Q409 9 292 316L176 624V606Q175 588 175 543T175 463T175 356L176 86Q187 50 261 46H278V0H269Q254 3 154 3Q52 3 37 0H29V46H46Q78 48 98 56T122 69T132 86V622Z"></path><path data-c="75" d="M383 58Q327 -10 256 -10H249Q124 -10 105 89Q104 96 103 226Q102 335 102 348T96 369Q86 385 36 385H25V408Q25 431 27 431L38 432Q48 433 67 434T105 436Q122 437 142 438T172 441T184 442H187V261Q188 77 190 64Q193 49 204 40Q224 26 264 26Q290 26 311 35T343 58T363 90T375 120T379 144Q379 145 379 161T380 201T380 248V315Q380 361 370 372T320 385H302V431Q304 431 378 436T457 442H464V264Q464 84 465 81Q468 61 479 55T524 46H542V0Q540 0 467 -5T390 -11H383V58Z" transform="translate(917,0)"></path><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z" transform="translate(1473,0)"></path><path data-c="74" d="M27 422Q80 426 109 478T141 600V615H181V431H316V385H181V241Q182 116 182 100T189 68Q203 29 238 29Q282 29 292 100Q293 108 293 146V181H333V146V134Q333 57 291 17Q264 -10 221 -10Q187 -10 162 2T124 33T105 68T98 100Q97 107 97 248V385H18V422H27Z" transform="translate(1751,0)"></path><path data-c="69" d="M69 609Q69 637 87 653T131 669Q154 667 171 652T188 609Q188 579 171 564T129 549Q104 549 87 564T69 609ZM247 0Q232 3 143 3Q132 3 106 3T56 1L34 0H26V46H42Q70 46 91 49Q100 53 102 60T104 102V205V293Q104 345 102 359T88 378Q74 385 41 385H30V408Q30 431 32 431L42 432Q52 433 70 434T106 436Q123 437 142 438T171 441T182 442H185V62Q190 52 197 50T232 46H255V0H247Z" transform="translate(2140,0)"></path><path data-c="48" d="M128 622Q121 629 117 631T101 634T58 637H25V683H36Q57 680 180 680Q315 680 324 683H335V637H302Q262 636 251 634T233 622L232 500V378H517V622Q510 629 506 631T490 634T447 637H414V683H425Q446 680 569 680Q704 680 713 683H724V637H691Q651 636 640 634T622 622V61Q628 51 639 49T691 46H724V0H713Q692 3 569 3Q434 3 425 0H414V46H447Q489 47 498 49T517 61V332H232V197L233 61Q239 51 250 49T302 46H335V0H324Q303 3 180 3Q45 3 36 0H25V46H58Q100 47 109 49T128 61V622Z" transform="translate(2418,0)"></path><path data-c="65" d="M28 218Q28 273 48 318T98 391T163 433T229 448Q282 448 320 430T378 380T406 316T415 245Q415 238 408 231H126V216Q126 68 226 36Q246 30 270 30Q312 30 342 62Q359 79 369 104L379 128Q382 131 395 131H398Q415 131 415 121Q415 117 412 108Q393 53 349 21T250 -11Q155 -11 92 58T28 218ZM333 275Q322 403 238 411H236Q228 411 220 410T195 402T166 381T143 340T127 274V267H333V275Z" transform="translate(3168,0)"></path><path data-c="61" d="M137 305T115 305T78 320T63 359Q63 394 97 421T218 448Q291 448 336 416T396 340Q401 326 401 309T402 194V124Q402 76 407 58T428 40Q443 40 448 56T453 109V145H493V106Q492 66 490 59Q481 29 455 12T400 -6T353 12T329 54V58L327 55Q325 52 322 49T314 40T302 29T287 17T269 6T247 -2T221 -8T190 -11Q130 -11 82 20T34 107Q34 128 41 147T68 188T116 225T194 253T304 268H318V290Q318 324 312 340Q290 411 215 411Q197 411 181 410T156 406T148 403Q170 388 170 359Q170 334 154 320ZM126 106Q126 75 150 51T209 26Q247 26 276 49T315 109Q317 116 318 175Q318 233 317 233Q309 233 296 232T251 223T193 203T147 166T126 106Z" transform="translate(3612,0)"></path><path data-c="64" d="M376 495Q376 511 376 535T377 568Q377 613 367 624T316 637H298V660Q298 683 300 683L310 684Q320 685 339 686T376 688Q393 689 413 690T443 693T454 694H457V390Q457 84 458 81Q461 61 472 55T517 46H535V0Q533 0 459 -5T380 -11H373V44L365 37Q307 -11 235 -11Q158 -11 96 50T34 215Q34 315 97 378T244 442Q319 442 376 393V495ZM373 342Q328 405 260 405Q211 405 173 369Q146 341 139 305T131 211Q131 155 138 120T173 59Q203 26 251 26Q322 26 373 103V342Z" transform="translate(4112,0)"></path></g><g data-mml-node="mo" transform="translate(4668,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(5057,0)"><path data-c="1D444" d="M399 -80Q399 -47 400 -30T402 -11V-7L387 -11Q341 -22 303 -22Q208 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435Q740 255 592 107Q529 47 461 16L444 8V3Q444 2 449 -24T470 -66T516 -82Q551 -82 583 -60T625 -3Q631 11 638 11Q647 11 649 2Q649 -6 639 -34T611 -100T557 -165T481 -194Q399 -194 399 -87V-80ZM636 468Q636 523 621 564T580 625T530 655T477 665Q429 665 379 640Q277 591 215 464T153 216Q153 110 207 59Q231 38 236 38V46Q236 86 269 120T347 155Q372 155 390 144T417 114T429 82T435 55L448 64Q512 108 557 185T619 334T636 468ZM314 18Q362 18 404 39L403 49Q399 104 366 115Q354 117 347 117Q344 117 341 117T337 118Q317 118 296 98T274 52Q274 18 314 18Z"></path></g><g data-mml-node="mo" transform="translate(5848,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(6292.7,0)"><path data-c="1D43E" d="M285 628Q285 635 228 637Q205 637 198 638T191 647Q191 649 193 661Q199 681 203 682Q205 683 214 683H219Q260 681 355 681Q389 681 418 681T463 682T483 682Q500 682 500 674Q500 669 497 660Q496 658 496 654T495 648T493 644T490 641T486 639T479 638T470 637T456 637Q416 636 405 634T387 623L306 305Q307 305 490 449T678 597Q692 611 692 620Q692 635 667 637Q651 637 651 648Q651 650 654 662T659 677Q662 682 676 682Q680 682 711 681T791 680Q814 680 839 681T869 682Q889 682 889 672Q889 650 881 642Q878 637 862 637Q787 632 726 586Q710 576 656 534T556 455L509 418L518 396Q527 374 546 329T581 244Q656 67 661 61Q663 59 666 57Q680 47 717 46H738Q744 38 744 37T741 19Q737 6 731 0H720Q680 3 625 3Q503 3 488 0H478Q472 6 472 9T474 27Q478 40 480 43T491 46H494Q544 46 544 71Q544 75 517 141T485 216L427 354L359 301L291 248L268 155Q245 63 245 58Q245 51 253 49T303 46H334Q340 37 340 35Q340 19 333 5Q328 0 317 0Q314 0 280 1T180 2Q118 2 85 2T49 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Z"></path></g><g data-mml-node="mo" transform="translate(7181.7,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(7626.3,0)"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"></path></g><g data-mml-node="mo" transform="translate(8395.3,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(9062.1,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mtext" transform="translate(10117.9,0)"><path data-c="43" d="M56 342Q56 428 89 500T174 615T283 681T391 705Q394 705 400 705T408 704Q499 704 569 636L582 624L612 663Q639 700 643 704Q644 704 647 704T653 705H657Q660 705 666 699V419L660 413H626Q620 419 619 430Q610 512 571 572T476 651Q457 658 426 658Q322 658 252 588Q173 509 173 342Q173 221 211 151Q232 111 263 84T328 45T384 29T428 24Q517 24 571 93T626 244Q626 251 632 257H660L666 251V236Q661 133 590 56T403 -21Q262 -21 159 83T56 342Z"></path><path data-c="6F" d="M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z" transform="translate(722,0)"></path><path data-c="6E" d="M41 46H55Q94 46 102 60V68Q102 77 102 91T102 122T103 161T103 203Q103 234 103 269T102 328V351Q99 370 88 376T43 385H25V408Q25 431 27 431L37 432Q47 433 65 434T102 436Q119 437 138 438T167 441T178 442H181V402Q181 364 182 364T187 369T199 384T218 402T247 421T285 437Q305 442 336 442Q450 438 463 329Q464 322 464 190V104Q464 66 466 59T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z" transform="translate(1222,0)"></path><path data-c="63" d="M370 305T349 305T313 320T297 358Q297 381 312 396Q317 401 317 402T307 404Q281 408 258 408Q209 408 178 376Q131 329 131 219Q131 137 162 90Q203 29 272 29Q313 29 338 55T374 117Q376 125 379 127T395 129H409Q415 123 415 120Q415 116 411 104T395 71T366 33T318 2T249 -11Q163 -11 99 53T34 214Q34 318 99 383T250 448T370 421T404 357Q404 334 387 320Z" transform="translate(1778,0)"></path><path data-c="61" d="M137 305T115 305T78 320T63 359Q63 394 97 421T218 448Q291 448 336 416T396 340Q401 326 401 309T402 194V124Q402 76 407 58T428 40Q443 40 448 56T453 109V145H493V106Q492 66 490 59Q481 29 455 12T400 -6T353 12T329 54V58L327 55Q325 52 322 49T314 40T302 29T287 17T269 6T247 -2T221 -8T190 -11Q130 -11 82 20T34 107Q34 128 41 147T68 188T116 225T194 253T304 268H318V290Q318 324 312 340Q290 411 215 411Q197 411 181 410T156 406T148 403Q170 388 170 359Q170 334 154 320ZM126 106Q126 75 150 51T209 26Q247 26 276 49T315 109Q317 116 318 175Q318 233 317 233Q309 233 296 232T251 223T193 203T147 166T126 106Z" transform="translate(2222,0)"></path><path data-c="74" d="M27 422Q80 426 109 478T141 600V615H181V431H316V385H181V241Q182 116 182 100T189 68Q203 29 238 29Q282 29 292 100Q293 108 293 146V181H333V146V134Q333 57 291 17Q264 -10 221 -10Q187 -10 162 2T124 33T105 68T98 100Q97 107 97 248V385H18V422H27Z" transform="translate(2722,0)"></path></g><g data-mml-node="mo" transform="translate(13228.9,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msub" transform="translate(13617.9,0)"><g data-mml-node="mtext"><path data-c="68" d="M41 46H55Q94 46 102 60V68Q102 77 102 91T102 124T102 167T103 217T103 272T103 329Q103 366 103 407T103 482T102 542T102 586T102 603Q99 622 88 628T43 637H25V660Q25 683 27 683L37 684Q47 685 66 686T103 688Q120 689 140 690T170 693T181 694H184V367Q244 442 328 442Q451 442 463 329Q464 322 464 190V104Q464 66 466 59T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z"></path><path data-c="65" d="M28 218Q28 273 48 318T98 391T163 433T229 448Q282 448 320 430T378 380T406 316T415 245Q415 238 408 231H126V216Q126 68 226 36Q246 30 270 30Q312 30 342 62Q359 79 369 104L379 128Q382 131 395 131H398Q415 131 415 121Q415 117 412 108Q393 53 349 21T250 -11Q155 -11 92 58T28 218ZM333 275Q322 403 238 411H236Q228 411 220 410T195 402T166 381T143 340T127 274V267H333V275Z" transform="translate(556,0)"></path><path data-c="61" d="M137 305T115 305T78 320T63 359Q63 394 97 421T218 448Q291 448 336 416T396 340Q401 326 401 309T402 194V124Q402 76 407 58T428 40Q443 40 448 56T453 109V145H493V106Q492 66 490 59Q481 29 455 12T400 -6T353 12T329 54V58L327 55Q325 52 322 49T314 40T302 29T287 17T269 6T247 -2T221 -8T190 -11Q130 -11 82 20T34 107Q34 128 41 147T68 188T116 225T194 253T304 268H318V290Q318 324 312 340Q290 411 215 411Q197 411 181 410T156 406T148 403Q170 388 170 359Q170 334 154 320ZM126 106Q126 75 150 51T209 26Q247 26 276 49T315 109Q317 116 318 175Q318 233 317 233Q309 233 296 232T251 223T193 203T147 166T126 106Z" transform="translate(1000,0)"></path><path data-c="64" d="M376 495Q376 511 376 535T377 568Q377 613 367 624T316 637H298V660Q298 683 300 683L310 684Q320 685 339 686T376 688Q393 689 413 690T443 693T454 694H457V390Q457 84 458 81Q461 61 472 55T517 46H535V0Q533 0 459 -5T380 -11H373V44L365 37Q307 -11 235 -11Q158 -11 96 50T34 215Q34 315 97 378T244 442Q319 442 376 393V495ZM373 342Q328 405 260 405Q211 405 173 369Q146 341 139 305T131 211Q131 155 138 120T173 59Q203 26 251 26Q322 26 373 103V342Z" transform="translate(1500,0)"></path></g><g data-mml-node="mn" transform="translate(2089,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g><g data-mml-node="mo" transform="translate(16110.4,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msub" transform="translate(16555.1,0)"><g data-mml-node="mtext"><path data-c="68" d="M41 46H55Q94 46 102 60V68Q102 77 102 91T102 124T102 167T103 217T103 272T103 329Q103 366 103 407T103 482T102 542T102 586T102 603Q99 622 88 628T43 637H25V660Q25 683 27 683L37 684Q47 685 66 686T103 688Q120 689 140 690T170 693T181 694H184V367Q244 442 328 442Q451 442 463 329Q464 322 464 190V104Q464 66 466 59T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z"></path><path data-c="65" d="M28 218Q28 273 48 318T98 391T163 433T229 448Q282 448 320 430T378 380T406 316T415 245Q415 238 408 231H126V216Q126 68 226 36Q246 30 270 30Q312 30 342 62Q359 79 369 104L379 128Q382 131 395 131H398Q415 131 415 121Q415 117 412 108Q393 53 349 21T250 -11Q155 -11 92 58T28 218ZM333 275Q322 403 238 411H236Q228 411 220 410T195 402T166 381T143 340T127 274V267H333V275Z" transform="translate(556,0)"></path><path data-c="61" d="M137 305T115 305T78 320T63 359Q63 394 97 421T218 448Q291 448 336 416T396 340Q401 326 401 309T402 194V124Q402 76 407 58T428 40Q443 40 448 56T453 109V145H493V106Q492 66 490 59Q481 29 455 12T400 -6T353 12T329 54V58L327 55Q325 52 322 49T314 40T302 29T287 17T269 6T247 -2T221 -8T190 -11Q130 -11 82 20T34 107Q34 128 41 147T68 188T116 225T194 253T304 268H318V290Q318 324 312 340Q290 411 215 411Q197 411 181 410T156 406T148 403Q170 388 170 359Q170 334 154 320ZM126 106Q126 75 150 51T209 26Q247 26 276 49T315 109Q317 116 318 175Q318 233 317 233Q309 233 296 232T251 223T193 203T147 166T126 106Z" transform="translate(1000,0)"></path><path data-c="64" d="M376 495Q376 511 376 535T377 568Q377 613 367 624T316 637H298V660Q298 683 300 683L310 684Q320 685 339 686T376 688Q393 689 413 690T443 693T454 694H457V390Q457 84 458 81Q461 61 472 55T517 46H535V0Q533 0 459 -5T380 -11H373V44L365 37Q307 -11 235 -11Q158 -11 96 50T34 215Q34 315 97 378T244 442Q319 442 376 393V495ZM373 342Q328 405 260 405Q211 405 173 369Q146 341 139 305T131 211Q131 155 138 120T173 59Q203 26 251 26Q322 26 373 103V342Z" transform="translate(1500,0)"></path></g><g data-mml-node="mn" transform="translate(2089,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(19047.7,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mo" transform="translate(19492.3,0)"><path data-c="2026" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60ZM525 60Q525 84 542 102T585 120Q609 120 627 104T646 61Q646 36 629 18T586 0T543 17T525 60ZM972 60Q972 84 989 102T1032 120Q1056 120 1074 104T1093 61Q1093 36 1076 18T1033 0T990 17T972 60Z"></path></g><g data-mml-node="mo" transform="translate(20831,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msub" transform="translate(21275.7,0)"><g data-mml-node="mtext"><path data-c="68" d="M41 46H55Q94 46 102 60V68Q102 77 102 91T102 124T102 167T103 217T103 272T103 329Q103 366 103 407T103 482T102 542T102 586T102 603Q99 622 88 628T43 637H25V660Q25 683 27 683L37 684Q47 685 66 686T103 688Q120 689 140 690T170 693T181 694H184V367Q244 442 328 442Q451 442 463 329Q464 322 464 190V104Q464 66 466 59T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z"></path><path data-c="65" d="M28 218Q28 273 48 318T98 391T163 433T229 448Q282 448 320 430T378 380T406 316T415 245Q415 238 408 231H126V216Q126 68 226 36Q246 30 270 30Q312 30 342 62Q359 79 369 104L379 128Q382 131 395 131H398Q415 131 415 121Q415 117 412 108Q393 53 349 21T250 -11Q155 -11 92 58T28 218ZM333 275Q322 403 238 411H236Q228 411 220 410T195 402T166 381T143 340T127 274V267H333V275Z" transform="translate(556,0)"></path><path data-c="61" d="M137 305T115 305T78 320T63 359Q63 394 97 421T218 448Q291 448 336 416T396 340Q401 326 401 309T402 194V124Q402 76 407 58T428 40Q443 40 448 56T453 109V145H493V106Q492 66 490 59Q481 29 455 12T400 -6T353 12T329 54V58L327 55Q325 52 322 49T314 40T302 29T287 17T269 6T247 -2T221 -8T190 -11Q130 -11 82 20T34 107Q34 128 41 147T68 188T116 225T194 253T304 268H318V290Q318 324 312 340Q290 411 215 411Q197 411 181 410T156 406T148 403Q170 388 170 359Q170 334 154 320ZM126 106Q126 75 150 51T209 26Q247 26 276 49T315 109Q317 116 318 175Q318 233 317 233Q309 233 296 232T251 223T193 203T147 166T126 106Z" transform="translate(1000,0)"></path><path data-c="64" d="M376 495Q376 511 376 535T377 568Q377 613 367 624T316 637H298V660Q298 683 300 683L310 684Q320 685 339 686T376 688Q393 689 413 690T443 693T454 694H457V390Q457 84 458 81Q461 61 472 55T517 46H535V0Q533 0 459 -5T380 -11H373V44L365 37Q307 -11 235 -11Q158 -11 96 50T34 215Q34 315 97 378T244 442Q319 442 376 393V495ZM373 342Q328 405 260 405Q211 405 173 369Q146 341 139 305T131 211Q131 155 138 120T173 59Q203 26 251 26Q322 26 373 103V342Z" transform="translate(1500,0)"></path></g><g data-mml-node="mi" transform="translate(2089,-150) scale(0.707)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"></path></g></g><g data-mml-node="mo" transform="translate(23822,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="msup" transform="translate(24211,0)"><g data-mml-node="mi"><path data-c="1D44A" d="M436 683Q450 683 486 682T553 680Q604 680 638 681T677 682Q695 682 695 674Q695 670 692 659Q687 641 683 639T661 637Q636 636 621 632T600 624T597 615Q597 603 613 377T629 138L631 141Q633 144 637 151T649 170T666 200T690 241T720 295T759 362Q863 546 877 572T892 604Q892 619 873 628T831 637Q817 637 817 647Q817 650 819 660Q823 676 825 679T839 682Q842 682 856 682T895 682T949 681Q1015 681 1034 683Q1048 683 1048 672Q1048 666 1045 655T1038 640T1028 637Q1006 637 988 631T958 617T939 600T927 584L923 578L754 282Q586 -14 585 -15Q579 -22 561 -22Q546 -22 542 -17Q539 -14 523 229T506 480L494 462Q472 425 366 239Q222 -13 220 -15T215 -19Q210 -22 197 -22Q178 -22 176 -15Q176 -12 154 304T131 622Q129 631 121 633T82 637H58Q51 644 51 648Q52 671 64 683H76Q118 680 176 680Q301 680 313 683H323Q329 677 329 674T327 656Q322 641 318 637H297Q236 634 232 620Q262 160 266 136L501 550L499 587Q496 629 489 632Q483 636 447 637Q428 637 422 639T416 648Q416 650 418 660Q419 664 420 669T421 676T424 680T428 682T436 683Z"></path></g><g data-mml-node="mi" transform="translate(1136.2,413) scale(0.707)"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g></g></g></g></svg></mjx-container><br>每个头的计算方法类似，但使用不同的参数。</p>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Transformer模型通过并行化的多头自注意力机制和前馈神经网络，极大地提高了序列到序列任务的效率和性能。它在许多自然语言处理任务中都取得了显著的成功，并成为了现代自然语言处理的基石。</p>
<h2 id="2-为什么要用-SwimTransformer-而不用cnn"><a href="#2-为什么要用-SwimTransformer-而不用cnn" class="headerlink" title="2. 为什么要用 SwimTransformer 而不用cnn"></a>2. 为什么要用 SwimTransformer 而不用cnn</h2><p>Swin Transformer 和 CNN（卷积神经网络）在架构和处理图像的方式上有显著的区别。以下是对这两者的详细比较以及Swin Transformer的优势：</p>
<h3 id="1-架构区别"><a href="#1-架构区别" class="headerlink" title="1. 架构区别"></a>1. 架构区别</h3><h4 id="CNN（卷积神经网络）"><a href="#CNN（卷积神经网络）" class="headerlink" title="CNN（卷积神经网络）"></a>CNN（卷积神经网络）</h4><ul>
<li><strong>基本单元</strong>：卷积层（Convolutional Layer），通过卷积核（filter）提取局部特征。</li>
<li><strong>特征提取方式</strong>：局部感受野（Local Receptive Field），在输入图像的局部区域内滑动卷积核进行特征提取。</li>
<li><strong>池化层（Pooling Layer）</strong>：用于下采样，减小特征图尺寸，通常使用最大池化（Max Pooling）或平均池化（Average Pooling）。</li>
<li><strong>层次结构</strong>：通常由多个卷积层、池化层和全连接层（Fully Connected Layer）堆叠而成。</li>
</ul>
<h4 id="Swin-Transformer（滑动窗口Transformer）"><a href="#Swin-Transformer（滑动窗口Transformer）" class="headerlink" title="Swin Transformer（滑动窗口Transformer）"></a>Swin Transformer（滑动窗口Transformer）</h4><ul>
<li><strong>基本单元</strong>：Transformer编码器层（Transformer Encoder Layer），采用自注意力机制（Self-Attention Mechanism）。</li>
<li><strong>特征提取方式</strong>：通过滑动窗口（Sliding Window）进行局部注意力计算，划分图像为不重叠的窗口，在每个窗口内计算自注意力。</li>
<li><strong>分层结构</strong>：包括多层Swin Transformer块，每个块包含局部注意力机制、跨窗口连接和前馈网络。</li>
<li><strong>多尺度表示</strong>：通过分层设计实现多尺度特征提取，类似于CNN中的层次结构，但更灵活。</li>
</ul>
<h3 id="2-优势比较"><a href="#2-优势比较" class="headerlink" title="2. 优势比较"></a>2. 优势比较</h3><h4 id="CNN-的优势"><a href="#CNN-的优势" class="headerlink" title="CNN 的优势"></a>CNN 的优势</h4><ol>
<li><strong>计算效率高</strong>：卷积操作在计算和内存上都非常高效，特别适合在图像处理中应用。</li>
<li><strong>局部特征提取</strong>：擅长提取局部特征，如边缘、纹理等，适用于大多数图像识别任务。</li>
<li><strong>结构简单</strong>：卷积层和池化层的设计简单明了，易于理解和实现。</li>
</ol>
<h4 id="Swin-Transformer-的优势"><a href="#Swin-Transformer-的优势" class="headerlink" title="Swin Transformer 的优势"></a>Swin Transformer 的优势</h4><ol>
<li><strong>全局建模能力</strong>：通过自注意力机制，能够在整个图像范围内建立全局上下文关系，而不仅仅局限于局部区域。</li>
<li><strong>灵活的窗口设计</strong>：滑动窗口机制结合了局部和全局特征提取的优势，通过窗口内和跨窗口的注意力计算，能够更好地捕捉多尺度信息。</li>
<li><strong>适应性强</strong>：可以通过改变窗口大小和层数，灵活调整模型以适应不同规模和复杂度的任务。</li>
<li><strong>统一架构</strong>：Transformer架构在自然语言处理和计算机视觉任务中的成功应用，表明其在处理不同类型数据上的强大适应性。</li>
</ol>
<h3 id="为什么使用-Swin-Transformer-而不是-CNN"><a href="#为什么使用-Swin-Transformer-而不是-CNN" class="headerlink" title="为什么使用 Swin Transformer 而不是 CNN"></a>为什么使用 Swin Transformer 而不是 CNN</h3><ol>
<li><strong>全局特征提取</strong>：Swin Transformer的自注意力机制可以在整个图像上建模长距离依赖关系，适合处理需要全局上下文信息的任务，如目标检测和语义分割。</li>
<li><strong>多尺度特征</strong>：通过滑动窗口和分层设计，Swin Transformer能够更好地捕捉不同尺度的特征，这在多尺度特征非常重要的任务中表现出色。</li>
<li><strong>灵活性和扩展性</strong>：Swin Transformer具有很强的灵活性，可以方便地扩展和调整以适应不同的任务和数据规模。而CNN的结构较为固定，适应性相对较差。</li>
<li><strong>一致性和统一性</strong>：Transformer在不同任务中的成功应用，使其成为一种通用的架构，便于在不同任务之间共享和转移学习，而不需要设计不同的模型。</li>
</ol>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>虽然CNN在计算效率和局部特征提取方面具有优势，但Swin Transformer通过结合自注意力机制和滑动窗口设计，实现了更强的全局建模能力和多尺度特征提取能力，适应性更强，尤其在处理复杂图像任务时表现出色。因此，在需要全局上下文信息和多尺度特征的任务中，使用Swin Transformer往往能够获得更好的效果。</p>
<h2 id="3-为什么transformer-需要mask（掩码）"><a href="#3-为什么transformer-需要mask（掩码）" class="headerlink" title="3.为什么transformer 需要mask（掩码）"></a>3.为什么transformer 需要mask（掩码）</h2><p>Transformer中的mask（掩码）在不同的阶段和子模块中有不同的用途，主要是为了控制注意力机制的范围和确保模型生成输出时的正确性。以下是Transformer中不同类型mask的详细说明及其原因：</p>
<h3 id="1-自注意力中的Mask（Self-Attention-Mask）"><a href="#1-自注意力中的Mask（Self-Attention-Mask）" class="headerlink" title="1. 自注意力中的Mask（Self-Attention Mask）"></a>1. 自注意力中的Mask（Self-Attention Mask）</h3><h4 id="a-Padding-Mask（填充掩码）"><a href="#a-Padding-Mask（填充掩码）" class="headerlink" title="a. Padding Mask（填充掩码）"></a>a. Padding Mask（填充掩码）</h4><ul>
<li><strong>用途</strong>：用于忽略填充部分的影响。</li>
<li><strong>位置</strong>：在输入序列中。</li>
<li><strong>原因</strong>：在处理变长序列时，输入序列通常被填充到相同长度。填充部分（通常是零）不应该影响注意力机制的计算，因此使用填充掩码来忽略这些位置。</li>
<li><strong>实现</strong>：将填充位置的注意力分数设为负无穷大，以确保softmax后的注意力权重为零。</li>
</ul>
<h4 id="b-Look-Ahead-Mask（前瞻掩码，也称为Causal-Mask-未来掩码）"><a href="#b-Look-Ahead-Mask（前瞻掩码，也称为Causal-Mask-未来掩码）" class="headerlink" title="b. Look-Ahead Mask（前瞻掩码，也称为Causal Mask/未来掩码）"></a>b. Look-Ahead Mask（前瞻掩码，也称为Causal Mask/未来掩码）</h4><ul>
<li><strong>用途</strong>：确保在解码阶段，每个位置只能看到当前及之前的位置，不能看到未来的位置。</li>
<li><strong>位置</strong>：在解码器中的自注意力层。</li>
<li><strong>原因</strong>：在序列生成任务中（如语言模型或翻译），当前步骤的输出不能依赖未来的输入，因此需要前瞻掩码来阻止模型在当前时间步关注到未来时间步的信息。</li>
<li><strong>实现</strong>：通过一个上三角矩阵来掩盖未来位置，将未来位置的注意力分数设为负无穷大。</li>
</ul>
<h3 id="2-编码器-解码器注意力中的Mask"><a href="#2-编码器-解码器注意力中的Mask" class="headerlink" title="2. 编码器-解码器注意力中的Mask"></a>2. 编码器-解码器注意力中的Mask</h3><h4 id="a-Padding-Mask"><a href="#a-Padding-Mask" class="headerlink" title="a. Padding Mask"></a>a. Padding Mask</h4><ul>
<li><strong>用途</strong>：在编码器-解码器注意力中，解码器需要关注编码器的输出，因此也需要忽略填充部分的影响。</li>
<li><strong>位置</strong>：在解码器的编码器-解码器注意力层。</li>
<li><strong>原因</strong>：类似于自注意力中的填充掩码，确保解码器不会在注意力计算中考虑编码器输出中的填充位置。</li>
<li><strong>实现</strong>：与自注意力中的填充掩码相同，将填充位置的注意力分数设为负无穷大。</li>
</ul>
<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><h4 id="为什么需要Mask？"><a href="#为什么需要Mask？" class="headerlink" title="为什么需要Mask？"></a>为什么需要Mask？</h4><ol>
<li><strong>处理变长输入</strong>：保证填充部分不会影响注意力机制的计算，确保模型只关注实际输入部分。</li>
<li><strong>保证因果性</strong>：在序列生成任务中，保证生成的每一步只依赖于当前及之前的信息，而不泄露未来的信息。</li>
<li><strong>提高模型性能</strong>：通过适当的掩码操作，可以提高模型训练的有效性和稳定性，避免无意义的注意力计算。</li>
</ol>
<h3 id="实际例子"><a href="#实际例子" class="headerlink" title="实际例子"></a>实际例子</h3><h4 id="自注意力中的Look-Ahead-Mask"><a href="#自注意力中的Look-Ahead-Mask" class="headerlink" title="自注意力中的Look-Ahead Mask"></a>自注意力中的Look-Ahead Mask</h4><p>假设我们有一个输入序列<code>[A, B, C, D]</code>，在生成时，模型不应该在生成<code>B</code>时看到<code>C</code>和<code>D</code>。</p>
<p>生成Look-Ahead Mask的矩阵如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line"> [0, -inf, -inf, -inf],</span><br><span class="line"> [0, 0, -inf, -inf],</span><br><span class="line"> [0, 0, 0, -inf],</span><br><span class="line"> [0, 0, 0, 0]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>在这个矩阵中，<code>0</code>表示可以关注，<code>-inf</code>表示掩盖。</p>
<h4 id="Padding-Mask"><a href="#Padding-Mask" class="headerlink" title="Padding Mask"></a>Padding Mask</h4><p>假设输入序列<code>[A, B, PAD, PAD]</code>，<code>PAD</code>表示填充位置。</p>
<p>生成的Padding Mask如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line"> [1, 1, 0, 0]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>在这个向量中，<code>1</code>表示实际输入位置，<code>0</code>表示填充位置。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>Mask在Transformer中起到了重要的作用，通过控制注意力机制的范围，确保模型在训练和推理过程中关注正确的信息，提高模型的性能和稳定性。</p>
<p>这是一个行内公式：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="16.403ex" height="2.072ex" role="img" focusable="false" viewBox="0 -833.9 7250 915.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="msup" transform="translate(529,0)"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mn" transform="translate(605,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(1759.8,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(2760,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mi" transform="translate(3189,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(3983.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(4983.4,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g><g data-mml-node="mo" transform="translate(5694.2,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(6750,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g></svg></mjx-container>。这是另一个行内公式：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="16.403ex" height="2.072ex" role="img" focusable="false" viewBox="0 -833.9 7250 915.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="msup" transform="translate(529,0)"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mn" transform="translate(605,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(1759.8,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(2760,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mi" transform="translate(3189,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(3983.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(4983.4,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g><g data-mml-node="mo" transform="translate(5694.2,0)"><path data-c="3E" d="M84 520Q84 528 88 533T96 539L99 540Q106 540 253 471T544 334L687 265Q694 260 694 250T687 235Q685 233 395 96L107 -40H101Q83 -38 83 -20Q83 -19 83 -17Q82 -10 98 -1Q117 9 248 71Q326 108 378 132L626 250L378 368Q90 504 86 509Q84 513 84 520Z"></path></g><g data-mml-node="mn" transform="translate(6750,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g></svg></mjx-container>。</p>
<p>这是一个块状公式：<br><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -5.313ex;" xmlns="http://www.w3.org/2000/svg" width="38.217ex" height="8.729ex" role="img" focusable="false" viewBox="0 -1509.9 16891.9 3858.2"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mfrac"><g data-mml-node="mn" transform="translate(3717.3,676)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mrow" transform="translate(220,-1359.8)"><g data-mml-node="TeXAtom" data-mjx-texclass="OPEN"><g data-mml-node="mo" transform="translate(0 -0.5)"><path data-c="28" d="M180 96T180 250T205 541T266 770T353 944T444 1069T527 1150H555Q561 1144 561 1141Q561 1137 545 1120T504 1072T447 995T386 878T330 721T288 513T272 251Q272 133 280 56Q293 -87 326 -209T399 -405T475 -531T536 -609T561 -640Q561 -643 555 -649H527Q483 -612 443 -568T353 -443T266 -270T205 -41Z"></path></g></g><g data-mml-node="msqrt" transform="translate(597,0)"><g transform="translate(1020,0)"><g data-mml-node="mi"><path data-c="1D719" d="M409 688Q413 694 421 694H429H442Q448 688 448 686Q448 679 418 563Q411 535 404 504T392 458L388 442Q388 441 397 441T429 435T477 418Q521 397 550 357T579 260T548 151T471 65T374 11T279 -10H275L251 -105Q245 -128 238 -160Q230 -192 227 -198T215 -205H209Q189 -205 189 -198Q189 -193 211 -103L234 -11Q234 -10 226 -10Q221 -10 206 -8T161 6T107 36T62 89T43 171Q43 231 76 284T157 370T254 422T342 441Q347 441 348 445L378 567Q409 686 409 688ZM122 150Q122 116 134 91T167 53T203 35T237 27H244L337 404Q333 404 326 403T297 395T255 379T211 350T170 304Q152 276 137 237Q122 191 122 150ZM500 282Q500 320 484 347T444 385T405 400T381 404H378L332 217L284 29Q284 27 285 27Q293 27 317 33T357 47Q400 66 431 100T475 170T494 234T500 282Z"></path></g><g data-mml-node="msqrt" transform="translate(596,0)"><g transform="translate(853,0)"><g data-mml-node="mn"><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"></path></g></g><g data-mml-node="mo" transform="translate(0,89.5)"><path data-c="221A" d="M95 178Q89 178 81 186T72 200T103 230T169 280T207 309Q209 311 212 311H213Q219 311 227 294T281 177Q300 134 312 108L397 -77Q398 -77 501 136T707 565T814 786Q820 800 834 800Q841 800 846 794T853 782V776L620 293L385 -193Q381 -200 366 -200Q357 -200 354 -197Q352 -195 256 15L160 225L144 214Q129 202 113 190T95 178Z"></path></g><rect width="500" height="60" x="853" y="829.5"></rect></g></g><g data-mml-node="mo" transform="translate(0,189.8)"><path data-c="221A" d="M1001 1150Q1017 1150 1020 1132Q1020 1127 741 244L460 -643Q453 -650 436 -650H424Q423 -647 423 -645T421 -640T419 -631T415 -617T408 -594T399 -560T385 -512T367 -448T343 -364T312 -259L203 119L138 41L111 67L212 188L264 248L472 -474L983 1140Q988 1150 1001 1150Z"></path></g><rect width="1949" height="60" x="1020" y="1279.8"></rect></g><g data-mml-node="mo" transform="translate(3788.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(4788.4,0)"><path data-c="1D719" d="M409 688Q413 694 421 694H429H442Q448 688 448 686Q448 679 418 563Q411 535 404 504T392 458L388 442Q388 441 397 441T429 435T477 418Q521 397 550 357T579 260T548 151T471 65T374 11T279 -10H275L251 -105Q245 -128 238 -160Q230 -192 227 -198T215 -205H209Q189 -205 189 -198Q189 -193 211 -103L234 -11Q234 -10 226 -10Q221 -10 206 -8T161 6T107 36T62 89T43 171Q43 231 76 284T157 370T254 422T342 441Q347 441 348 445L378 567Q409 686 409 688ZM122 150Q122 116 134 91T167 53T203 35T237 27H244L337 404Q333 404 326 403T297 395T255 379T211 350T170 304Q152 276 137 237Q122 191 122 150ZM500 282Q500 320 484 347T444 385T405 400T381 404H378L332 217L284 29Q284 27 285 27Q293 27 317 33T357 47Q400 66 431 100T475 170T494 234T500 282Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="CLOSE" transform="translate(5384.4,0)"><g data-mml-node="mo" transform="translate(0 -0.5)"><path data-c="29" d="M35 1138Q35 1150 51 1150H56H69Q113 1113 153 1069T243 944T330 771T391 541T416 250T391 -40T330 -270T243 -443T152 -568T69 -649H56Q43 -649 39 -647T35 -637Q65 -607 110 -548Q283 -316 316 56Q324 133 324 251Q324 368 316 445Q278 877 48 1123Q36 1137 35 1138Z"></path></g></g><g data-mml-node="msup" transform="translate(5981.4,0)"><g data-mml-node="mi"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="TeXAtom" transform="translate(499,365.5) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mfrac"><g data-mml-node="mn" transform="translate(220,394) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mn" transform="translate(220,-345) scale(0.707)"><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"></path></g><rect width="553.6" height="60" x="120" y="220"></rect></g><g data-mml-node="mi" transform="translate(793.6,0)"><path data-c="1D70B" d="M132 -11Q98 -11 98 22V33L111 61Q186 219 220 334L228 358H196Q158 358 142 355T103 336Q92 329 81 318T62 297T53 285Q51 284 38 284Q19 284 19 294Q19 300 38 329T93 391T164 429Q171 431 389 431Q549 431 553 430Q573 423 573 402Q573 371 541 360Q535 358 472 358H408L405 341Q393 269 393 222Q393 170 402 129T421 65T431 37Q431 20 417 5T381 -10Q370 -10 363 -7T347 17T331 77Q330 86 330 121Q330 170 339 226T357 318T367 358H269L268 354Q268 351 249 275T206 114T175 17Q164 -11 132 -11Z"></path></g></g></g></g><rect width="7694.6" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(8212.4,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(9268.2,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(9990.4,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mfrac" transform="translate(10990.6,0)"><g data-mml-node="msup" transform="translate(2022.8,676)"><g data-mml-node="mi"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="TeXAtom" transform="translate(499,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mo"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(778,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mi" transform="translate(1278,0)"><path data-c="1D70B" d="M132 -11Q98 -11 98 22V33L111 61Q186 219 220 334L228 358H196Q158 358 142 355T103 336Q92 329 81 318T62 297T53 285Q51 284 38 284Q19 284 19 294Q19 300 38 329T93 391T164 429Q171 431 389 431Q549 431 553 430Q573 423 573 402Q573 371 541 360Q535 358 472 358H408L405 341Q393 269 393 222Q393 170 402 129T421 65T431 37Q431 20 417 5T381 -10Q370 -10 363 -7T347 17T331 77Q330 86 330 121Q330 170 339 226T357 318T367 358H269L268 354Q268 351 249 275T206 114T175 17Q164 -11 132 -11Z"></path></g></g></g><g data-mml-node="mrow" transform="translate(220,-896.9)"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(722.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mfrac" transform="translate(1722.4,0)"><g data-mml-node="msup" transform="translate(1213.3,394) scale(0.707)"><g data-mml-node="mi"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="TeXAtom" transform="translate(499,289) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mo"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(778,0)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g><g data-mml-node="mi" transform="translate(1278,0)"><path data-c="1D70B" d="M132 -11Q98 -11 98 22V33L111 61Q186 219 220 334L228 358H196Q158 358 142 355T103 336Q92 329 81 318T62 297T53 285Q51 284 38 284Q19 284 19 294Q19 300 38 329T93 391T164 429Q171 431 389 431Q549 431 553 430Q573 423 573 402Q573 371 541 360Q535 358 472 358H408L405 341Q393 269 393 222Q393 170 402 129T421 65T431 37Q431 20 417 5T381 -10Q370 -10 363 -7T347 17T331 77Q330 86 330 121Q330 170 339 226T357 318T367 358H269L268 354Q268 351 249 275T206 114T175 17Q164 -11 132 -11Z"></path></g></g></g><g data-mml-node="mrow" transform="translate(220,-596.1) scale(0.707)"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(500,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mfrac" transform="translate(1278,0)"><g data-mml-node="msup" transform="translate(846.1,394) scale(0.707)"><g data-mml-node="mi"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(499,289)"><g data-mml-node="mo"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(778,0)"><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z"></path></g><g data-mml-node="mi" transform="translate(1278,0)"><path data-c="1D70B" d="M132 -11Q98 -11 98 22V33L111 61Q186 219 220 334L228 358H196Q158 358 142 355T103 336Q92 329 81 318T62 297T53 285Q51 284 38 284Q19 284 19 294Q19 300 38 329T93 391T164 429Q171 431 389 431Q549 431 553 430Q573 423 573 402Q573 371 541 360Q535 358 472 358H408L405 341Q393 269 393 222Q393 170 402 129T421 65T431 37Q431 20 417 5T381 -10Q370 -10 363 -7T347 17T331 77Q330 86 330 121Q330 170 339 226T357 318T367 358H269L268 354Q268 351 249 275T206 114T175 17Q164 -11 132 -11Z"></path></g></g></g><g data-mml-node="mrow" transform="translate(220,-793.9) scale(0.707)"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(500,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mfrac" transform="translate(1278,0)"><g data-mml-node="msup" transform="translate(246.5,394)"><g data-mml-node="mi"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(499,289)"><g data-mml-node="mo"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(778,0)"><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z"></path></g><g data-mml-node="mi" transform="translate(1278,0)"><path data-c="1D70B" d="M132 -11Q98 -11 98 22V33L111 61Q186 219 220 334L228 358H196Q158 358 142 355T103 336Q92 329 81 318T62 297T53 285Q51 284 38 284Q19 284 19 294Q19 300 38 329T93 391T164 429Q171 431 389 431Q549 431 553 430Q573 423 573 402Q573 371 541 360Q535 358 472 358H408L405 341Q393 269 393 222Q393 170 402 129T421 65T431 37Q431 20 417 5T381 -10Q370 -10 363 -7T347 17T331 77Q330 86 330 121Q330 170 339 226T357 318T367 358H269L268 354Q268 351 249 275T206 114T175 17Q164 -11 132 -11Z"></path></g></g></g><g data-mml-node="mrow" transform="translate(220,-506)"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(500,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mo" transform="translate(1278,0)"><path data-c="22EF" d="M78 250Q78 274 95 292T138 310Q162 310 180 294T199 251Q199 226 182 208T139 190T96 207T78 250ZM525 250Q525 274 542 292T585 310Q609 310 627 294T646 251Q646 226 629 208T586 190T543 207T525 250ZM972 250Q972 274 989 292T1032 310Q1056 310 1074 294T1093 251Q1093 226 1076 208T1033 190T990 207T972 250Z"></path></g></g><rect width="2650" height="60" x="120" y="220"></rect></g></g><rect width="3147.2" height="60" x="120" y="220"></rect></g></g><rect width="3498.8" height="60" x="120" y="220"></rect></g></g><rect width="5661.3" height="60" x="120" y="220"></rect></g></g></g></g></svg></mjx-container></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-06-13T12:15:51.000Z" title="2024/6/13 20:15:51">2024-06-13</time>发表</span><span class="level-item"><time dateTime="2024-06-13T12:16:38.964Z" title="2024/6/13 20:16:38">2024-06-13</time>更新</span><span class="level-item">2 小时读完 (大约19469个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/06/13/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/">算法总结</a></p><div class="content"><p>目录</p>
<p>一、基础算法	3</p>
<p>快速排序算法模板	3</p>
<p>归并排序算法模板	4</p>
<p>逆序对数量	5</p>
<p>整数二分算法模板	6</p>
<p>浮点数二分算法模板	7</p>
<p>高精度加法	7</p>
<p>高精度减法	8</p>
<p>高精度比大小（cmp函数）	8</p>
<p>高精度乘低精度	8</p>
<p>高精度乘高精度	9</p>
<p>高精度除低精度	9</p>
<p>高精度除高精度	10</p>
<p>一维前缀和	11</p>
<p>二维前缀和	11</p>
<p>一维差分	12</p>
<p>二维差分	13</p>
<p>位运算	14</p>
<p>双指针算法	14</p>
<p>离散化	14</p>
<p>区间合并	16</p>
<p>二、数据结构	17</p>
<p>单链表	17</p>
<p>双链表	18</p>
<p>栈	19</p>
<p>队列	20</p>
<p>循环队列	21</p>
<p>单调栈	22</p>
<p>单调队列	23</p>
<p>KMP字符串匹配	24</p>
<p>二叉树的存储与遍历	25</p>
<p>Trie树	28</p>
<p>并查集	29</p>
<p>堆	32</p>
<p>一般hash	33</p>
<p>字符串哈希	34</p>
<p>三、搜索与图论	37</p>
<p>树与图的存储	38</p>
<p>邻接矩阵	38</p>
<p>邻接表	38</p>
<p>树与图的遍历	38</p>
<p>应用：数字全排列	39</p>
<p>应用：树的重心	39</p>
<p>应用：n-皇后问题	41</p>
<p>宽度优先遍历	42</p>
<p>应用：走迷宫	42</p>
<p>应用：八数码	43</p>
<p>拓扑排序	44</p>
<p>Dijkstra算法	46</p>
<p>Bellman-Ford算法	49</p>
<p>SPFA算法（队列优化的Bellman-Ford算法）	52</p>
<p>floyd算法	55</p>
<p>最短路算法总结	57</p>
<p>prim算法	57</p>
<p>Kruskal算法	59</p>
<p>染色法判别二分图	62</p>
<p>匈牙利算法	64</p>
<p>四、数学知识	67</p>
<p>试除法判定质数	68</p>
<p>试除法分解质因数	68</p>
<p>埃氏筛法求质数	68</p>
<p>线性筛法求质数	69</p>
<p>试除法求所有约数	69</p>
<p>约数个数	69</p>
<p>约数之和	70</p>
<p>欧几里得算法(求最大公约数)	71</p>
<p>最小公倍数	72</p>
<p>求欧拉函数	72</p>
<p>线性筛法求欧拉函数	73</p>
<p>快速幂	74</p>
<p>扩展欧几里得算法	74</p>
<p>中国剩余定理	75</p>
<p>扩展中国剩余定理	76</p>
<p>高斯消元法	76</p>
<p>求组合数	79</p>
<p>Lucas定理求组合数	81</p>
<p>分解质因数法求组合数	83</p>
<p>容斥原理应用	87</p>
<p>博弈论	88</p>
<p>五、动态规划	91</p>
<p>闫式dp分析法.jpg	91</p>
<p>背包问题	91</p>
<p>区间DP	100</p>
<p>计数类DP	102</p>
<p>数位统计DP	102</p>
<p>状态压缩DP	104</p>
<p>树形DP	106</p>
<p>记忆化搜索	108</p>
<p>六、贪心	109</p>
<p>区间问题	109</p>
<p>区间选点	109</p>
<p>区间分组	111</p>
<p>排序不等式	112</p>
<p>排队打水	112</p>
<h2 id="一、基础算法"><a href="#一、基础算法" class="headerlink" title="一、基础算法"></a>一、基础算法</h2><h3 id="快速排序算法模板"><a href="#快速排序算法模板" class="headerlink" title="快速排序算法模板"></a>快速排序算法模板</h3><p>void quick_sort(int q[], int l, int r)</p>
<p>{</p>
<pre><code>//递归的终止情况

if (l &gt;= r) return;



 //选取分界线。这里选数组中间那个数

int i = l - 1, j = r + 1, x = q[l + r &gt;&gt; 1];

//划分成左右两个部分

while (i &lt; j)

&#123;

    do i ++ ; while (q[i] &lt; x);

    do j -- ; while (q[j] &gt; x);

    if (i &lt; j) swap(q[i], q[j]);

&#125;

//对左右部分排序

quick_sort(q, l, j), quick_sort(q, j + 1, r);
</code></pre>
<p>}</p>
<p>边界问题：因为边界问题只有这两种组合，不能随意搭配</p>
<p>1.x不能取q[l]和q[l+r&gt;&gt;1];</p>
<p>quick_sort(q,l,i-1),quick_sort(q,i,r);</p>
<p>2.x不能取q[r]和q[(l+r+1)&gt;&gt;1];</p>
<p>quick_sort(q,l,j),quick_sort(q,j+1,r);</p>
<h3 id="归并排序算法模板"><a href="#归并排序算法模板" class="headerlink" title="归并排序算法模板"></a>归并排序算法模板</h3><p>void merge_sort(int q[], int l, int r)</p>
<p>{</p>
<pre><code>//递归的终止情况

if (l &gt;= r) return;

//第一步：分成子问题

int mid = l + r &gt;&gt; 1;

//第二步：递归处理子问题

merge_sort(q, l, mid);

merge_sort(q, mid + 1, r);



//第三步：合并子问题

int k = 0, i = l, j = mid + 1;

while (i &lt;= mid &amp;&amp; j &lt;= r)

    if (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];

    else tmp[k ++ ] = q[j ++ ];



while (i &lt;= mid) tmp[k ++ ] = q[i ++ ];

while (j &lt;= r) tmp[k ++ ] = q[j ++ ];

//第四步：复制回原数组

for (i = l, j = 0; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];
</code></pre>
<p>}</p>
<h3 id="逆序对数量"><a href="#逆序对数量" class="headerlink" title="逆序对数量"></a>逆序对数量</h3><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。</p>
<p>思路：归并排序</p>
<p>举个例子：</p>
<p>在合并 {4 ,5} {1 , 2} 的时候，首先我们判断 1 &lt; 4，我们即可统计出逆序对为2，为什么呢？这利用了数组的部分有序性。因为我们知道 {4 ,5} 这个数组必然是有序的，因为是合并上来的。此时当 1比4小的时候，证明4以后的数也都比1大，此时就构成了从4开始到 {4,5}这个数组结束，这么多个逆序对（2个），此时利用一个临时数组，将1存放起来，接着比较2和4的大小，同样可以得到有2个逆序对，于是将2也放进临时数组中，此时右边数组已经完全没有元素了，则将左边剩余的元素全部放进临时元素中，最后将临时数组中的元素放进原数组对应的位置。</p>
<p>最后接着向上合并~</p>
<p>逆序对数量.png</p>
<p>归并排序求逆序对.gif</p>
<p>using namespace std;</p>
<p>typedef long long  LL;</p>
<p>const int N &#x3D; 100010;</p>
<p>int n;</p>
<p>int q[N], tmp[N];</p>
<p>LL merge_sort(int l, int r) {</p>
<pre><code>if (l &gt;= r)return 0;

int mid = (l + r) &gt;&gt; 1;

LL res = merge_sort(l, mid) + merge_sort(mid + 1, r);

// 归并的过程

int k = 0, i = l, j = mid + 1;

while (i &lt;= mid &amp;&amp; j &lt;= r)

    if (q[i] &lt;= q[j])tmp[k++] = q[i++];

    else &#123;

        tmp[k++] = q[j++];

        res += mid - i + 1;

    &#125;

//扫尾

while (i &lt;= mid)tmp[k++] = q[i++];

while (j &lt;= r)tmp[k++] = q[j++];

//物归原主

for (i = l, j = 0; i &lt;= r; j++, i++)q[i] = tmp[j];

return res;
</code></pre>
<p>}</p>
<p>int main() {</p>
<pre><code>cin &gt;&gt; n;

for (int i = 0; i &lt; n; i++)cin &gt;&gt; q[i];

cout &lt;&lt; merge_sort(0, n - 1) &lt;&lt; endl;

return 0;
</code></pre>
<p>}</p>
<h3 id="整数二分算法模板"><a href="#整数二分算法模板" class="headerlink" title="整数二分算法模板"></a>整数二分算法模板</h3><p>对lower_bound来说，它寻找的就是第一个满足条件“值大于等于x”的元素的位置；对upper_bound函数来说，它寻找的是第一个满足“值大于 x”的元素的位置。</p>
<p>bool check(int x) {&#x2F;* … *&#x2F;} &#x2F;&#x2F; 检查x是否满足某种性质</p>
<p>&#x2F;&#x2F; 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</p>
<p>int bsearch_1(int l, int r)</p>
<p>{</p>
<pre><code>while (l &lt; r)

&#123;

    int mid = l + r &gt;&gt; 1;

    if (check(mid)) r = mid;    // check()判断mid是否满足性质

    else l = mid + 1;//左加右减

&#125;

return l;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</p>
<p>int bsearch_2(int l, int r)</p>
<p>{</p>
<pre><code>while (l &lt; r)

&#123;

    int mid = l + r + 1 &gt;&gt; 1;//如果下方else后面是l则这里加1

    if (check(mid)) l = mid;

    else r = mid - 1;//左加右减

&#125;

return l;
</code></pre>
<p>}</p>
<h3 id="浮点数二分算法模板"><a href="#浮点数二分算法模板" class="headerlink" title="浮点数二分算法模板"></a>浮点数二分算法模板</h3><p>bool check(double x) {&#x2F;* … *&#x2F;} &#x2F;&#x2F; 检查x是否满足某种性质</p>
<p>double bsearch_3(double l, double r)</p>
<p>{</p>
<pre><code>const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求

while (r - l &gt; eps)

&#123;

    double mid = (l + r) / 2;

    if (check(mid)) r = mid;

    else l = mid;

&#125;

return l;
</code></pre>
<p>}</p>
<h3 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h3><p>&#x2F;&#x2F; C &#x3D; A + B, A &gt;&#x3D; 0, B &gt;&#x3D; 0</p>
<p>vector<int> add(vector<int> &amp;a,vector<int> &amp;b){</p>
<pre><code>//c为答案

vector&lt;int&gt; c;

//t为进位

int t=0;

for(int i=0;i&lt;a.size()||i&lt;b.size();i++)&#123;

    //不超过a的范围添加a[i]

    if(i&lt;a.size())t+=a[i];

    //不超过b的范围添加b[i]

    if(i&lt;b.size())t+=b[i];

    //取当前位的答案

    c.push_back(t%10);

    //是否进位

    t/=10;

&#125;

//如果t!=0的话向后添加1

if(t)c.push_back(1);

return c;
</code></pre>
<p>}</p>
<h3 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h3><p>&#x2F;&#x2F; C &#x3D; A - B, 满足A &gt;&#x3D; B, A &gt;&#x3D; 0, B &gt;&#x3D; 0</p>
<p>vector<int> sub(vector<int> &amp;A, vector<int> &amp;B)</p>
<p>{</p>
<pre><code>//答案

vector&lt;int&gt; C;

//遍历最大的数

for (int i = 0, t = 0; i &lt; A.size(); i ++ )

&#123;

    //t为进位

    t = A[i] - t;

    //不超过B的范围t=A[i]-B[i]-t;

    if (i &lt; B.size()) t -= B[i];

    //合二为一，取当前位的答案

    C.push_back((t + 10) % 10);

    //t&lt;0则t=1

    if (t &lt; 0) t = 1;

    //t&gt;=0则t=0

    else t = 0;

&#125;

//去除前导零

while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();

return C;
</code></pre>
<p>}</p>
<h3 id="高精度比大小（cmp函数）"><a href="#高精度比大小（cmp函数）" class="headerlink" title="高精度比大小（cmp函数）"></a>高精度比大小（cmp函数）</h3><p>&#x2F;&#x2F;高精度比大小</p>
<p>bool cmp(vector<int> &amp;A, vector<int> &amp;B) {</p>
<pre><code>if (A.size() != B.size())

    return A.size() &gt; B.size();

for (int i = A.size() - 1; i &gt;= 0; i -- )

    if (A[i] != B[i])

        return A[i] &gt; B[i];

return true;
</code></pre>
<p>}</p>
<h3 id="高精度乘低精度"><a href="#高精度乘低精度" class="headerlink" title="高精度乘低精度"></a>高精度乘低精度</h3><p>&#x2F;&#x2F; C &#x3D; A * b, A &gt;&#x3D; 0, b &gt;&#x3D; 0</p>
<p>vector<int> mul(vector<int> &amp;A, int b)</p>
<p>{</p>
<pre><code>//类似于高精度加法

vector&lt;int&gt; C;

//t为进位

int t = 0;

for (int i = 0; i &lt; A.size() || t; i ++ )

&#123;

    //不超过A的范围t=t+A[i]*b

    if (i &lt; A.size()) t += A[i] * b;

    //取当前位的答案

    C.push_back(t % 10);

    //进位

    t /= 10;

&#125;

//去除前导零

while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();



return C;
</code></pre>
<p>}</p>
<h3 id="高精度乘高精度"><a href="#高精度乘高精度" class="headerlink" title="高精度乘高精度"></a>高精度乘高精度</h3><p><strong>高精度加减乘除</strong>：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1LA411v7mt/">https://www.bilibili.com/video/BV1LA411v7mt/</a></p>
<p>vector<int> mul(vector<int> &amp;A, vector<int> &amp;B) {</p>
<pre><code>vector&lt;int&gt; C(A.size() + B.size()); // 初始化为 0，C的size可以大一点



for (int i = 0; i &lt; A.size(); i++)

    for (int j = 0; j &lt; B.size(); j++)

        C[i + j] += A[i] * B[j];

for (int i = 0, t = 0; i &lt; C.size(); i++) &#123; // i = C.size() - 1时 t 一定小于 10

    t += C[i];

    C[i] = t % 10;

    t /= 10;

&#125;



while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); // 必须要去前导 0，因为最高位很可能是 0

return C;
</code></pre>
<p>}</p>
<h3 id="高精度除低精度"><a href="#高精度除低精度" class="headerlink" title="高精度除低精度"></a>高精度除低精度</h3><p>&#x2F;&#x2F; A &#x2F; b &#x3D; C … r, A &gt;&#x3D; 0, b &gt; 0</p>
<p>vector<int> div(vector<int> &amp;A, int b, int &amp;r)&#x2F;&#x2F;高精度A，低精度b，余数r</p>
<p>{</p>
<pre><code>vector&lt;int&gt; C;//答案

r = 0;

for (int i = A.size() - 1; i &gt;= 0; i -- )

&#123;

    r = r * 10 + A[i];//补全r&gt;=b

    C.push_back(r / b);//取当前位的答案

    r %= b;//r%b为下一次计算

&#125;

reverse(C.begin(), C.end());//倒序为答案

while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();//去除前导零

return C;
</code></pre>
<p>}</p>
<h3 id="高精度除高精度"><a href="#高精度除高精度" class="headerlink" title="高精度除高精度"></a>高精度除高精度</h3><p><strong>高精度加减乘除</strong>：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1LA411v7mt/">https://www.bilibili.com/video/BV1LA411v7mt/</a></p>
<p>vector<int> div(vector<int> &amp;A, vector<int> &amp;B, vector<int> &amp;r) {</p>
<pre><code>vector&lt;int&gt; C;

if (!cmp(A, B)) &#123;

    C.push_back(0);

    r.assign(A.begin(), A.end());

    return C;

&#125;

int j = B.size();

r.assign(A.end() - j, A.end());

while (j &lt;= A.size()) &#123;

    int k = 0;

    while (cmp(r, B)) &#123;

        r = sub(r, B);

        k ++;

    &#125;

    C.push_back(k);

    if (j &lt; A.size())

        r.insert(r.begin(), A[A.size() - j - 1]);

    if (r.size() &gt; 1 &amp;&amp; r.back() == 0)

        r.pop_back();

    j++;

&#125;

reverse(C.begin(), C.end());

while (C.size() &gt; 1 &amp;&amp; C.back() == 0)

    C.pop_back();

return C;
</code></pre>
<p>}</p>
<h3 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h3><p>前缀和可以用于快速计算一个序列的区间和，也有很多问题里不是直接用前缀和，但是借用了前缀和的思想。</p>
<p>预处理:s[i]&#x3D;a[i]+a[i-1]</p>
<p>求区间[l,r]:sum&#x3D;s[r]-s[l-1]</p>
<p>“前缀和数组”和”原数组”可以合二为一</p>
<p>应用</p>
<p>const int N&#x3D;100010;</p>
<p>int a[N];</p>
<p>int main(){</p>
<pre><code>int n,m;

scanf(&quot;%d&quot;,&amp;n);

for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]);

for(int i=1;i&lt;=n;i++)a[i]=a[i-1]+a[i];

scanf(&quot;%d&quot;,&amp;m);

while(m--)&#123;

    int l,r;

    scanf(&quot;%d%d&quot;,&amp;l,&amp;r);

    printf(&quot;%d\n&quot;,a[r]-a[l-1]);

&#125;

return 0;
</code></pre>
<p>}</p>
<h3 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h3><p>计算矩阵的前缀和：s[x][y] &#x3D; s[x - 1][y] + s[x][y -1] - s[x-1][y-1] + a[x][y]</p>
<p>以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：</p>
<p>计算子矩阵的和：s &#x3D; s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 -1]</p>
<p>应用</p>
<p>int s[1010][1010];</p>
<p>int n,m,q;</p>
<p>int main(){</p>
<pre><code>scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;q);

for(int i=1;i&lt;=n;i++)

    for(int j=1;j&lt;=m;j++)

        scanf(&quot;%d&quot;,&amp;s[i][j]);

for(int i=1;i&lt;=n;i++)

    for(int j=1;j&lt;=m;j++)

        s[i][j]+=s[i-1][j]+s[i][j-1]-s[i-1][j-1];

while(q--)&#123;

    int x1,y1,x2,y2;

    scanf(&quot;%d%d%d%d&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2);

    printf(&quot;%d\n&quot;,s[x2][y2]-s[x2][y1-1]-s[x1-1][y2]+s[x1-1][y1-1]);

&#125;

return 0;
</code></pre>
<p>}</p>
<h3 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h3><p>差分是前缀和的逆运算，对于一个数组a，其差分数组b的每一项都是a [ i ]和前一项a [ i − 1 ]的差。</p>
<p>注意：差分数组和原数组必须分开存放！！！！</p>
<p>给区间[l, r]中的每个数加上c：B[l] +&#x3D; c, B[r + 1] -&#x3D; c</p>
<p>应用</p>
<p>using namespace std;</p>
<p>int a[100010],s[100010];</p>
<p>int main(){</p>
<pre><code>int n,m;

cin&gt;&gt;n&gt;&gt;m;

for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i];   

for(int i=1;i&lt;=n;i++)s[i]=a[i]-a[i-1];// 读入并计算差分数组

while(m--)&#123;

    int l,r,c;

    cin&gt;&gt;l&gt;&gt;r&gt;&gt;c;

    s[l]+=c;

    s[r+1]-=c;// 在原数组中将区间[l, r]加上c

&#125;

for(int i=1;i&lt;=n;i++)&#123;

    s[i]+=s[i-1];

    cout&lt;&lt;s[i]&lt;&lt;&#39; &#39;;

&#125;// 给差分数组计算前缀和，就求出了原数组

return 0;
</code></pre>
<p>}</p>
<h3 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h3><p>给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：</p>
<p>S[x1, y1] +&#x3D; c, S[x2 + 1, y1] -&#x3D; c, S[x1, y2 + 1] -&#x3D; c, S[x2 + 1, y2 + 1] +&#x3D; c</p>
<p>应用</p>
<p>const int N &#x3D; 1e3 + 10;</p>
<p>int a[N][N], b[N][N];</p>
<p>void insert(int x1, int y1, int x2, int y2, int c)</p>
<p>{</p>
<pre><code>b[x1][y1] += c;

b[x2 + 1][y1] -= c;

b[x1][y2 + 1] -= c;

b[x2 + 1][y2 + 1] += c;
</code></pre>
<p>}</p>
<p>int main()</p>
<p>{</p>
<pre><code>int n, m, q;

cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;

for (int i = 1; i &lt;= n; i++)

    for (int j = 1; j &lt;= m; j++)

        cin &gt;&gt; a[i][j];

for (int i = 1; i &lt;= n; i++)

&#123;

    for (int j = 1; j &lt;= m; j++)

    &#123;

        insert(i, j, i, j, a[i][j]);      //构建差分数组

    &#125;

&#125;

while (q--)

&#123;

    int x1, y1, x2, y2, c;

    cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c;

    insert(x1, y1, x2, y2, c);//加c

&#125;

for (int i = 1; i &lt;= n; i++)

&#123;

    for (int j = 1; j &lt;= m; j++)

    &#123;

        b[i][j] += b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1];  //二维前缀和

    &#125;

&#125;

for (int i = 1; i &lt;= n; i++)

&#123;

    for (int j = 1; j &lt;= m; j++)

    &#123;

        printf(&quot;%d &quot;, b[i][j]);

    &#125;

    printf(&quot;\n&quot;);

&#125;

return 0;
</code></pre>
<p>}</p>
<p>关于前缀和与差分的相关博客链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39757593/article/details/129219491">https://blog.csdn.net/qq_39757593/article/details/129219491</a></p>
<h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>求n的第k位数字: n &gt;&gt; k &amp; 1</p>
<p>返回n的最后一位1：lowbit(n) &#x3D; n &amp; -n</p>
<h3 id="双指针算法"><a href="#双指针算法" class="headerlink" title="双指针算法"></a>双指针算法</h3><p>for (int i &#x3D; 0, j &#x3D; 0; i &lt; n; i ++ )</p>
<p>{</p>
<pre><code>while (j &lt; i &amp;&amp; check(i, j)) j ++ ;

// 具体问题的逻辑
</code></pre>
<p>}</p>
<p>常见问题分类：</p>
<pre><code>(1) 对于一个序列，用两个指针维护一段区间

(2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作
</code></pre>
<h3 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h3><p>离散化的本质是建立了一段数列到自然数之间的映射关系（value -&gt; index)，通过建立新索引，来缩小目标区间，使得可以进行一系列连续数组可以进行的操作比如二分，前缀和等…</p>
<p>离散化首先需要排序去重：</p>
<p>1.排序：sort(alls.begin(),alls.end())</p>
<p>2.去重：alls.earse(unique(alls.begin(),alls.end()),alls.end());</p>
<p>vector<int> alls; &#x2F;&#x2F; 存储所有待离散化的值</p>
<p>sort(alls.begin(), alls.end()); &#x2F;&#x2F; 将所有值排序</p>
<p>alls.erase(unique(alls.begin(), alls.end()), alls.end());   &#x2F;&#x2F; 去掉重复元素</p>
<p>&#x2F;&#x2F; 二分求出x对应的离散化的值</p>
<p>int find(int x) &#x2F;&#x2F; 找到第一个大于等于x的位置</p>
<p>{</p>
<pre><code>int l = 0, r = alls.size() - 1;

while (l &lt; r)

&#123;

    int mid = l + r &gt;&gt; 1;

    if (alls[mid] &gt;= x) r = mid;

    else l = mid + 1;

&#125;

return r + 1; // 映射到1, 2, ...n
</code></pre>
<p>}</p>
<p>应用</p>
<p>typedef pair&lt;int, int&gt; PII;</p>
<p>const int N &#x3D; 300010;</p>
<p>int n, m;</p>
<p>int a[N], s[N];</p>
<p>vector<int> alls;&#x2F;&#x2F;存入下标容器</p>
<p>vector<PII> add, query;&#x2F;&#x2F;add增加容器，存入对应下标和增加的值的大小</p>
<p>&#x2F;&#x2F;query存入需要计算下标区间和的容器</p>
<p>int find(int x)</p>
<p>{</p>
<pre><code>int l = 0, r = alls.size() - 1;

while (l &lt; r)//查找大于等于x的最小的值的下标

&#123;

    int mid = l + r &gt;&gt; 1;

    if (alls[mid] &gt;= x) r = mid;

    else l = mid + 1;

&#125;

return r + 1;//因为使用前缀和，其下标要+1可以不考虑边界问题
</code></pre>
<p>}</p>
<p>int main()</p>
<p>{</p>
<pre><code>cin &gt;&gt; n &gt;&gt; m;

for (int i = 0; i &lt; n; i ++ )

&#123;

    int x, c;

    cin &gt;&gt; x &gt;&gt; c;

    add.push_back(&#123;x, c&#125;);//存入下标即对应的数值c



    alls.push_back(x);//存入数组下标x=add.first

&#125;



for (int i = 0; i &lt; m; i ++ )

&#123;

    int l, r;

    cin &gt;&gt; l &gt;&gt; r;

    query.push_back(&#123;l, r&#125;);//存入要求的区间



    alls.push_back(l);//存入区间左右下标

    alls.push_back(r);

&#125;



// 区间去重

sort(alls.begin(), alls.end());

alls.erase(unique(alls.begin(), alls.end()), alls.end());



// 处理插入

for (auto item : add)

&#123;

    int x = find(item.first);//将add容器的add.secend值存入数组a[]当中，

    a[x] += item.second;//在去重之后的下标集合alls内寻找对应的下标并添加数值

&#125;



// 预处理前缀和

for (int i = 1; i &lt;= alls.size(); i ++ ) s[i] = s[i - 1] + a[i];



// 处理询问

for (auto item : query)

&#123;

    int l = find(item.first), r = find(item.second);//在下标容器中查找对应的左右两端[l~r]下标，然后通过下标得到前缀和相减再得到区间a[l~r]的和

    cout &lt;&lt; s[r] - s[l - 1] &lt;&lt; endl;

&#125;



return 0;
</code></pre>
<p>}</p>
<h3 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h3><p>&#x2F;&#x2F; 将所有存在交集的区间合并</p>
<p>void merge(vector<PII> &amp;segs)</p>
<p>{</p>
<pre><code>vector&lt;PII&gt; res;



sort(segs.begin(), segs.end());



int st = -2e9, ed = -2e9;

for (auto seg : segs)

    if (ed &lt; seg.first)

    &#123;

        if (st != -2e9) res.push_back(&#123;st, ed&#125;);

        st = seg.first, ed = seg.second;

    &#125;

    else ed = max(ed, seg.second);



if (st != -2e9) res.push_back(&#123;st, ed&#125;);



segs = res;
</code></pre>
<p>}</p>
<h2 id="二、数据结构"><a href="#二、数据结构" class="headerlink" title="二、数据结构"></a>二、数据结构</h2><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>const int N&#x3D;100010;</p>
<p>int head,e[N],ne[N],idx;</p>
<p>&#x2F;&#x2F;初始化</p>
<p>void init(){</p>
<pre><code>head=-1;

idx=0;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F;在链表头部添加节点</p>
<p>void add_to_head(int x){</p>
<pre><code>e[idx]=x,ne[idx]=head,head=idx++;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F;在位置k添加节点x</p>
<p>void add(int k,int x){</p>
<pre><code>e[idx]=x,ne[idx]=ne[k],ne[k]=idx++;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F;删除位置k的节点</p>
<p>void remove(int k){</p>
<pre><code>ne[k]=ne[ne[k]];
</code></pre>
<p>}</p>
<p>应用</p>
<p>int main(){</p>
<pre><code>int m;

init();

cin&gt;&gt;m;

while(m--)&#123;

    int k,x;

    char op;

    cin&gt;&gt;op;

    if(op==&#39;H&#39;)&#123;

        cin&gt;&gt;x;

        add_to_head(x);

    &#125;else if(op==&#39;D&#39;)&#123;

        cin&gt;&gt;k;

        if(!k)head=ne[head];

        remove(k-1);

    &#125;else &#123;

        cin&gt;&gt;k&gt;&gt;x;

        add(k-1,x);

    &#125;

&#125;

for(int i=head;i!=-1;i=ne[i])cout&lt;&lt;e[i]&lt;&lt;&#39; &#39;;

cout&lt;&lt;endl;

return 0;
</code></pre>
<p>}</p>
<h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><p>const int N&#x3D;100010;</p>
<p>int e[N],l[N],r[N],idx;</p>
<p>&#x2F;&#x2F;初始化</p>
<p>void init(){</p>
<pre><code>l[1]=0;

r[0]=1;

idx=2;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F;在节点a的右边插入一个数x</p>
<p>void insert(int a,int x){</p>
<pre><code>e[idx]=x;

l[idx]=a,r[idx]=r[a];

l[r[a]]=idx,r[a]=idx++;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F;删除节点a</p>
<p>void remove(int a){</p>
<pre><code>l[r[a]]=l[a];

r[l[a]]=r[a];
</code></pre>
<p>}</p>
<p>应用</p>
<p>int main(){</p>
<pre><code>int m;

cin&gt;&gt;m;

init();

while(m--)&#123;

    string op;

    cin&gt;&gt;op;

    int k,x;

    if(op==&quot;L&quot;)&#123;//在最左端插入数x

        cin&gt;&gt;x;

        insert(0,x);

    &#125;else if(op==&quot;R&quot;)&#123;//在最右端插入数x

        cin&gt;&gt;x;

        insert(l[1],x);

    &#125;else if(op==&quot;D&quot;)&#123;//删除第k个插入的数

        cin&gt;&gt;k;

        remove(k+1);

    &#125;else if(op==&quot;IL&quot;)&#123;//在第k个位置的左侧插入一个数

        cin&gt;&gt;k&gt;&gt;x;

        insert(l[k+1],x);

    &#125;else if(op==&quot;LR&quot;)&#123;//在第k个位置的右侧插入一个数

        cin&gt;&gt;k&gt;&gt;x;

        insert(k+1,x);

    &#125;

&#125;

for(int i=r[0];i!=1;i=r[i])printf(&quot;%d &quot;,e[i]);

cout&lt;&lt;endl;

return 0;
</code></pre>
<p>}</p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>&#x2F;&#x2F; tt表示栈顶</p>
<p>int stk[N], tt &#x3D; 0;</p>
<p>&#x2F;&#x2F; 向栈顶插入一个数</p>
<p>stk[ ++ tt] &#x3D; x;</p>
<p>&#x2F;&#x2F; 从栈顶弹出一个数</p>
<p>tt – ;</p>
<p>&#x2F;&#x2F; 栈顶的值</p>
<p>stk[tt];</p>
<p>&#x2F;&#x2F; 判断栈是否为空，如果 tt &gt; 0，则表示不为空</p>
<p>if (tt &gt; 0)</p>
<p>{</p>
<p>}</p>
<p>应用</p>
<p>const int N&#x3D;100010;</p>
<p>int stk[N],tt;</p>
<p>int main(){</p>
<pre><code>int m;

cin&gt;&gt;m;

while(m--)&#123;

    string op;

    int x;

    cin&gt;&gt;op;

    if(op==&quot;push&quot;)&#123;

        cin&gt;&gt;x;

        stk[tt++]=x;

    &#125;else if(op==&quot;pop&quot;)&#123;

        tt--;

    &#125;else if(op==&quot;query&quot;)&#123;

        cout&lt;&lt;stk[tt-1]&lt;&lt;endl;

    &#125;else&#123;

        if(!tt)cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;

        else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;

    &#125;

&#125;

return 0;
</code></pre>
<p>}</p>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>普通队列</p>
<p>&#x2F;&#x2F; hh 表示队头，tt表示队尾</p>
<p>int q[N], hh &#x3D; 0, tt &#x3D; -1;</p>
<p>&#x2F;&#x2F; 向队尾插入一个数</p>
<p>q[ ++ tt] &#x3D; x;</p>
<p>&#x2F;&#x2F; 从队头弹出一个数</p>
<p>hh ++ ;</p>
<p>&#x2F;&#x2F; 队头的值</p>
<p>q[hh];</p>
<p>&#x2F;&#x2F; 判断队列是否为空，如果 hh &lt;&#x3D; tt，则表示不为空</p>
<p>if (hh &lt;&#x3D; tt)</p>
<p>{</p>
<p>}</p>
<p>应用</p>
<p>int const N&#x3D;100010;</p>
<p>int que[N],hh,tt&#x3D;-1;</p>
<p>int main(){</p>
<pre><code>int m;

cin&gt;&gt;m;

while(m--)&#123;

    string op;

    int x;

    cin&gt;&gt;op;

    if(op==&quot;push&quot;)&#123;

        cin&gt;&gt;x;

        que[++tt]=x;

    &#125;else if(op==&quot;query&quot;)&#123;

        cout&lt;&lt;que[hh]&lt;&lt;endl;

    &#125;else if(op==&quot;pop&quot;)&#123;

        hh++;

    &#125;else&#123;

        if(hh&gt;tt)cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;

        else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;

    &#125;

&#125;

return 0;
</code></pre>
<p>}</p>
<h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>&#x2F;&#x2F; hh 表示队头，tt表示队尾的后一个位置</p>
<p>int q[N], hh &#x3D; 0, tt &#x3D; 0;</p>
<p>&#x2F;&#x2F; 向队尾插入一个数</p>
<p>q[tt ++ ] &#x3D; x;</p>
<p>if (tt &#x3D;&#x3D; N) tt &#x3D; 0;</p>
<p>&#x2F;&#x2F; 从队头弹出一个数</p>
<p>hh ++ ;</p>
<p>if (hh &#x3D;&#x3D; N) hh &#x3D; 0;</p>
<p>&#x2F;&#x2F; 队头的值</p>
<p>q[hh];</p>
<p>&#x2F;&#x2F; 判断队列是否为空，如果hh !&#x3D; tt，则表示不为空</p>
<p>if (hh !&#x3D; tt)</p>
<p>{</p>
<p>}</p>
<h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p>常见模型：找出每个数左边离它最近的比它大&#x2F;小的数</p>
<p>int tt &#x3D; 0;</p>
<p>for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )</p>
<p>{</p>
<pre><code>while (tt &amp;&amp; check(stk[tt], i)) tt -- ;

stk[ ++ tt] = i;
</code></pre>
<p>}</p>
<p>应用</p>
<p>找出每个数左边离它最近的比它大&#x2F;小的数</p>
<p>stack<int> stk;</p>
<p>int main(){</p>
<pre><code>int n;

cin &gt;&gt; n;

stk.push(-1);

for (int i = 0; i &lt; n; i ++)&#123;

    int x; 

    cin &gt;&gt; x;

    while (stk.size() &amp;&amp; stk.top() &gt;= x) stk.pop();

    cout &lt;&lt; stk.top() &lt;&lt; &quot; &quot;;

    stk.push(x);

&#125;

return 0;
</code></pre>
<p>}</p>
<h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><p>常见模型：找出滑动窗口中的最大值&#x2F;最小值</p>
<p>int hh &#x3D; 0, tt &#x3D; -1;</p>
<p>for (int i &#x3D; 0; i &lt; n; i ++ )</p>
<p>{</p>
<pre><code>while (hh &lt;= tt &amp;&amp; check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口

while (hh &lt;= tt &amp;&amp; check(q[tt], i)) tt -- ;

q[ ++ tt] = i;
</code></pre>
<p>}</p>
<p>const int N &#x3D; 1000010;</p>
<p>int a[N];</p>
<p>int main()</p>
<p>{</p>
<pre><code>int n, k;

cin &gt;&gt; n &gt;&gt; k;

for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; a[i];//读入数据

deque&lt;int&gt; q;

for(int i = 1; i &lt;= n; i++)

&#123;

    while(q.size() &amp;&amp; q.back() &gt; a[i]) //新进入窗口的值小于队尾元素，则队尾出队列

        q.pop_back();

    q.push_back(a[i]);//将新进入的元素入队

    if(i - k &gt;= 1 &amp;&amp; q.front() == a[i - k])//若队头是否滑出了窗口，队头出队 

        q.pop_front();

    if(i &gt;= k)//当窗口形成，输出队头对应的值

        cout &lt;&lt; q.front() &lt;&lt;&quot; &quot;;

&#125;

q.clear();

cout &lt;&lt; endl;



//最大值亦然

for(int i = 1; i &lt;= n; i++)

&#123;

    while(q.size() &amp;&amp; q.back() &lt; a[i]) q.pop_back();

    q.push_back(a[i]);

    if(i - k &gt;= 1 &amp;&amp; a[i - k] == q.front()) q.pop_front(); 

    if(i &gt;= k) cout &lt;&lt; q.front() &lt;&lt; &quot; &quot;;



&#125;
</code></pre>
<p>}</p>
<h3 id="KMP字符串匹配"><a href="#KMP字符串匹配" class="headerlink" title="KMP字符串匹配"></a>KMP字符串匹配</h3><p>视频讲解：[最浅显易懂的 KMP 算法讲解_哔哩哔哩_bilibili]：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1AY4y157yL">https://www.bilibili.com/video/BV1AY4y157yL</a></p>
<p>下标从1开始的kmp算法</p>
<p>const int N &#x3D; 100010, M &#x3D; 1000010;</p>
<p>int n, m;</p>
<p>int ne[N];</p>
<p>char s[M], p[N];</p>
<p>int main()</p>
<p>{</p>
<pre><code>cin &gt;&gt; n &gt;&gt; p + 1 &gt;&gt; m &gt;&gt; s + 1;

for (int i = 2, j = 0; i &lt;= n; i ++ )

&#123;

    while (j &amp;&amp; p[i] != p[j + 1]) j = ne[j];

    if (p[i] == p[j + 1]) j ++ ;

    ne[i] = j;

&#125;//处理ne数组

for (int i = 1, j = 0; i &lt;= m; i ++ )

&#123;

    while (j &amp;&amp; s[i] != p[j + 1]) j = ne[j];

    if (s[i] == p[j + 1]) j ++ ;

    if (j == n)

    &#123;

        printf(&quot;%d &quot;, i - n);

        j = ne[j];

    &#125;

&#125;//匹配算法

return 0;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; s[]是长文本，p[]是模式串，n是s的长度，m是p的长度</p>
<p>求模式串的Next数组：</p>
<p>for (int i &#x3D; 2, j &#x3D; 0; i &lt;&#x3D; m; i ++ )</p>
<p>{</p>
<pre><code>while (j &amp;&amp; p[i] != p[j + 1]) j = ne[j];

if (p[i] == p[j + 1]) j ++ ;

ne[i] = j;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; 匹配</p>
<p>for (int i &#x3D; 1, j &#x3D; 0; i &lt;&#x3D; n; i ++ )</p>
<p>{</p>
<pre><code>while (j &amp;&amp; s[i] != p[j + 1]) j = ne[j];

if (s[i] == p[j + 1]) j ++ ;

if (j == m)

&#123;

    j = ne[j];

    // 匹配成功后的逻辑

&#125;
</code></pre>
<p>}</p>
<p>下标从0开始的kmp算法</p>
<p>const int N &#x3D; 1000010;</p>
<p>int n, m;</p>
<p>char s[N], p[N];</p>
<p>int ne[N];</p>
<p>int main()</p>
<p>{</p>
<pre><code>cin &gt;&gt; m &gt;&gt; p &gt;&gt; n &gt;&gt; s;

ne[0] = -1;

for (int i = 1, j = -1; i &lt; m; i ++ )

&#123;

    while (j &gt;= 0 &amp;&amp; p[j + 1] != p[i]) j = ne[j];

    if (p[j + 1] == p[i]) j ++ ;

    ne[i] = j;

&#125;

for (int i = 0, j = -1; i &lt; n; i ++ )

&#123;

    while (j != -1 &amp;&amp; s[i] != p[j + 1]) j = ne[j];

    if (s[i] == p[j + 1]) j ++ ;

    if (j == m - 1)

    &#123;

        cout &lt;&lt; i - j &lt;&lt; &#39; &#39;;

        j = ne[j];

    &#125;

&#125;

return 0;
</code></pre>
<p>}</p>
<h3 id="二叉树的存储与遍历"><a href="#二叉树的存储与遍历" class="headerlink" title="二叉树的存储与遍历"></a>二叉树的存储与遍历</h3><p>const int N &#x3D; 1e6 + 10;</p>
<p>&#x2F;&#x2F; 二叉树的存储,l数组为左节点,r数组为右结点</p>
<p>int l[N], r[N];</p>
<p>&#x2F;&#x2F; 存储节点的数据</p>
<p>char w[N];</p>
<p>&#x2F;&#x2F; 节点的下标指针</p>
<p>int idx &#x3D; 0;</p>
<p>&#x2F;&#x2F; 先序创建</p>
<p>int pre_create(int n) {</p>
<pre><code>cin &gt;&gt; w[n];

if (w[n] == &#39;#&#39;) return -1;

l[n] = pre_create(++idx);

r[n] = pre_create(++idx);

return n;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; 中序创建</p>
<p>int in_create(int n) {</p>
<pre><code>if (w[n] == &#39;#&#39;) return -1;

l[n] = in_create(++idx);

cin &gt;&gt; w[n];

r[n] = in_create(++idx);

return n;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; 后序创建</p>
<p>int back_create(int n) {</p>
<pre><code>if (w[n] == &#39;#&#39;) return -1;

l[n] = back_create(++idx);

r[n] = back_create(++idx);

cin &gt;&gt; w[n];

return n;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; 先序遍历</p>
<p>void pre_print(int n){</p>
<pre><code>if (w[n] != &#39;#&#39;) cout &lt;&lt; w[n] &lt;&lt; &#39; &#39;;

if (l[n] &gt; 0) pre_print(l[n]);

if (r[n] &gt; 0) pre_print(r[n]);
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; 中序遍历</p>
<p>void in_print(int n){</p>
<pre><code>if (l[n] &gt; 0) in_print(l[n]);

if (w[n] != &#39;#&#39;) cout &lt;&lt; w[n] &lt;&lt; &#39; &#39;;

if (r[n] &gt; 0) in_print(r[n]);
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; 后序遍历</p>
<p>void back_print(int n){</p>
<pre><code>if (l[n] &gt; 0) back_print(l[n]);

if (r[n] &gt; 0) back_print(r[n]);

if (w[n] != &#39;#&#39;) cout &lt;&lt; w[n] &lt;&lt; &#39; &#39;;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; 层序遍历</p>
<p>void bfs(int root){</p>
<pre><code>queue&lt;int&gt; que;

que.push(root);

while (!que.empty()) &#123;

    int t = que.front();

    cout &lt;&lt; w[t] &lt;&lt; &#39; &#39;;

    que.pop();

    if (l[t] &gt; 0 &amp;&amp; w[l[t]] != &#39;#&#39;)

        que.push(l[t]);

    if (r[t] &gt; 0 &amp;&amp; w[r[t]] != &#39;#&#39;)

        que.push(r[t]);

&#125;
</code></pre>
<p>}</p>
<p>应用</p>
<p>int main(){</p>
<pre><code>// 先序创建

pre_create(++idx);

// 中序创建

// in_create(++idx);

// 后序创建

// back_create(++idx);

// 先序遍历

pre_print(1);

// 中序遍历

in_print(1);

// 后序遍历

back_print(1);

// 层序遍历

bfs(1);

// 测试数据abc##de#g##f###

// 输出如下：

// a b c d e g f 

// c b e g d f a 

// c g e f d b a 

// a b c d e f g 

return 0;
</code></pre>
<p>}</p>
<h3 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h3><p>Trie 树是一种多叉树的结构，每个节点保存一个字符，一条路径表示一个字符串。</p>
<p>相关链接：<a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/27771/">https://www.acwing.com/solution/content/27771/</a></p>
<p>int son[N][26], cnt[N], idx;</p>
<p>&#x2F;&#x2F; 0号点既是根节点，又是空节点</p>
<p>&#x2F;&#x2F; son[][]存储树中每个节点的子节点</p>
<p>&#x2F;&#x2F; cnt[]存储以每个节点结尾的单词数量</p>
<p>&#x2F;&#x2F; 插入一个字符串</p>
<p>void insert(char *str)</p>
<p>{</p>
<pre><code>int p = 0;

for (int i = 0; str[i]; i ++ )

&#123;

    int u = str[i] - &#39;a&#39;;

    if (!son[p][u]) son[p][u] = ++ idx;

    p = son[p][u];

&#125;

cnt[p] ++ ;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; 查询字符串出现的次数</p>
<p>int query(char *str)</p>
<p>{</p>
<pre><code>int p = 0;

for (int i = 0; str[i]; i ++ )

&#123;

    int u = str[i] - &#39;a&#39;;

    if (!son[p][u]) return 0;

    p = son[p][u];

&#125;

return cnt[p];
</code></pre>
<p>}</p>
<p>const int N &#x3D; 100010;</p>
<p>int son[N][26], cnt[N], idx;</p>
<p>char str[N];</p>
<p>void insert(char *str)</p>
<p>{</p>
<pre><code>int p = 0;

for (int i = 0; str[i]; i ++ )

&#123;

    int u = str[i] - &#39;a&#39;;

    if (!son[p][u]) son[p][u] = ++ idx;

    p = son[p][u];

&#125;

cnt[p] ++ ;
</code></pre>
<p>}&#x2F;&#x2F;插入</p>
<p>int query(char *str)</p>
<p>{</p>
<pre><code>int p = 0;

for (int i = 0; str[i]; i ++ )

&#123;

    int u = str[i] - &#39;a&#39;;

    if (!son[p][u]) return 0;

    p = son[p][u];

&#125;

return cnt[p];
</code></pre>
<p>}&#x2F;&#x2F;查询</p>
<p>int main()</p>
<p>{</p>
<pre><code>int n;

scanf(&quot;%d&quot;, &amp;n);

while (n -- )

&#123;

    char op[2];

    scanf(&quot;%s%s&quot;, op, str);

    if (*op == &#39;I&#39;) insert(str);

    else printf(&quot;%d\n&quot;, query(str));

&#125;



return 0;
</code></pre>
<p>}</p>
<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>(1)朴素并查集：</p>
<pre><code>int p[N]; //存储每个点的祖宗节点



// 返回x的祖宗节点

int find(int x)

&#123;

    if (p[x] != x) p[x] = find(p[x]);

    return p[x];

&#125;



// 初始化，假定节点编号是1~n

for (int i = 1; i &lt;= n; i ++ ) p[i] = i;



// 合并a和b所在的两个集合：

p[find(a)] = find(b);
</code></pre>
<p>(2)维护size的并查集：</p>
<pre><code>int p[N], size[N];

//p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量



// 返回x的祖宗节点

int find(int x)

&#123;

    if (p[x] != x) p[x] = find(p[x]);

    return p[x];

&#125;



// 初始化，假定节点编号是1~n

for (int i = 1; i &lt;= n; i ++ )

&#123;

    p[i] = i;

    size[i] = 1;

&#125;



// 合并a和b所在的两个集合：

size[find(b)] += size[find(a)];

p[find(a)] = find(b);
</code></pre>
<p>(3)维护到祖宗节点距离的并查集：</p>
<pre><code>int p[N], d[N];

//p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离



// 返回x的祖宗节点

int find(int x)

&#123;

    if (p[x] != x)

    &#123;

        int u = find(p[x]);

        d[x] += d[p[x]];

        p[x] = u;

    &#125;

    return p[x];

&#125;



// 初始化，假定节点编号是1~n

for (int i = 1; i &lt;= n; i ++ )

&#123;

    p[i] = i;

    d[i] = 0;

&#125;



// 合并a和b所在的两个集合：

p[find(a)] = find(b);

d[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量
</code></pre>
<p>应用</p>
<p>const int N&#x3D;100010;</p>
<p>int p[N],n,m;</p>
<p>int find(int x){&#x2F;&#x2F;找到祖宗节点+路径压缩</p>
<pre><code>if(p[x]!=x)p[x]=find(p[x]);

return p[x];
</code></pre>
<p>}</p>
<p>int main(){</p>
<pre><code>scanf(&quot;%d%d&quot;,&amp;n,&amp;m);

for(int i=1;i&lt;=n;i++)p[i]=i;

while(m--)&#123;

    char op[2];

    int a,b;

    scanf(&quot;%s%d%d&quot;,op,&amp;a,&amp;b);

    if(op[0]==&#39;M&#39;)p[find(a)]=find(b);

    else &#123;

        if(find(a)==find(b))puts(&quot;Yes&quot;);

        else puts(&quot;No&quot;);

    &#125;

&#125;

return 0;
</code></pre>
<p>}</p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>&#x2F;&#x2F; h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1</p>
<p>&#x2F;&#x2F; ph[k]存储第k个插入的点在堆中的位置</p>
<p>&#x2F;&#x2F; hp[k]存储堆中下标是k的点是第几个插入的</p>
<p>int h[N], ph[N], hp[N], size;</p>
<p>&#x2F;&#x2F; 交换两个点，及其映射关系</p>
<p>void heap_swap(int a, int b)</p>
<p>{</p>
<pre><code>swap(ph[hp[a]],ph[hp[b]]);

swap(hp[a], hp[b]);

swap(h[a], h[b]);
</code></pre>
<p>}</p>
<p>void down(int u)</p>
<p>{</p>
<pre><code>int t = u;

if (u * 2 &lt;= size &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2;

if (u * 2 + 1 &lt;= size &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1;

if (u != t)

&#123;

    heap_swap(u, t);

    down(t);

&#125;
</code></pre>
<p>}</p>
<p>void up(int u)</p>
<p>{</p>
<pre><code>while (u / 2 &amp;&amp; h[u] &lt; h[u / 2])

&#123;

    heap_swap(u, u / 2);

    u &gt;&gt;= 1;

&#125;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; O(n)建堆</p>
<p>for (int i &#x3D; n &#x2F; 2; i; i – ) down(i);</p>
<p>应用：堆排序</p>
<p>const int N&#x3D;100010;</p>
<p>int heap[N],cnt;</p>
<p>void down(int u){</p>
<pre><code>int t=u;

if(u*2&lt;=cnt&amp;&amp;heap[u*2]&lt;=heap[t])t=u*2;

if(u*2+1&lt;=cnt&amp;&amp;heap[u*2+1]&lt;=heap[t])t=u*2+1;

if(t!=u)&#123;

    swap(heap[t],heap[u]);

    down(t);

&#125;
</code></pre>
<p>}&#x2F;&#x2F;down操作</p>
<p>void up(int u){</p>
<pre><code>while(u/2&amp;&amp;heap[u/2]&gt;heap[u])&#123;

    swap(heap[u/2],heap[u]);

    u&gt;&gt;=1;

&#125;
</code></pre>
<p>}&#x2F;&#x2F;up操作</p>
<p>int main(){</p>
<pre><code>int n,m;

scanf(&quot;%d%d&quot;,&amp;n,&amp;m);

for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;heap[i]);

cnt=n;

for(int i=n/2;i;i--)down(i);

while(m--)&#123;

    printf(&quot;%d &quot;,heap[1]);

    heap[1]=heap[cnt--];

    down(1);

&#125;

return 0;
</code></pre>
<p>}</p>
<h3 id="一般hash"><a href="#一般hash" class="headerlink" title="一般hash"></a>一般hash</h3><p>(1) 拉链法</p>
<pre><code>int h[N], e[N], ne[N], idx;



// 向哈希表中插入一个数

void insert(int x)

&#123;

    int k = (x % N + N) % N;

    e[idx] = x;

    ne[idx] = h[k];

    h[k] = idx ++ ;

&#125;



// 在哈希表中查询某个数是否存在

bool find(int x)

&#123;

    int k = (x % N + N) % N;

    for (int i = h[k]; i != -1; i = ne[i])

        if (e[i] == x)

            return true;



    return false;

&#125;
</code></pre>
<p>(2) 开放寻址法</p>
<pre><code>int h[N];



// 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置

int find(int x)

&#123;

    int t = (x % N + N) % N;

    while (h[t] != null &amp;&amp; h[t] != x)

    &#123;

        t ++ ;

        if (t == N) t = 0;

    &#125;

    return t;

&#125;
</code></pre>
<h3 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h3><p>核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低</p>
<p>小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果</p>
<p>typedef unsigned long long ULL;</p>
<p>ULL h[N], p[N]; &#x2F;&#x2F; h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64</p>
<p>&#x2F;&#x2F; 初始化</p>
<p>p[0] &#x3D; 1;</p>
<p>for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )</p>
<p>{</p>
<pre><code>h[i] = h[i - 1] * P + str[i];

p[i] = p[i - 1] * P;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; 计算子串 str[l ~ r] 的哈希值</p>
<p>ULL get(int l, int r)</p>
<p>{</p>
<pre><code>return h[r] - h[l - 1] * p[r - l + 1];
</code></pre>
<p>}</p>
<h3 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h3><p>STL容器.png</p>
<p>视频讲解：[100 STL 容器_哔哩哔哩_bilibili]：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1tF411G73c/">https://www.bilibili.com/video/BV1tF411G73c/</a></p>
<p>vector, 变长数组，倍增的思想</p>
<pre><code>size()  返回元素个数

empty()  返回是否为空

clear()  清空

front()/back()

push_back()/pop_back()

begin()/end()

[]

支持比较运算，按字典序
</code></pre>
<p>pair&lt;int, int&gt;</p>
<pre><code>first, 第一个元素

second, 第二个元素

支持比较运算，以first为第一关键字，以second为第二关键字（字典序）
</code></pre>
<p>string，字符串</p>
<pre><code>size()/length()  返回字符串长度

empty()

clear()

substr(起始下标，(子串长度))  返回子串

c_str()  返回字符串所在字符数组的起始地址
</code></pre>
<p>queue, 队列</p>
<pre><code>size()

empty()

push()  向队尾插入一个元素

front()  返回队头元素

back()  返回队尾元素

pop()  弹出队头元素
</code></pre>
<p>priority_queue, 优先队列，默认是大根堆</p>
<pre><code>size()

empty()

push()  插入一个元素

top()  返回堆顶元素

pop()  弹出堆顶元素

定义成小根堆的方式：priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;
</code></pre>
<p>stack, 栈</p>
<pre><code>size()

empty()

push()  向栈顶插入一个元素

top()  返回栈顶元素

pop()  弹出栈顶元素
</code></pre>
<p>deque, 双端队列</p>
<pre><code>size()

empty()

clear()

front()/back()

push_back()/pop_back()

push_front()/pop_front()

begin()/end()

[]
</code></pre>
<p>set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列</p>
<pre><code>size()

empty()

clear()

begin()/end()

++, -- 返回前驱和后继，时间复杂度 O(logn)



set/multiset

    insert()  插入一个数

    find()  查找一个数

    count()  返回某一个数的个数

    erase()

        (1) 输入是一个数x，删除所有x   O(k + logn)

        (2) 输入一个迭代器，删除这个迭代器

    lower_bound()/upper_bound()

        lower_bound(x)  返回大于等于x的最小的数的迭代器

        upper_bound(x)  返回大于x的最小的数的迭代器

map/multimap

    insert()  插入的数是一个pair

    erase()  输入的参数是pair或者迭代器

    find()

    []  注意multimap不支持此操作。 时间复杂度是 O(logn)

    lower_bound()/upper_bound()
</code></pre>
<p>unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表</p>
<pre><code>和上面类似，增删改查的时间复杂度是 O(1)

不支持 lower_bound()/upper_bound()， 迭代器的++，--
</code></pre>
<p>bitset, 圧位</p>
<pre><code>bitset&lt;10000&gt; s;

~, &amp;, |, ^

&gt;&gt;, &lt;&lt;

==, !=

[]



count()  返回有多少个1



any()  判断是否至少有一个1

none()  判断是否全为0



set()  把所有位置成1

set(k, v)  将第k位变成v

reset()  把所有位变成0

flip()  等价于~

flip(k) 把第k位取反
</code></pre>
<h2 id="三、搜索与图论"><a href="#三、搜索与图论" class="headerlink" title="三、搜索与图论"></a>三、搜索与图论</h2><h3 id="树与图的存储"><a href="#树与图的存储" class="headerlink" title="树与图的存储"></a>树与图的存储</h3><p>树是一种特殊的图，与图的存储方式相同。</p>
<p>对于无向图中的边ab，存储两条有向边a-&gt;b, b-&gt;a。</p>
<p>因此我们可以只考虑有向图的存储。</p>
<h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>邻接矩阵：g[a][b] 存储边a-&gt;b的距离</p>
<h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>&#x2F;&#x2F; 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点</p>
<p>int h[N], e[N], ne[N], idx;</p>
<p>&#x2F;&#x2F; 添加一条边a-&gt;b </p>
<p>void add(int a, int b)</p>
<p>{</p>
<pre><code>//存下b的值，b下一个指向a的下个一节点，a的下一个节点指向b

e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; 初始化</p>
<p>idx &#x3D; 0;</p>
<p>memset(h, -1, sizeof h);</p>
<h3 id="树与图的遍历"><a href="#树与图的遍历" class="headerlink" title="树与图的遍历"></a>树与图的遍历</h3><p>时间复杂度O(n+m)，n表示点数，m表示边数</p>
<p>深度优先遍历</p>
<p>int dfs(int u)</p>
<p>{</p>
<pre><code>st[u] = true; // st[u] 表示点u已经被遍历过



for (int i = h[u]; i != -1; i = ne[i])

&#123;

    int j = e[i];

    if (!st[j]) dfs(j);

&#125;
</code></pre>
<p>}</p>
<h3 id="应用：数字全排列"><a href="#应用：数字全排列" class="headerlink" title="应用：数字全排列"></a>应用：数字全排列</h3><p>#include <iostream></p>
<p>using namespace std;</p>
<p>int res[10],b[10],n;</p>
<p>void dfs(int k){</p>
<pre><code>if(k==n)&#123;//k==n则输出n个数字

    for(int i=0;i&lt;n;i++)printf(&quot;%d &quot;,res[i]);

    cout&lt;&lt;endl;

&#125;

for(int i=1;i&lt;=n;i++)&#123;

    if(!b[i])&#123;//判断是否被用过

        res[k]=i;//当前k位存入位置

        b[i]=1;//表示被占用

        dfs(k+1);

        b[i]=0;//恢复现场

    &#125;

&#125;
</code></pre>
<p>}</p>
<p>int main(){</p>
<pre><code>cin&gt;&gt;n;

dfs(0);//从0开始枚举

return 0;
</code></pre>
<p>}</p>
<h3 id="应用：树的重心"><a href="#应用：树的重心" class="headerlink" title="应用：树的重心"></a>应用：树的重心</h3><p>#include <cstdio></p>
<p>#include <cstring></p>
<p>#include <iostream></p>
<p>#include <algorithm></p>
<p>using namespace std;</p>
<p>const int N &#x3D; 100010, M &#x3D; N * 2;&#x2F;&#x2F;无向图n条边时，最多2n个idx，因为每条边在邻接表中会出现两次</p>
<p>int n;&#x2F;&#x2F;n个结点,n-1条边</p>
<p>int h[N], e[M], ne[M], idx;&#x2F;&#x2F;n个链表头，e每一个结点的值，ne每一个结点的next指针</p>
<p>int ans &#x3D; N;&#x2F;&#x2F;最小的最大值</p>
<p>bool st[N];&#x2F;&#x2F;状态数组，防止子节点搜索父节点</p>
<p>void add(int a, int b)&#x2F;&#x2F;a-&gt;b</p>
<p>{&#x2F;&#x2F;e记录当前点的值(地址-&gt;值),ne下一点的地址(地址-&gt;地址)，h记录指向的第一个点的地址(值-&gt;地址)</p>
<pre><code>e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
</code></pre>
<p>}&#x2F;&#x2F;头插法</p>
<p>int dfs(int u)&#x2F;&#x2F;通过h数组找到子结点的向</p>
<p>{</p>
<pre><code>st[u] = true;//st标记当前点被搜过



int size = 0, sum = 0;

//size删掉元素后各个子连通块的最大值

//sum当前子树大小，遍历叶节点时，返回1



for (int i = h[u]; i != -1; i = ne[i])//遍历单链表，链表末端初始化为-1

&#123;

    int j=e[i];

    if(st[j])continue;//此处防逆向dfs

    int s = dfs(j);//s各个子连通块的大小

    size = max(size, s);//size删掉元素后各个连通块的最大值

    sum += s;//各个连通块大小之和

&#125;



size = max(size, n - sum - 1);//判断最大子连通块与父连通块的最大值

ans = min(ans, size);//全局变量ans存最小的最大值
</code></pre>
<p>&#x2F;&#x2F;注意：本题若求最大的最大值，则只需去除任意叶节点即可，即n-1</p>
<pre><code>return sum + 1;//各个子连通块，当前结点之和
</code></pre>
<p>}</p>
<p>int main()</p>
<p>{</p>
<pre><code>scanf(&quot;%d&quot;, &amp;n);



memset(h, -1, sizeof h);//n个头节点全部指向-1



for (int i = 0; i &lt; n - 1; i ++ )//n个结点，n-1条边

&#123;

    int a, b;

    scanf(&quot;%d%d&quot;, &amp;a, &amp;b);

    add(a, b), add(b, a);//不知道子节点还是父节点，所以需要建两条边可以双向查找

&#125;



dfs(1);//结点编号为1~n且可能只有一个结点，则参数只能为1

printf(&quot;%d\n&quot;, ans);

return 0;
</code></pre>
<p>}</p>
<h3 id="应用：n-皇后问题"><a href="#应用：n-皇后问题" class="headerlink" title="应用：n-皇后问题"></a>应用：n-皇后问题</h3><p>n皇后搜索图示</p>
<p>using namespace std;</p>
<p>const int N &#x3D; 11;</p>
<p>char q[N][N];&#x2F;&#x2F;存储棋盘</p>
<p>bool dg[N * 2], udg[N * 2], cor[N];&#x2F;&#x2F;点对应的两个斜线以及列上是否有皇后</p>
<p>int n;</p>
<p>void dfs(int r)</p>
<p>{</p>
<pre><code>if(r == n)//放满了棋盘，输出棋盘

&#123;

    for(int i = 0; i &lt; n; i++)

    &#123;

        for(int j = 0; j &lt; n; j++)

            cout &lt;&lt; q[i][j];

        cout &lt;&lt; endl;

    &#125;

    cout &lt;&lt; endl;

    return;

&#125;



for(int i = 0; i &lt; n; i++)//第 r 行，第 i 列 是否放皇后

&#123;

    if(!cor[i] &amp;&amp; !dg[i + r] &amp;&amp; !udg[n - i + r])//不冲突，放皇后

    &#123;

        q[r][i] = &#39;Q&#39;;

        cor[i] = dg[i + r] = udg[n - i + r] = 1;//对应的 列， 斜线 状态改变

        dfs(r + 1);//处理下一行

        cor[i] = dg[i + r] = udg[n - i + r] = 0;//恢复现场

        q[r][i] = &#39;.&#39;;

    &#125;

&#125;
</code></pre>
<p>}</p>
<p>int main()</p>
<p>{</p>
<pre><code>cin &gt;&gt; n;

for (int i = 0; i &lt; n; i ++ )

    for (int j = 0; j &lt; n; j ++ )

        q[i][j] = &#39;.&#39;;

dfs(0);

return 0;
</code></pre>
<p>}</p>
<h3 id="宽度优先遍历"><a href="#宽度优先遍历" class="headerlink" title="宽度优先遍历"></a>宽度优先遍历</h3><p>queue<int> q;</p>
<p>st[1] &#x3D; true; &#x2F;&#x2F; 表示1号点已经被遍历过</p>
<p>q.push(1);</p>
<p>while (q.size())</p>
<p>{</p>
<pre><code>int t = q.front();

q.pop();



for (int i = h[t]; i != -1; i = ne[i])

&#123;

    int j = e[i];

    if (!st[j])

    &#123;

        st[j] = true; // 表示点j已经被遍历过

        q.push(j);

    &#125;

&#125;
</code></pre>
<p>}</p>
<h3 id="应用：走迷宫"><a href="#应用：走迷宫" class="headerlink" title="应用：走迷宫"></a>应用：走迷宫</h3><p>typedef pair&lt;int,int&gt; PII;&#x2F;&#x2F;声明pair时候必须要在代码前面写上using namespace std;</p>
<p>const int N&#x3D;110;</p>
<p>int g[N][N],f[N][N],n,m;</p>
<p>int bfs(int x,int y){</p>
<pre><code>queue&lt;PII&gt; que;

que.push(&#123;x,y&#125;);

int dx[4]=&#123;0,1,0,-1&#125;,dy[4]=&#123;1,0,-1,0&#125;;

while(!que.empty())&#123;

    PII t=que.front();

    que.pop();

    g[t.first][t.second]=1;

    for(int i=0;i&lt;4;i++)&#123;

        int a=t.first+dx[i],b=t.second+dy[i];

        if(a&gt;=0&amp;&amp;b&gt;=0&amp;&amp;a&lt;n&amp;&amp;b&lt;m&amp;&amp;!g[a][b])&#123;

            g[a][b]=1;

            f[a][b]=f[t.first][t.second]+1;

            que.push(&#123;a,b&#125;);

        &#125;

    &#125;

&#125;

return f[n-1][m-1];
</code></pre>
<p>}</p>
<p>int main(){</p>
<pre><code>scanf(&quot;%d%d&quot;,&amp;n,&amp;m);

for(int i=0;i&lt;n;i++)

    for(int j=0;j&lt;m;j++)

        scanf(&quot;%d&quot;,&amp;g[i][j]);

cout&lt;&lt;bfs(0,0)&lt;&lt;endl;

return 0;
</code></pre>
<p>}</p>
<h3 id="应用：八数码"><a href="#应用：八数码" class="headerlink" title="应用：八数码"></a>应用：八数码</h3><p>using namespace std;</p>
<p>int bfs(string state) {</p>
<pre><code>queue&lt;string&gt; q;

unordered_map&lt;string, int&gt; d;



int dx[4] = &#123;-1, 0, 1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;;

string ed = &quot;12345678x&quot;;

q.push(state);

d[state] = 0;



while (q.size()) &#123;

    auto t = q.front();

    q.pop();

    if (t == ed)//等于结果就输出步数

        return d[t];

    int distance = d[t];

    int k = t.find(&#39;x&#39;);//寻找x

    int x = k / 3, y = k % 3;//计算下标

    for (int i = 0; i &lt; 4; i ++ ) &#123;

        int a = x + dx[i], b = y + dy[i];

        if (a &gt;= 0 &amp;&amp; a &lt; 3 &amp;&amp; b &gt;= 0 &amp;&amp; b &lt; 3) &#123;

            swap(t[a * 3 + b], t[k]);//交换

            if (!d.count(t)) &#123;//不存在就入队

                d[t] = distance + 1;

                q.push(t);

            &#125;

            swap(t[a * 3 + b], t[k]);//还原

        &#125;

    &#125;

&#125;

return -1;
</code></pre>
<p>}</p>
<p>int main() {</p>
<pre><code>char s[2];

string state;

for (int i = 0; i &lt; 9; i ++ ) &#123;

    cin &gt;&gt; s;

    state += *s;

&#125;

cout&lt;&lt;bfs(state)&lt;&lt;endl;

return 0;
</code></pre>
<p>}</p>
<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>啥是拓扑排序？</p>
<p>一个有向图，如果图中有入度为 0 的点，就把这个点删掉，同时也删掉这个点所连的边。</p>
<p>一直进行上面出处理，如果所有点都能被删掉，则这个图可以进行拓扑排序。</p>
<h4 id="纯净版"><a href="#纯净版" class="headerlink" title="纯净版"></a>纯净版</h4><p>bool topsort()</p>
<p>{</p>
<pre><code>int hh = 0, tt = -1;



// d[i] 存储点i的入度

for (int i = 1; i &lt;= n; i ++ )

    if (!d[i])

        q[ ++ tt] = i;



while (hh &lt;= tt)

&#123;

    int t = q[hh ++ ];



    for (int i = h[t]; i != -1; i = ne[i])

    &#123;

        int j = e[i];

        if (-- d[j] == 0)

            q[ ++ tt] = j;

    &#125;

&#125;



// 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。

return tt == n - 1;
</code></pre>
<p>}</p>
<h4 id="解说版"><a href="#解说版" class="headerlink" title="解说版"></a>解说版</h4><p>using namespace std;</p>
<p>const int N &#x3D; 100010;</p>
<p>int e[N], ne[N], idx; &#x2F;&#x2F;邻接表存储图</p>
<p>int h[N];&#x2F;&#x2F;邻接表的每个头链表</p>
<p>int q[N], hh &#x3D; 0, tt &#x3D; -1; &#x2F;&#x2F;队列保存入度为0的点，也就是能够输出的点</p>
<p>int n, m; &#x2F;&#x2F;保存图的点数和边数</p>
<p>int d[N];&#x2F;&#x2F;保存各个点的入度</p>
<p>void add(int a, int b) {</p>
<pre><code>e[idx] = b, ne[idx] = h[a], h[a] = idx++;
</code></pre>
<p>}</p>
<p>void topsort() {</p>
<pre><code>for (int i = 1; i &lt;= n; i++) &#123;//遍历一遍顶点的入度。

    if (!d[i])//如果入度为0，则可以入队列

        q[++tt] = i;

&#125;

while (tt &gt;= hh) &#123; //循环处理队列中点的

    int a = q[hh++];

    for (int i = h[a]; i != -1; i = ne[i]) &#123;

        int b = e[i]; //a 有一条边指向b

        d[b]--;//删除边后，b的入度减1

        if (!d[b])//如果b的入度减为 0,则 b 可以输出，入队列

            q[++tt] = b;

    &#125;

&#125;

if (tt == n - 1) &#123;//如果队列中的点的个数与图中点的个数相同，则可以进行拓扑排序

    for (int i = 0; i &lt; n; i++)//队列中保存了所有入度为0的点，依次输出

        printf(&quot;%d &quot;, q[i]);

&#125; else//如果队列中的点的个数与图中点的个数不相同，则可以进行拓扑排序

    cout &lt;&lt; -1;
</code></pre>
<p>}</p>
<p>int main() {</p>
<pre><code>cin &gt;&gt; n &gt;&gt; m; //保存点的个数和边的个数

memset(h, -1, sizeof h); //初始化领接矩阵

while (m--) &#123; //依次读入边

    int a, b;

    cin &gt;&gt; a &gt;&gt; b;

    d[b]++;//顶点b的入度+1

    add(a, b); //添加到邻接矩阵

&#125;

topsort();//进行拓扑排序

return 0;
</code></pre>
<p>}</p>
<h3 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h3><h4 id="朴素版"><a href="#朴素版" class="headerlink" title="朴素版"></a>朴素版</h4><p>时间复杂是O(n2+m)</p>
<p>，n表示点数，m表示边数</p>
<p>int g[N][N];  &#x2F;&#x2F; 存储每条边</p>
<p>int dist[N];  &#x2F;&#x2F; 存储1号点到每个点的最短距离</p>
<p>bool st[N];   &#x2F;&#x2F; 存储每个点的最短路是否已经确定</p>
<p>&#x2F;&#x2F; 求1号点到n号点的最短路，如果不存在则返回-1</p>
<p>int dijkstra()</p>
<p>{</p>
<pre><code>memset(dist, 0x3f, sizeof dist);

dist[1] = 0;



for (int i = 0; i &lt; n - 1; i ++ )

&#123;

    int t = -1;     // 在还未确定最短路的点中，寻找距离最小的点

    for (int j = 1; j &lt;= n; j ++ )

        if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))

            t = j;



    // 用t更新其他点的距离

    for (int j = 1; j &lt;= n; j ++ )

        dist[j] = min(dist[j], dist[t] + g[t][j]);



    st[t] = true;

&#125;



if (dist[n] == 0x3f3f3f3f) return -1;

return dist[n];
</code></pre>
<p>}</p>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>const int N &#x3D; 510, M &#x3D; 100010;</p>
<p>int h[N], e[M], ne[M], w[M], idx;&#x2F;&#x2F;邻接表存储图</p>
<p>int state[N];&#x2F;&#x2F;state 记录是否找到了源点到该节点的最短距离</p>
<p>int dist[N];&#x2F;&#x2F;dist 数组保存源点到其余各个节点的距离</p>
<p>int n, m;&#x2F;&#x2F;图的节点个数和边数</p>
<p>void add(int a, int b, int c)&#x2F;&#x2F;插入边</p>
<p>{</p>
<pre><code>e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
</code></pre>
<p>}</p>
<p>void Dijkstra()</p>
<p>{</p>
<pre><code>memset(dist, 0x3f, sizeof(dist));//dist 数组的各个元素为无穷大

dist[1] = 0;//源点到源点的距离为置为 0

for (int i = 0; i &lt; n; i++)

&#123;

    int t = -1;

    for (int j = 1; j &lt;= n; j++)//遍历 dist 数组，找到没有确定最短路径的节点中距离源点最近的点t

    &#123;

        if (!state[j] &amp;&amp; (t == -1 || dist[j] &lt; dist[t]))

            t = j;

    &#125;



    state[t] = 1;//state[i] 置为 1。



    for (int j = h[t]; j != -1; j = ne[j])//遍历 t 所有可以到达的节点 i

    &#123;

        int i = e[j];

        dist[i] = min(dist[i], dist[t] + w[j]);//更新 dist[j]

    &#125;





&#125;
</code></pre>
<p>}</p>
<p>int main()</p>
<p>{</p>
<pre><code>memset(h, -1, sizeof(h));//邻接表初始化



cin &gt;&gt; n &gt;&gt; m;

while (m--)//读入 m 条边

&#123;

    int a, b, w;

    cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;

    add(a, b, w);

&#125;



Dijkstra();

if (dist[n] != 0x3f3f3f3f)//如果dist[n]被更新了，则存在路径

    cout &lt;&lt; dist[n];

else

    cout &lt;&lt; &quot;-1&quot;;
</code></pre>
<p>}</p>
<h4 id="堆优化版"><a href="#堆优化版" class="headerlink" title="堆优化版"></a>堆优化版</h4><p>时间复杂度O(mlogn)</p>
<p>，n表示点数，m表示边数</p>
<p>typedef pair&lt;int, int&gt; PII;</p>
<p>int n;      &#x2F;&#x2F; 点的数量</p>
<p>int h[N], w[N], e[N], ne[N], idx;       &#x2F;&#x2F; 邻接表存储所有边</p>
<p>int dist[N];        &#x2F;&#x2F; 存储所有点到1号点的距离</p>
<p>bool st[N];     &#x2F;&#x2F; 存储每个点的最短距离是否已确定</p>
<p>&#x2F;&#x2F; 求1号点到n号点的最短距离，如果不存在，则返回-1</p>
<p>int dijkstra(){</p>
<pre><code>memset(dist,0x3f,sizeof dist);//距离初始化为无穷大

dist[1]=0;//1-&gt;1的节点距离为0

priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt; heap;//小根堆

heap.push(&#123;0,1&#125;);//插入距离和节点编号



while(heap.size())&#123;

    auto t=heap.top();//取距离源点最近的点

    heap.pop();



    int ver=t.second,distance=t.first;//ver：节点编号，distance源点距离ver

    if(st[ver])continue;//如果距离已经确定，则跳过该点

    st[ver]=true;

    for(int i=h[ver];i!=-1;i=ne[i])//更新ver所指向的节点距离

    &#123;

        int j=e[i];

        if(dist[j]&gt;dist[ver]+w[i])&#123;

            dist[j]=dist[ver]+w[i];

            heap.push(&#123;dist[j],j&#125;);//距离变小，则入堆

        &#125;

    &#125;

&#125;

if(dist[n]==0x3f3f3f3f)return -1;

return dist[n];
</code></pre>
<p>}</p>
<h4 id="关于Dijkstra的相关博客链接："><a href="#关于Dijkstra的相关博客链接：" class="headerlink" title="关于Dijkstra的相关博客链接："></a>关于Dijkstra的相关博客链接：</h4><p>[AcWing 849. Dijkstra求最短路 I：图解 详细代码（图解） - AcWing：<a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/38318/">https://www.acwing.com/solution/content/38318/</a></p>
<p>[AcWing 850. Dijkstra求最短路 II：详解+代码注释 - AcWing]：<a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/38323/">https://www.acwing.com/solution/content/38323/</a></p>
<h3 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman-Ford算法"></a>Bellman-Ford算法</h3><p>时间复杂度O(nm)，n表示点数，m表示边数</p>
<p>注意在模板题中需要对下面的模板稍作修改，加上备份数组，详情见模板题。</p>
<p>Bellman-ford算法动态规划图示.png</p>
<p>上图为Bellman-ford草稿图</p>
<p>int n, m;       &#x2F;&#x2F; n表示点数，m表示边数</p>
<p>int dist[N],backup[N];        &#x2F;&#x2F; dist[x]存储1到x的最短路距离</p>
<p>struct Edge     &#x2F;&#x2F; 边，a表示出点，b表示入点，w表示边的权重</p>
<p>{</p>
<pre><code>int a, b, w;
</code></pre>
<p>}edges[M];</p>
<p>&#x2F;&#x2F; 求1到n的最短路距离，如果无法从1走到n，则返回-1。</p>
<p>int bellman_ford()</p>
<p>{</p>
<pre><code>memset(dist, 0x3f, sizeof dist);

dist[1] = 0;



// 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。

for (int i = 0; i &lt; n; i ++ )

&#123;

    memcpy(back,dist,sizeof dist);

    for (int j = 0; j &lt; m; j ++ )

    &#123;

        int a = edges[j].a, b = edges[j].b, w = edges[j].w;

        if (dist[b] &gt; backup[a] + w)

            dist[b] = backup[a] + w;

    &#125;

&#125;



if (dist[n] &gt; 0x3f3f3f3f / 2) return -1;

return dist[n];
</code></pre>
<p>}</p>
<h4 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h4><p>int n,m,k;</p>
<p>const int N&#x3D;512,M&#x3D;10012;</p>
<p>struct Edge{</p>
<pre><code>int a,b,w;
</code></pre>
<p>}e[M];</p>
<p>int dist[N];</p>
<p>int back[N];</p>
<p>void bellman_ford(){</p>
<pre><code>memset(dist,0x3f,sizeof dist);

dist[1]=0;

for(int i=0;i&lt;k;i++)&#123;

    memcpy(back,dist,sizeof dist);

    for(int j=0;j&lt;m;j++)&#123;

        int a=e[j].a,b=e[j].b,c=e[j].w;

        dist[b]=min(dist[b],back[a]+c);

    &#125;

&#125;
</code></pre>
<p>}</p>
<p>int main(){</p>
<pre><code>scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k);

for(int i=0;i&lt;m;i++)&#123;

    int a,b,w;

    scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;w);

    e[i]=&#123;a,b,w&#125;;

&#125;

bellman_ford();

if(dist[n]&gt;0x3f3f3f3f/2)cout&lt;&lt;&quot;impossible&quot;&lt;&lt;endl;

else cout&lt;&lt;dist[n]&lt;&lt;endl;

return 0;
</code></pre>
<p>}</p>
<p>问题：为什么把每一条边用不等式刷k次就是k条件下的值？</p>
<p>你可以想象这个图是1-&gt;2-&gt;3-&gt;4….-&gt;n这样一条直线。比如说第一次迭代，为什么只有与原点相连的点才能被更新dist呢？因为原点的dist是0，其他点的dist是+∞，满足dist[2] &gt; dist[1]+c，而+∞并不&gt;+∞+c，所以第一次迭代结束就是不超过一条边走到i节点最短路的距离，依次类推，第二次迭代，只有3会被更新，因为只有1、2的dist不是+∞，第二次迭代就是不超过2条边走到i节点的最短距离。这就是为什么k次迭代最多是走了k条边，同时也是为什么一共只用迭代n-1次，因为n个点的有向图，如果能走到，原点到n号点的最短距离最多是n-1次，也就是1-&gt;2-&gt;…-&gt;n直线这种。</p>
<h3 id="SPFA算法（队列优化的Bellman-Ford算法）"><a href="#SPFA算法（队列优化的Bellman-Ford算法）" class="headerlink" title="SPFA算法（队列优化的Bellman-Ford算法）"></a>SPFA算法（队列优化的Bellman-Ford算法）</h3><p>时间复杂度平均情况下O(m)，最坏情况下O(nm)，n表示点数，m表示边数</p>
<p>模板</p>
<p>int n;      &#x2F;&#x2F; 总点数</p>
<p>int h[N], w[N], e[N], ne[N], idx;       &#x2F;&#x2F; 邻接表存储所有边</p>
<p>int dist[N];        &#x2F;&#x2F; 存储每个点到1号点的最短距离</p>
<p>bool st[N];     &#x2F;&#x2F; 存储每个点是否在队列中</p>
<p>&#x2F;&#x2F; 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1</p>
<p>int spfa()</p>
<p>{</p>
<pre><code>memset(dist, 0x3f, sizeof dist);

dist[1] = 0;



queue&lt;int&gt; q;

q.push(1);

st[1] = true;



while (q.size())

&#123;

    auto t = q.front();

    q.pop();



    st[t] = false;



    for (int i = h[t]; i != -1; i = ne[i])

    &#123;

        int j = e[i];

        if (dist[j] &gt; dist[t] + w[i])

        &#123;

            dist[j] = dist[t] + w[i];

            if (!st[j])     // 如果队列中已存在j，则不需要将j重复插入

            &#123;

                q.push(j);

                st[j] = true;

            &#125;

        &#125;

    &#125;

&#125;



if (dist[n] == 0x3f3f3f3f) return -1;

return dist[n];
</code></pre>
<p>}</p>
<h4 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h4><p>const int N &#x3D; 1e6 + 10;</p>
<p>int n, m;&#x2F;&#x2F;节点数量和边数</p>
<p>int h[N], w[N], e[N], ne[N], idx;&#x2F;&#x2F;邻接矩阵存储图</p>
<p>int dist[N];&#x2F;&#x2F;存储距离</p>
<p>bool st[N];&#x2F;&#x2F;存储状态</p>
<p>void add(int a, int b, int c)</p>
<p>{</p>
<pre><code>e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
</code></pre>
<p>}</p>
<p>int spfa()</p>
<p>{</p>
<pre><code>memset(dist, 0x3f, sizeof dist);//距离初始化为无穷大

dist[1] = 0;//初始化1到1的距离为0

queue&lt;int&gt; que;//队列

que.push(1);//1入队



while (que.size())//判断是否存在

&#123;

    int t=que.front();

    que.pop();//获取第一个并出队

    st[t]=false;//第一个取消占用

    for(int i=h[t];i!=-1;i=ne[i])&#123;//遍历第一个可以到达的结点

        int j=e[i];

        if(dist[j]&gt;dist[t]+w[i])&#123;//1号点可到达的节点距离是否大于上次的距离距离加上当前的距离

            dist[j]=dist[t]+w[i];//赋值给可到达的节点

            if(!st[j])&#123;//如果可到达的节点未被占用

                que.push(j);//则入队

                st[j]=true;//占用

            &#125;

        &#125;

    &#125;

&#125;



return dist[n];
</code></pre>
<p>}</p>
<p>int main()</p>
<p>{</p>
<pre><code>scanf(&quot;%d%d&quot;, &amp;n, &amp;m);



memset(h, -1, sizeof h);

while (m -- )

&#123;

    int a, b, c;

    scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);

    add(a, b, c);

&#125;



int t=spfa();

if(t==0x3f3f3f3f)cout&lt;&lt;&quot;impossible&quot;&lt;&lt;endl;

else printf(&quot;%d\n&quot;,t);



return 0;
</code></pre>
<p>}</p>
<h4 id="应用：spfa判断图中是否存在负权"><a href="#应用：spfa判断图中是否存在负权" class="headerlink" title="应用：spfa判断图中是否存在负权"></a>应用：spfa判断图中是否存在负权</h4><p>int n;      &#x2F;&#x2F; 总点数</p>
<p>int h[N], w[N], e[N], ne[N], idx;       &#x2F;&#x2F; 邻接表存储所有边</p>
<p>int dist[N], cnt[N];        &#x2F;&#x2F; dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数</p>
<p>bool st[N];     &#x2F;&#x2F; 存储每个点是否在队列中</p>
<p>&#x2F;&#x2F; 如果存在负环，则返回true，否则返回false。</p>
<p>bool spfa()</p>
<p>{</p>
<pre><code>// 不需要初始化dist数组

// 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。



queue&lt;int&gt; q;

for (int i = 1; i &lt;= n; i ++ )

&#123;

    q.push(i);

    st[i] = true;

&#125;



while (q.size())

&#123;

    auto t = q.front();

    q.pop();



    st[t] = false;



    for (int i = h[t]; i != -1; i = ne[i])

    &#123;

        int j = e[i];

        if (dist[j] &gt; dist[t] + w[i])

        &#123;

            dist[j] = dist[t] + w[i];

            cnt[j] = cnt[t] + 1;

            if (cnt[j] &gt;= n) return true;       // 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环

            if (!st[j])

            &#123;

                q.push(j);

                st[j] = true;

            &#125;

        &#125;

    &#125;

&#125;



return false;
</code></pre>
<p>}</p>
<h3 id="floyd算法"><a href="#floyd算法" class="headerlink" title="floyd算法"></a>floyd算法</h3><p>时间复杂度O(n3)，n表示点数</p>
<p>视频讲解：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV14R4y1x7GB/">https://www.bilibili.com/video/BV14R4y1x7GB/</a></p>
<p>模板</p>
<p>初始化：</p>
<pre><code>for (int i = 1; i &lt;= n; i ++ )

    for (int j = 1; j &lt;= n; j ++ )

        if (i == j) d[i][j] = 0;

        else d[i][j] = INF;
</code></pre>
<p>&#x2F;&#x2F; 算法结束后，d[a][b]表示a到b的最短距离</p>
<p>void floyd()</p>
<p>{</p>
<pre><code>for (int k = 1; k &lt;= n; k ++ )//k为中转节点

    for (int i = 1; i &lt;= n; i ++ )

        for (int j = 1; j &lt;= n; j ++ )

            d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
</code></pre>
<p>}</p>
<p>应用</p>
<p>using namespace std;</p>
<p>const int N &#x3D; 210, INF &#x3D; 1e9;</p>
<p>int n, m, Q;</p>
<p>int d[N][N];</p>
<p>void floyd()</p>
<p>{</p>
<pre><code>for (int k = 1; k &lt;= n; k ++ )//k为中转节点

    for (int i = 1; i &lt;= n; i ++ )

        for (int j = 1; j &lt;= n; j ++ )

            d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
</code></pre>
<p>}</p>
<p>int main()</p>
<p>{</p>
<pre><code>scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;Q);



for (int i = 1; i &lt;= n; i ++ )

    for (int j = 1; j &lt;= n; j ++ )

        if (i == j) d[i][j] = 0;

        else d[i][j] = INF;



while (m -- )

&#123;

    int a, b, c;

    scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);

    d[a][b] = min(d[a][b], c);

&#125;



floyd();



while (Q -- )

&#123;

    int a, b;

    scanf(&quot;%d%d&quot;, &amp;a, &amp;b);



    int t = d[a][b];

    if (t &gt; INF / 2) puts(&quot;impossible&quot;);

    else printf(&quot;%d\n&quot;, t);

&#125;



return 0;
</code></pre>
<p>}</p>
<h3 id="最短路算法总结"><a href="#最短路算法总结" class="headerlink" title="最短路算法总结"></a>最短路算法总结</h3><p>最短路</p>
<p>单源最短路：给定V中的一个顶点，称为源。要计算从源到其他所有各顶点的最短路径长度。这里的长度就是指路上各边权之和。这个问题通常称为单源最短路径 问题。</p>
<p>所有边权都是正数：</p>
<p>朴素Dijkstra算法 O(n^2) 适合稠密图，贪心思想</p>
<p>堆优化版的Dijkstra算法 O(mlogn)适合稀疏图，贪心思想</p>
<p>​ 存在负权边：</p>
<p>​ Bellman-ford O(nm)，动态规划思想</p>
<p>​ SPFA 一般：O(m)，最坏O(nm)</p>
<p>多源汇最短路：任意两点最短路径被称为多源最短路径，即给定任意两个点，一个出发点，一个到达点，求这两个点的之间的最短路径，就是任意两点最短路径问题</p>
<p>Floyd算法 O(n^3)</p>
<h3 id="prim算法"><a href="#prim算法" class="headerlink" title="prim算法"></a>prim算法</h3><p>时间复杂度是O(n2+m)，n表示点数，m表示边数</p>
<p>int n;      &#x2F;&#x2F; n表示点数</p>
<p>int g[N][N];        &#x2F;&#x2F; 邻接矩阵，存储所有边</p>
<p>int dist[N];        &#x2F;&#x2F; 存储其他点到当前最小生成树的距离</p>
<p>bool st[N];     &#x2F;&#x2F; 存储每个点是否已经在生成树中</p>
<p>&#x2F;&#x2F; 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和</p>
<p>int prim()</p>
<p>{</p>
<pre><code>memset(dist, 0x3f, sizeof dist);



int res = 0;

for (int i = 0; i &lt; n; i ++ )

&#123;

    int t = -1;

    for (int j = 1; j &lt;= n; j ++ )

        if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))

            t = j;



    if (i &amp;&amp; dist[t] == INF) return INF;



    if (i) res += dist[t];

    st[t] = true;



    for (int j = 1; j &lt;= n; j ++ ) dist[j] = min(dist[j], g[t][j]);

&#125;



return res;
</code></pre>
<p>}</p>
<p>应用</p>
<p>const int N &#x3D; 510, INF &#x3D; 0x3f3f3f3f;</p>
<p>int n, m;</p>
<p>int g[N][N];</p>
<p>int dist[N];</p>
<p>bool st[N];</p>
<p>int prim()</p>
<p>{</p>
<pre><code>memset(dist, 0x3f, sizeof dist);



int res = 0;

for (int i = 0; i &lt; n; i ++ )

&#123;

    int t = -1;

    for (int j = 1; j &lt;= n; j ++ )

        if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))

            t = j;



    if (i &amp;&amp; dist[t] == INF) return INF;



    if (i) res += dist[t];

    st[t] = true;



    for (int j = 1; j &lt;= n; j ++ ) dist[j] = min(dist[j], g[t][j]);

&#125;



return res;
</code></pre>
<p>}</p>
<p>int main()</p>
<p>{</p>
<pre><code>scanf(&quot;%d%d&quot;, &amp;n, &amp;m);



memset(g, 0x3f, sizeof g);



while (m -- )

&#123;

    int a, b, c;

    scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);

    g[a][b] = g[b][a] = min(g[a][b], c);

&#125;



int t = prim();



if (t == INF) puts(&quot;impossible&quot;);

else printf(&quot;%d\n&quot;, t);



return 0;
</code></pre>
<p>}</p>
<h3 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h3><p>时间复杂度O(mlogm)，n表示点数，m表示边数</p>
<p>int n, m;       &#x2F;&#x2F; n是点数，m是边数</p>
<p>int p[N];       &#x2F;&#x2F; 并查集的父节点数组</p>
<p>struct Edge     &#x2F;&#x2F; 存储边</p>
<p>{</p>
<pre><code>int a, b, w;

bool operator&lt; (const Edge &amp;W)const

&#123;

    return w &lt; W.w;

&#125;
</code></pre>
<p>}edges[M];</p>
<p>int find(int x)     &#x2F;&#x2F; 并查集核心操作</p>
<p>{</p>
<pre><code>if (p[x] != x) p[x] = find(p[x]);

return p[x];
</code></pre>
<p>}</p>
<p>int kruskal()</p>
<p>{</p>
<pre><code>sort(edges, edges + m);



for (int i = 1; i &lt;= n; i ++ ) p[i] = i;    // 初始化并查集



int res = 0, cnt = 0;

for (int i = 0; i &lt; m; i ++ )

&#123;

    int a = edges[i].a, b = edges[i].b, w = edges[i].w;



    a = find(a), b = find(b);

    if (a != b)     // 如果两个连通块不连通，则将这两个连通块合并

    &#123;

        p[a] = b;

        res += w;

        cnt ++ ;

    &#125;

&#125;

if (cnt &lt; n - 1) return INF;

return res;
</code></pre>
<p>}</p>
<p>应用</p>
<p>#include <cstring></p>
<p>#include <iostream></p>
<p>#include <algorithm></p>
<p>using namespace std;</p>
<p>const int N &#x3D; 100010, M &#x3D; 200010, INF &#x3D; 0x3f3f3f3f;</p>
<p>int n, m;</p>
<p>int p[N];</p>
<p>struct Edge</p>
<p>{</p>
<pre><code>int a, b, w;



bool operator&lt; (const Edge &amp;W)const

&#123;

    return w &lt; W.w;

&#125;
</code></pre>
<p>}edges[M];</p>
<p>int find(int x)</p>
<p>{</p>
<pre><code>if (p[x] != x) p[x] = find(p[x]);

return p[x];
</code></pre>
<p>}</p>
<p>int kruskal()</p>
<p>{</p>
<pre><code>sort(edges, edges + m);



for (int i = 1; i &lt;= n; i ++ ) p[i] = i;    // 初始化并查集



int res = 0, cnt = 0;

for (int i = 0; i &lt; m; i ++ )

&#123;

    int a = edges[i].a, b = edges[i].b, w = edges[i].w;



    a = find(a), b = find(b);

    if (a != b)

    &#123;

        p[a] = b;

        res += w;

        cnt ++ ;

    &#125;

&#125;



if (cnt &lt; n - 1) return INF;

return res;
</code></pre>
<p>}</p>
<p>int main()</p>
<p>{</p>
<pre><code>scanf(&quot;%d%d&quot;, &amp;n, &amp;m);



for (int i = 0; i &lt; m; i ++ )

&#123;

    int a, b, w;

    scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;w);

    edges[i] = &#123;a, b, w&#125;;

&#125;



int t = kruskal();



if (t == INF) puts(&quot;impossible&quot;);

else printf(&quot;%d\n&quot;, t);



return 0;
</code></pre>
<p>}</p>
<h3 id="染色法判别二分图"><a href="#染色法判别二分图" class="headerlink" title="染色法判别二分图"></a>染色法判别二分图</h3><p>什么叫二分图</p>
<p>有两顶点集且图中每条边的的两个顶点分别位于两个顶点集中，每个顶点集中没有边直接相连接！</p>
<p>说人话的定义：图中点通过移动能分成左右两部分，左侧的点只和右侧的点相连，右侧的点只和左侧的点相连。</p>
<p>下图就是个二分图：</p>
<p>时间复杂度是O(n+m)，n表示点数，m表示边数</p>
<p>int n;      &#x2F;&#x2F; n表示点数</p>
<p>int h[N], e[M], ne[M], idx;     &#x2F;&#x2F; 邻接表存储图</p>
<p>int color[N];       &#x2F;&#x2F; 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色</p>
<p>&#x2F;&#x2F; 参数：u表示当前节点，c表示当前点的颜色</p>
<p>bool dfs(int u, int c)</p>
<p>{</p>
<pre><code>color[u] = c;

for (int i = h[u]; i != -1; i = ne[i])

&#123;

    int j = e[i];

    if (color[j] == -1)

    &#123;

        if (!dfs(j, !c)) return false;

    &#125;

    else if (color[j] == c) return false;

&#125;



return true;
</code></pre>
<p>}</p>
<p>bool check()</p>
<p>{</p>
<pre><code>memset(color, -1, sizeof color);

bool flag = true;

for (int i = 1; i &lt;= n; i ++ )

    if (color[i] == -1)

        if (!dfs(i, 0))

        &#123;

            flag = false;

            break;

        &#125;

return flag;
</code></pre>
<p>}</p>
<h4 id="应用-3"><a href="#应用-3" class="headerlink" title="应用"></a>应用</h4><p>using namespace std;</p>
<p>const int N &#x3D; 100010, M &#x3D; 200010;&#x2F;&#x2F; 由于是无向图, 顶点数最大是N，那么边数M最大是顶点数的2倍</p>
<p>int n, m;</p>
<p>int h[N], e[M], ne[M], idx;</p>
<p>int color[N];</p>
<p>void add(int a, int b)</p>
<p>{</p>
<pre><code>e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
</code></pre>
<p>}</p>
<p>bool dfs(int u, int c)</p>
<p>{</p>
<pre><code>color[u] = c;



for (int i = h[u]; i != -1; i = ne[i])

&#123;

    int j = e[i];

    if (!color[j])

    &#123;

        if (!dfs(j, 3 - c)) return false;

    &#125;

    else if (color[j] == c) return false;

&#125;



return true;
</code></pre>
<p>}</p>
<p>int main()</p>
<p>{</p>
<pre><code>scanf(&quot;%d%d&quot;, &amp;n, &amp;m);



memset(h, -1, sizeof h);



while (m -- )

&#123;

    int a, b;

    scanf(&quot;%d%d&quot;, &amp;a, &amp;b);

    add(a, b), add(b, a);// 无向图，a-&gt;b, b-&gt;a

&#125;



bool flag = true;

for (int i = 1; i &lt;= n; i ++ )

    if (!color[i])

    &#123;

        if (!dfs(i, 1))

        &#123;

            flag = false;

            break;

        &#125;

    &#125;



if (flag) puts(&quot;Yes&quot;);

else puts(&quot;No&quot;);



return 0;
</code></pre>
<p>}</p>
<h3 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h3><p>要了解匈牙利算法必须先理解下面的概念：</p>
<p>匹配：在图论中，一个「匹配」是一个边的集合，其中任意两条边都没有公共顶点。</p>
<p>最大匹配：一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配。</p>
<p>下面是一些补充概念：</p>
<p>完美匹配：如果一个图的某个匹配中，所有的顶点都是匹配点，那么它就是一个完美匹配。</p>
<p>交替路：从一个未匹配点出发，依次经过非匹配边、匹配边、非匹配边…形成的路径叫交替路。</p>
<p>增广路：从一个未匹配点出发，走交替路，如果途径另一个未匹配点（出发的点不算），则这条交替 路称为增广路（agumenting path）。</p>
<p>时间复杂度O(nm)，n表示点数，m表示边数</p>
<p>&#x2F;&#x2F;遍历自己喜欢的女孩int n1, n2;     &#x2F;&#x2F; n1表示第一个集合中的点数，n2表示第二个集合中的点数</p>
<p>int h[N], e[M], ne[M], idx;     &#x2F;&#x2F; 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边</p>
<p>int match[N];       &#x2F;&#x2F; 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个</p>
<p>bool st[N];     &#x2F;&#x2F; 表示第二个集合中的每个点是否已经被遍历过</p>
<p>void add(int a, int b)</p>
<p>{</p>
<pre><code>e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
</code></pre>
<p>}</p>
<p>bool find(int x)</p>
<p>{</p>
<pre><code>//遍历自己喜欢的女孩

for (int i = h[x]; i != -1; i = ne[i])

&#123;

    int j = e[i];

    if (!st[j])//如果在这一轮模拟匹配中,这个女孩尚未被预定

    &#123;

        st[j] = true;//那x就预定这个女孩了

        //如果女孩j没有男朋友，或者她原来的男朋友能够预定其它喜欢的女孩。配对成功

        if (match[j] == 0 || find(match[j]))

        &#123;

            match[j] = x;

            return true;

        &#125;

    &#125;

&#125;

//自己中意的全部都被预定了。配对失败。

return false;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点</p>
<p>int res &#x3D; 0;</p>
<p>for (int i &#x3D; 1; i &lt;&#x3D; n1; i ++ )</p>
<p>{</p>
<pre><code>memset(st, false, sizeof st);

if (find(i)) res ++ ;
</code></pre>
<p>}</p>
<p>应用：二分图的最大匹配</p>
<p>匈牙利算法图示化</p>
<p>相关题解：[AcWing 861. 二分图的最大匹配—-图解 - AcWing]：<a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/179030/">https://www.acwing.com/solution/content/179030/</a></p>
<p>using namespace std;</p>
<p>const int N &#x3D; 510, M &#x3D; 100010;</p>
<p>int n1, n2, m;</p>
<p>int h[N], e[M], ne[M], idx;</p>
<p>int match[N];</p>
<p>bool st[N];</p>
<p>void add(int a, int b)</p>
<p>{</p>
<pre><code>e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
</code></pre>
<p>}</p>
<p>bool find(int x)</p>
<p>{</p>
<pre><code> // 和各个点尝试能否匹配

for (int i = h[x]; i != -1; i = ne[i])

&#123;

    int j = e[i];

    if (!st[j])//打标记

    &#123;

        st[j] = true;

        // 当前尝试点没有被匹配或者和当前尝试点匹配的那个点可以换另一个匹配

        if (match[j] == 0 || find(match[j]))

        &#123;

            // 和当前尝试点匹配在一起

            match[j] = x;

            return true;

        &#125;

    &#125;

&#125;

return false;
</code></pre>
<p>}</p>
<p>int main()</p>
<p>{</p>
<pre><code>scanf(&quot;%d%d%d&quot;, &amp;n1, &amp;n2, &amp;m);



memset(h, -1, sizeof h);

// 保存图，因为只从一遍找另一边，所以该无向图只需要存储一个方向

while (m -- )

&#123;

    int a, b;

    scanf(&quot;%d%d&quot;, &amp;a, &amp;b);

    add(a, b);

&#125;



int res = 0;

//为各个点找匹配

for (int i = 1; i &lt;= n1; i ++ )

&#123;

    memset(st, false, sizeof st);

    //找到匹配

    if (find(i)) res ++ ;

&#125;



printf(&quot;%d\n&quot;, res);



return 0;
</code></pre>
<p>}</p>
<h2 id="四、数学知识"><a href="#四、数学知识" class="headerlink" title="四、数学知识"></a>四、数学知识</h2><p>算法的数学知识定理证明可以在这里查阅：[数学部分简介 - OI Wiki (oi-wiki.org)]：<a target="_blank" rel="noopener" href="https://oi-wiki.org/math/">https://oi-wiki.org/math/</a></p>
<h3 id="试除法判定质数"><a href="#试除法判定质数" class="headerlink" title="试除法判定质数"></a>试除法判定质数</h3><p>bool is_prime(int x)</p>
<p>{</p>
<pre><code>if (x &lt; 2) return false;

for (int i = 2; i &lt;= x / i; i ++ )

    if (x % i == 0)

        return false;

return true;
</code></pre>
<p>}</p>
<h3 id="试除法分解质因数"><a href="#试除法分解质因数" class="headerlink" title="试除法分解质因数"></a>试除法分解质因数</h3><p>void divide(int x)</p>
<p>{</p>
<pre><code>for (int i = 2; i &lt;= x / i; i ++ )

    if (x % i == 0)//i 一定是质数

    &#123;

        int s = 0;

        while (x % i == 0) x /= i, s ++ ;

        cout &lt;&lt; i &lt;&lt; &#39; &#39; &lt;&lt; s &lt;&lt; endl;

    &#125;

if (x &gt; 1) cout &lt;&lt; x &lt;&lt; &#39; &#39; &lt;&lt; 1 &lt;&lt; endl;

cout &lt;&lt; endl;
</code></pre>
<p>}</p>
<h3 id="埃氏筛法求质数"><a href="#埃氏筛法求质数" class="headerlink" title="埃氏筛法求质数"></a>埃氏筛法求质数</h3><p>int primes[N], cnt;     &#x2F;&#x2F; primes[]存储所有素数</p>
<p>bool st[N];         &#x2F;&#x2F; st[x]存储x是否被筛掉</p>
<p>void get_primes(int n)</p>
<p>{</p>
<pre><code>for (int i = 2; i &lt;= n; i ++ )

&#123;

    if (st[i]) continue;

    primes[cnt ++ ] = i;

    for (int j = i + i; j &lt;= n; j += i)

        st[j] = true;

&#125;
</code></pre>
<p>}</p>
<h3 id="线性筛法求质数"><a href="#线性筛法求质数" class="headerlink" title="线性筛法求质数"></a>线性筛法求质数</h3><p>算法动画讲解：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1LR4y1Z7pm">https://www.bilibili.com/video/BV1LR4y1Z7pm</a></p>
<p>int primes[N], cnt;     &#x2F;&#x2F; primes[]存储所有素数</p>
<p>bool st[N];         &#x2F;&#x2F; st[x]存储x是否被筛掉</p>
<p>void get_primes(int n)</p>
<p>{</p>
<pre><code>for (int i = 2; i &lt;= n; i ++ )

&#123;

    if (!st[i]) primes[cnt ++ ] = i;

    for (int j = 0; primes[j] &lt;= n / i; j ++ )

    &#123;

        st[primes[j] * i] = true;

        if (i % primes[j] == 0) break;

    &#125;

&#125;
</code></pre>
<p>}</p>
<h3 id="试除法求所有约数"><a href="#试除法求所有约数" class="headerlink" title="试除法求所有约数"></a>试除法求所有约数</h3><p>vector<int> get_divisors(int x)</p>
<p>{</p>
<pre><code>vector&lt;int&gt; res;

for (int i = 1; i &lt;= x / i; i ++ )

    if (x % i == 0)

    &#123;

        res.push_back(i);

        if (i != x / i) res.push_back(x / i);

    &#125;

sort(res.begin(), res.end());

return res;
</code></pre>
<p>}</p>
<h3 id="约数个数"><a href="#约数个数" class="headerlink" title="约数个数"></a>约数个数</h3><p><strong>约数个数定理和约数和定理公式推导</strong>：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV13R4y1o777">https://www.bilibili.com/video/BV13R4y1o777</a></p>
<p><strong>约数个数定理推导</strong>：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1NY41187GM">https://www.bilibili.com/video/BV1NY41187GM</a></p>
<p>约数个数.png</p>
<p>using namespace std;</p>
<p>typedef long long LL;</p>
<p>const int N &#x3D; 110, mod &#x3D; 1e9 + 7;</p>
<p>int main()</p>
<p>{</p>
<pre><code>int n;

cin &gt;&gt; n;

unordered_map&lt;int, int&gt; primes;

while (n -- )

&#123;

    int x;

    cin &gt;&gt; x;

    for (int i = 2; i &lt;= x / i; i ++ )

        while (x % i == 0)

        &#123;

            x /= i;

            primes[i] ++ ;

        &#125;

    if (x &gt; 1) primes[x] ++ ;

&#125;

LL res = 1;

for (auto p : primes) res = res * (p.second + 1) % mod;

cout &lt;&lt; res &lt;&lt; endl;

return 0;
</code></pre>
<p>}</p>
<h3 id="约数之和"><a href="#约数之和" class="headerlink" title="约数之和"></a>约数之和</h3><p><strong>约数个数定理和约数和定理公式推导</strong>：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV13R4y1o777">https://www.bilibili.com/video/BV13R4y1o777</a></p>
<p>约数之和.png</p>
<p>using namespace std;</p>
<p>typedef long long LL;</p>
<p>const int N &#x3D; 110, mod &#x3D; 1e9 + 7;</p>
<p>int main()</p>
<p>{</p>
<pre><code>int n;

cin &gt;&gt; n;

unordered_map&lt;int, int&gt; primes;

while (n -- )

&#123;

    int x;

    cin &gt;&gt; x;

    for (int i = 2; i &lt;= x / i; i ++ )

        while (x % i == 0)

        &#123;

            x /= i;

            primes[i] ++ ;

        &#125;

    if (x &gt; 1) primes[x] ++ ;

&#125;

LL res = 1;

for (auto p : primes)

&#123;

    LL a = p.first, b = p.second;

    LL t = 1;

    while (b -- ) t = (t * a + 1) % mod;//遍历b次后得到t=p^b+p^(b-1)+...+p+1

    res = res * t % mod;

&#125;

cout &lt;&lt; res &lt;&lt; endl;

return 0;
</code></pre>
<p>}</p>
<p>代码第26行解释：</p>
<p>约数之和小公式推导.png</p>
<h3 id="欧几里得算法-求最大公约数"><a href="#欧几里得算法-求最大公约数" class="headerlink" title="欧几里得算法(求最大公约数)"></a>欧几里得算法(求最大公约数)</h3><p>int gcd(int a, int b)</p>
<p>{</p>
<pre><code>return b ? gcd(b, a % b) : a;
</code></pre>
<p>}</p>
<h3 id="最小公倍数"><a href="#最小公倍数" class="headerlink" title="最小公倍数"></a>最小公倍数</h3><p>int lcm(int a, int b)</p>
<p>{</p>
<pre><code>return abs(a * b) / gcd(a, b);
</code></pre>
<p>}</p>
<h3 id="求欧拉函数"><a href="#求欧拉函数" class="headerlink" title="求欧拉函数"></a>求欧拉函数</h3><p>前置知识</p>
<p>互质：互质是公约数只有1的两个整数，叫做互质整数。</p>
<p>欧拉函数定义</p>
<p>1∼N−1</p>
<p>中与N互质的数的个数被称为欧拉函数，记为ϕ(N)。</p>
<p>若在算数基本定理中，N&#x3D;pa11pa22…pamm，则：</p>
<p>ϕ(N)&#x3D;N⋅p1−1p1⋅p2−1p2⋅…⋅pm−1pm</p>
<p>欧拉函数推导</p>
<p>首先我们要知道1,2,3…N−1,N与N互质的个数是1∼N数列去除N的质因子的倍数。</p>
<p>例如N&#x3D;10,即1,2,3,4,5,6,7,8,9,10去除N的质因子的倍数,</p>
<p>则1,\bcancel2,3,\bcancel4,\bcancel5,\bcancel6,7,\bcancel8,9,\bcancel10.</p>
<p>显然，1,3,7,9与10互质。</p>
<p>由上方结论使用容斥原理进行数学推导如下：</p>
<h4 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h4><p>int phi(int x)</p>
<p>{</p>
<pre><code>int res = x;

for (int i = 2; i &lt;= x / i; i ++ )

    if (x % i == 0)

    &#123;

        res = res / i * (i - 1);

        while (x % i == 0) x /= i;

    &#125;

if (x &gt; 1) res = res / x * (x - 1);



return res;
</code></pre>
<p>}</p>
<h3 id="线性筛法求欧拉函数"><a href="#线性筛法求欧拉函数" class="headerlink" title="线性筛法求欧拉函数"></a>线性筛法求欧拉函数</h3><p>int primes[N], cnt;     &#x2F;&#x2F; primes[]存储所有素数</p>
<p>int euler[N];           &#x2F;&#x2F; 存储每个数的欧拉函数</p>
<p>bool st[N];         &#x2F;&#x2F; st[x]存储x是否被筛掉</p>
<p>void get_eulers(int n)  &#x2F;&#x2F; 线性筛法求1~n的欧拉函数</p>
<p>{</p>
<pre><code>euler[1] = 1;

for (int i = 2; i &lt;= n; i ++ )

&#123;

    if (!st[i])

    &#123;

        primes[cnt ++ ] = i;

        euler[i] = i - 1;

    &#125;

    for (int j = 0; primes[j] &lt;= n / i; j ++ )

    &#123;

        int t = primes[j] * i;

        st[t] = true;

        if (i % primes[j] == 0)

        &#123;

            euler[t] = euler[i] * primes[j];

            break;

        &#125;

        euler[t] = euler[i] * (primes[j] - 1);

    &#125;

&#125;
</code></pre>
<p>}</p>
<h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><p>快速幂公式证明：[快速幂 - OI Wiki (oi-wiki.org)]：<a target="_blank" rel="noopener" href="https://oi-wiki.org/math/binary-exponentiation/">https://oi-wiki.org/math/binary-exponentiation/</a></p>
<p>&#x2F;&#x2F; 求 m^k mod p，时间复杂度 O(logk)。</p>
<p>&#x2F;&#x2F; m为底数，k为幂</p>
<p>int qmi(int m, int k, int p)</p>
<p>{</p>
<pre><code>int res = 1 % p, t = m;

while (k)

&#123;

    if (k&amp;1) res = res * t % p;

    t = t * t % p;

    k &gt;&gt;= 1;

&#125;

return res;
</code></pre>
<p>}</p>
<h3 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h3><p><strong>扩展欧几里得算法讲解：</strong><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1KU4y1a7E2/">https://www.bilibili.com/video/BV1KU4y1a7E2/</a></p>
<p><strong>优秀题解：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/1393">https://www.acwing.com/solution/content/1393</a></p>
<p><strong>优秀博客：</strong><a target="_blank" rel="noopener" href="https://blog.csdn.net/mango114514/article/details/121048335">https://blog.csdn.net/mango114514/article/details/121048335</a></p>
<p>x的第一个正解就是(x%k+k)%k</p>
<p>其中，k&#x3D;b&#x2F;gcd(a,b)</p>
<p>&#x2F;&#x2F; 求x, y，使得ax + by &#x3D; gcd(a, b)</p>
<p>int exgcd(int a, int b, int &amp;x, int &amp;y)</p>
<p>{</p>
<pre><code>if (!b)

&#123;

    x = 1, y = 0;

    return a;

&#125;

int d = exgcd(b, a % b, y, x);

y -= (a/b) * x;

return d;
</code></pre>
<p>}</p>
<h3 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h3><p><strong>中国剩余定理讲解：</strong><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1AN4y1N7Su/">https://www.bilibili.com/video/BV1AN4y1N7Su/</a></p>
<p>中国剩余定理.png</p>
<p>LL exgcd(LL a,LL b,LL &amp;x,LL &amp;y){</p>
<pre><code>if(b==0)&#123;

    x=1,y=0; 

    return a;

&#125;

LL d=exgcd(b,a%b,y,x);

y -= (a/b) * x;

return d;
</code></pre>
<p>}</p>
<p>LL CRT(LL m[],LL r[]){</p>
<pre><code>LL m=1,ans=0;

for(int i=1;i&lt;=n;i++)M*=m[i];

for(int i=1;i&lt;=n;i++)&#123;

    LL c=M/m[i],x,y;

    exgcd(c,m[i],x,y);

    ans=(ans+r[i]*c*x%M)%M;

&#125;

return (ans%M+M)%M;
</code></pre>
<p>}</p>
<h3 id="扩展中国剩余定理"><a href="#扩展中国剩余定理" class="headerlink" title="扩展中国剩余定理"></a>扩展中国剩余定理</h3><p><strong>扩展中国剩余定理讲解：</strong><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Ut4y1F7HG/">https://www.bilibili.com/video/BV1Ut4y1F7HG/</a></p>
<p>扩展中国剩余定理.png</p>
<p>LL exgcd(LL a,LL b,LL &amp;x,LL &amp;y){</p>
<pre><code>if(b==0)&#123;

    x=1,y=0; 

    return a;

&#125;

LL d=exgcd(b,a%b,y,x);

y -= (a/b) * x;

return d;
</code></pre>
<p>}</p>
<p>LL EXCRT(LL m[],LL r[]){</p>
<pre><code>LL m1,m2,r1,r2,p,q;

m1=m[1],r1=r[1];

for(int i=2;i&lt;=n;i++)&#123;

    m2=m[i],r2=r[i];

    LL d = exgcd(m1,m2,p,q);

    if((r2-r1)%d)&#123;

        return -1;

    &#125;

    p=p*(r2-r1)/d;//特解

    p=(p%(m2/d)+m2/d)%(m2/d);

    r1=m1*p+r1;

    m1=m1*m2/d;

&#125;

return (r1%m1+m1)%m1;
</code></pre>
<p>}</p>
<h3 id="高斯消元法"><a href="#高斯消元法" class="headerlink" title="高斯消元法"></a>高斯消元法</h3><p>高斯消元 O(n3)</p>
<p>求解例如下面方程组</p>
<p>⎧⎩⎨⎪⎪⎪⎪⎪⎪a11x1+a12x2+…+a1nxn&#x3D;b1a21x1+a22x2+…+a2nxn&#x3D;b2⋮⋮⋮⋮an1x1+an2x2+…+annxn&#x3D;bn</p>
<p><strong>高斯消元讲解：</strong><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Kd4y127vZ/">https://www.bilibili.com/video/BV1Kd4y127vZ/</a></p>
<h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><p>&#x2F;&#x2F; a[N][N]是增广矩阵</p>
<p>int gauss()</p>
<p>{</p>
<pre><code>int c, r;

for (c = 0, r = 0; c &lt; n; c ++ )

&#123;

    int t = r;

    for (int i = r; i &lt; n; i ++ )   // 找到绝对值最大的行

        if (fabs(a[i][c]) &gt; fabs(a[t][c]))

            t = i;



    if (fabs(a[t][c]) &lt; eps) continue;



    for (int i = c; i &lt;= n; i ++ ) swap(a[t][i], a[r][i]);      // 将绝对值最大的行换到最顶端

    for (int i = n; i &gt;= c; i -- ) a[r][i] /= a[r][c];      // 将当前行的首位变成1

    for (int i = r + 1; i &lt; n; i ++ )       // 用当前行将下面所有的列消成0

        if (fabs(a[i][c]) &gt; eps)

            for (int j = n; j &gt;= c; j -- )

                a[i][j] -= a[r][j] * a[i][c];



    r ++ ;

&#125;



if (r &lt; n)

&#123;

    for (int i = r; i &lt; n; i ++ )

        if (fabs(a[i][n]) &gt; eps)

            return 2; // 无解

    return 1; // 有无穷多组解

&#125;



for (int i = n - 1; i &gt;= 0; i -- )

    for (int j = i + 1; j &lt; n; j ++ )

        a[i][n] -= a[i][j] * a[j][n];



return 0; // 有唯一解
</code></pre>
<p>}</p>
<h4 id="应用-4"><a href="#应用-4" class="headerlink" title="应用"></a>应用</h4><p>using namespace std;</p>
<p>const int N &#x3D; 110;</p>
<p>const double eps &#x3D; 1e-6;</p>
<p>int n;</p>
<p>double a[N][N];</p>
<p>int gauss()</p>
<p>{</p>
<pre><code>int c, r;// c 代表 列 col ， r 代表 行 row

for (c = 0, r = 0; c &lt; n; c ++ )

&#123;

    int t = r;// 先找到当前这一列，绝对值最大的一个数字所在的行号

    for (int i = r; i &lt; n; i ++ )

        if (fabs(a[i][c]) &gt; fabs(a[t][c]))

            t = i;



    if (fabs(a[t][c]) &lt; eps) continue;// 如果当前这一列的最大数都是 0 ，那么所有数都是 0，就没必要去算了，因为它的约束方程，可能在上面几行



    for (int i = c; i &lt; n + 1; i ++ ) swap(a[t][i], a[r][i]);//// 把当前这一行，换到最上面（不是第一行，是第 r 行）去

    for (int i = n; i &gt;= c; i -- ) a[r][i] /= a[r][c];// 把当前这一行的第一个数，变成 1， 方程两边同时除以 第一个数，必须要到着算，不然第一个数直接变1，系数就被篡改，后面的数字没法算

    for (int i = r + 1; i &lt; n; i ++ )// 把当前列下面的所有数，全部消成 0

        if (fabs(a[i][c]) &gt; eps)// 如果非0 再操作，已经是 0就没必要操作了

            for (int j = n; j &gt;= c; j -- )// 从后往前，当前行的每个数字，都减去对应列 * 行首非0的数字，这样就能保证第一个数字是 a[i][0] -= 1*a[i][0];

                a[i][j] -= a[r][j] * a[i][c];



    r ++ ;// 这一行的工作做完，换下一行

&#125;



if (r &lt; n)// 说明剩下方程的个数是小于 n 的，说明不是唯一解，判断是无解还是无穷多解

&#123;// 因为已经是阶梯型，所以 r ~ n-1 的值应该都为 0

    for (int i = r; i &lt; n; i ++ )// 

        if (fabs(a[i][n]) &gt; eps)// a[i][n] 代表 b_i ,即 左边=0，右边=b_i,0 != b_i, 所以无解。

            return 2;

    return 1;// 否则， 0 = 0，就是r ~ n-1的方程都是多余方程

&#125;

// 唯一解 ↓，从下往上回代，得到方程的解

for (int i = n - 1; i &gt;= 0; i -- )

    for (int j = i + 1; j &lt; n; j ++ )

        a[i][n] -= a[j][n] * a[i][j];//因为只要得到解，所以只用对 b_i 进行操作，中间的值，可以不用操作，因为不用输出



return 0;
</code></pre>
<p>}</p>
<p>int main()</p>
<p>{</p>
<pre><code>cin &gt;&gt; n;

for (int i = 0; i &lt; n; i ++ )

    for (int j = 0; j &lt; n + 1; j ++ )

        cin &gt;&gt; a[i][j];



int t = gauss();



if (t == 0)

&#123;

    for (int i = 0; i &lt; n; i ++ ) printf(&quot;%.2lf\n&quot;, a[i][n]);

&#125;

else if (t == 1) puts(&quot;Infinite group solutions&quot;);

else puts(&quot;No solution&quot;);

return 0;
</code></pre>
<p>}</p>
<h3 id="求组合数"><a href="#求组合数" class="headerlink" title="求组合数"></a>求组合数</h3><h4 id="递推法求组合数"><a href="#递推法求组合数" class="headerlink" title="递推法求组合数"></a>递推法求组合数</h4><p><strong>排列组合详细讲解：</strong><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1e7411J7SC/">https://www.bilibili.com/video/BV1e7411J7SC/</a></p>
<p>杨辉三角.png</p>
<p>杨辉三角组合数.png</p>
<p>&#x2F;&#x2F; c[a][b] 表示从a个苹果中选b个的方案数</p>
<p>int c[N][N];</p>
<p>for (int i &#x3D; 0; i &lt; N; i ++ )</p>
<pre><code>for (int j = 0; j &lt;= i; j ++ )

    if (!j) c[i][j] = 1;

    else c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;
</code></pre>
<p>&#x2F;&#x2F;本质上杨辉三角</p>
<h4 id="通过预处理逆元的方式求组合数"><a href="#通过预处理逆元的方式求组合数" class="headerlink" title="通过预处理逆元的方式求组合数"></a>通过预处理逆元的方式求组合数</h4><h4 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h4><p>&#x2F;&#x2F; 首先预处理出所有阶乘取模的余数fact[N]，以及所有阶乘取模的逆元infact[N]</p>
<p>&#x2F;&#x2F; 如果取模的数是质数，可以用费马小定理求逆元</p>
<p>int qmi(int a, int k, int p)    &#x2F;&#x2F; 快速幂模板</p>
<p>{</p>
<pre><code>int res = 1;

while (k)

&#123;

    if (k &amp; 1) res = (LL)res * a % p;

    a = (LL)a * a % p;

    k &gt;&gt;= 1;

&#125;

return res;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; 预处理阶乘的余数和阶乘逆元的余数</p>
<p>fact[0] &#x3D; infact[0] &#x3D; 1;</p>
<p>for (int i &#x3D; 1; i &lt; N; i ++ )</p>
<p>{</p>
<pre><code>fact[i] = (LL)fact[i - 1] * i % mod;

infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
</code></pre>
<p>}</p>
<h4 id="应用-5"><a href="#应用-5" class="headerlink" title="应用"></a>应用</h4><p>using namespace std;</p>
<p>typedef long long LL;</p>
<p>const int N &#x3D; 100010,mod&#x3D;1e9+7;&#x2F;&#x2F;1e9+7是质数所以与[1,1e9+7)中的数互质</p>
<p>int fact[N],infact[N];</p>
<p>int qmi(int a,int k,int p){</p>
<pre><code>int res=1;

while(k)&#123;

    if(k&amp;1)res=(LL)res*a%p;

    a=(LL)a*a%p;

    k&gt;&gt;=1;

&#125;

return res;
</code></pre>
<p>}</p>
<p>int main()</p>
<p>{</p>
<pre><code>fact[0]=infact[0]=1;

for (int i = 1; i &lt;= N; i ++ )&#123;

    fact[i]=(LL)fact[i-1]*i%mod;

    infact[i]=(LL)infact[i-1]*qmi(i,mod-2,mod)%mod;

&#125;



int n;

scanf(&quot;%d&quot;,&amp;n);

while (n -- )&#123;

    int a,b;

    scanf(&quot;%d%d&quot;, &amp;a, &amp;b);

    printf(&quot;%d\n&quot;,(LL)fact[a]*infact[b]%mod*infact[a-b]%mod);

&#125;

return 0;
</code></pre>
<p>}</p>
<h3 id="Lucas定理求组合数"><a href="#Lucas定理求组合数" class="headerlink" title="Lucas定理求组合数"></a>Lucas定理求组合数</h3><p><strong>Lucas定理证明：</strong><a target="_blank" rel="noopener" href="https://blog.csdn.net/Qiuker_jl/article/details/109528164">https://blog.csdn.net/Qiuker_jl/article/details/109528164</a></p>
<h4 id="模板-2"><a href="#模板-2" class="headerlink" title="模板"></a>模板</h4><p>&#x2F;&#x2F; 若p是质数，则对于任意整数 1 &lt;&#x3D; m &lt;&#x3D; n，有：</p>
<p>&#x2F;&#x2F; C(n, m) &#x3D; C(n % p, m % p) * C(n &#x2F; p, m &#x2F; p) (mod p)</p>
<p>int qmi(int a, int k, int p)  &#x2F;&#x2F; 快速幂模板</p>
<p>{</p>
<pre><code>int res = 1 % p;

while (k)

&#123;

    if (k &amp; 1) res = (LL)res * a % p;

    a = (LL)a * a % p;

    k &gt;&gt;= 1;

&#125;

return res;
</code></pre>
<p>}</p>
<p>int C(int a, int b, int p)  &#x2F;&#x2F; 通过定理求组合数C(a, b)</p>
<p>{</p>
<pre><code>if (a &lt; b) return 0;



LL x = 1, y = 1;  // x是分子，y是分母

for (int i = a, j = 1; j &lt;= b; i --, j ++ )

&#123;

    x = (LL)x * i % p;

    y = (LL) y * j % p;

&#125;



return x * (LL)qmi(y, p - 2, p) % p;
</code></pre>
<p>}</p>
<p>int lucas(LL a, LL b, int p)</p>
<p>{</p>
<pre><code>if (a &lt; p &amp;&amp; b &lt; p) return C(a, b, p);

return (LL)C(a % p, b % p, p) * lucas(a / p, b / p, p) % p;
</code></pre>
<p>}</p>
<h4 id="应用-6"><a href="#应用-6" class="headerlink" title="应用"></a>应用</h4><p>using namespace std;</p>
<p>typedef long long LL;</p>
<p>int qmi(int a,int k,int p)</p>
<p>{</p>
<pre><code>int res = 1;

while(k)

&#123;

    if(k&amp;1)res = (LL)res*a%p;

    a = (LL)a*a%p;

    k&gt;&gt;=1;

&#125;

return res;
</code></pre>
<p>}</p>
<p>int C(int a,int b,int p)&#x2F;&#x2F;自变量类型int</p>
<p>{</p>
<pre><code>if(b&gt;a)return 0;//漏了边界条件

int res = 1;

// a!/(b!(a-b)!) = (a-b+1)*...*a / b! 分子有b项

for(int i=1,j=a;i&lt;=b;i++,j--)//i&lt;=b而不是&lt;

&#123;

    res = (LL)res*j%p;

    res = (LL)res*qmi(i,p-2,p)%p;

&#125;

return res;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F;对公式敲</p>
<p>int lucas(LL a,LL b,int p)</p>
<p>{</p>
<pre><code>if(a&lt;p &amp;&amp; b&lt;p)return C(a,b,p);//lucas递归终点是C_&#123;bk&#125;^&#123;ak&#125;

return (LL)C(a%p,b%p,p)*lucas(a/p,b/p,p)%p;//a%p后肯定是&lt;p的,所以可以用C(),但a/p后不一定&lt;p 所以用lucas继续递归
</code></pre>
<p>}</p>
<p>int main()</p>
<p>{</p>
<pre><code>int n;

cin &gt;&gt; n;

while(n--)

&#123;

    LL a,b;

    int p;

    cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;

    cout &lt;&lt; lucas(a,b,p) &lt;&lt; endl;

&#125;

return 0;
</code></pre>
<p>}</p>
<h3 id="分解质因数法求组合数"><a href="#分解质因数法求组合数" class="headerlink" title="分解质因数法求组合数"></a>分解质因数法求组合数</h3><h4 id="模板-3"><a href="#模板-3" class="headerlink" title="模板"></a>模板</h4><p>当我们需要求出组合数的真实值，而非对某个数的余数时，分解质因数的方式比较好用：</p>
<pre><code>1. 筛法求出范围内的所有质数

2. 通过 C(a, b) = a! / b! / (a - b)! 这个公式求出每个质因子的次数。 n! 中p的次数是 n / p + n / p^2 + n / p^3 + ...

3. 用高精度乘法将所有质因子相乘
</code></pre>
<p>int primes[N], cnt;     &#x2F;&#x2F; 存储所有质数</p>
<p>int sum[N];     &#x2F;&#x2F; 存储每个质数的次数</p>
<p>bool st[N];     &#x2F;&#x2F; 存储每个数是否已被筛掉</p>
<p>void get_primes(int n)      &#x2F;&#x2F; 线性筛法求素数</p>
<p>{</p>
<pre><code>for (int i = 2; i &lt;= n; i ++ )

&#123;

    if (!st[i]) primes[cnt ++ ] = i;

    for (int j = 0; primes[j] &lt;= n / i; j ++ )

    &#123;

        st[primes[j] * i] = true;

        if (i % primes[j] == 0) break;

    &#125;

&#125;
</code></pre>
<p>}</p>
<p>int get(int n, int p)       &#x2F;&#x2F; 求n！中的次数</p>
<p>{</p>
<pre><code>int res = 0;

while (n)

&#123;

    res += n / p;

    n /= p;

&#125;

return res;
</code></pre>
<p>}</p>
<p>vector<int> mul(vector<int> a, int b)       &#x2F;&#x2F; 高精度乘低精度模板</p>
<p>{</p>
<pre><code>vector&lt;int&gt; c;

int t = 0;

for (int i = 0; i &lt; a.size(); i ++ )

&#123;

    t += a[i] * b;

    c.push_back(t % 10);

    t /= 10;

&#125;



while (t)

&#123;

    c.push_back(t % 10);

    t /= 10;

&#125;



return c;
</code></pre>
<p>}</p>
<p>get_primes(a);  &#x2F;&#x2F; 预处理范围内的所有质数</p>
<p>for (int i &#x3D; 0; i &lt; cnt; i ++ )     &#x2F;&#x2F; 求每个质因数的次数</p>
<p>{</p>
<pre><code>int p = primes[i];

sum[i] = get(a, p) - get(b, p) - get(a - b, p);
</code></pre>
<p>}</p>
<p>vector<int> res;</p>
<p>res.push_back(1);</p>
<p>for (int i &#x3D; 0; i &lt; cnt; i ++ )     &#x2F;&#x2F; 用高精度乘法将所有质因子相乘</p>
<pre><code>for (int j = 0; j &lt; sum[i]; j ++ )

    res = mul(res, primes[i]);
</code></pre>
<h4 id="应用-7"><a href="#应用-7" class="headerlink" title="应用"></a>应用</h4><p>using namespace std;</p>
<p>const int N &#x3D; 5010;</p>
<p>int primes[N],cnt&#x3D;0;</p>
<p>&#x2F;&#x2F; v[i] 记录数字 i 为素数还是合数，v[i]&#x3D;true时 i 为合数，否则 i 为素数</p>
<p>bool v[N];</p>
<p>&#x2F;&#x2F; sum[i]&#x3D;c 表示质数 i 的个数为 c</p>
<p>int sum[N];</p>
<p>&#x2F;&#x2F; 线性筛法</p>
<p>void get_primes(int n)</p>
<p>{</p>
<pre><code>for(int i=2;i&lt;=n;++i)

&#123;

    // i为质数，则存在primes中

    if(!v[i])primes[cnt++]=i;

    // 给当前数i乘上一个质因子pj

    for(int j=0;primes[j]&lt;=n/i;++j)

    &#123;

        v[primes[j]*i]=true;

        if(i%primes[j]==0)break;

    &#125;

&#125;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; 计算 n 里面含有质数 p 的个数，这里的计算是不重不漏的。</p>
<p>&#x2F;&#x2F; p^k的倍数会被计算k次：第一次算p的倍数时，被加一次；第二次算p^2的倍数时，被加一次；第三次算p^3的倍数时，被加一次…第k次算p^k的倍数时，被加一次。总共被加了k次，是不重不漏的。</p>
<p>int get(int n,int p)</p>
<p>{</p>
<pre><code>int res=0;

while(n)

&#123;

    res+=n/p;

    n/=p;

&#125;

return res;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; A * b：把 b 看成一个整体，然后与 A 中每一位相乘，A中的数字采用小端存储，即低位数字存储在数组的前面，高位数字存储在数组的后面</p>
<p>vector<int> mul(const vector<int>&amp; A,const int b)</p>
<p>{</p>
<pre><code>if(b==0)return &#123;0&#125;;

vector&lt;int&gt; res;

// t 表示乘法进位，这里的进位不限于0 1，可以为任意数字

for(int i=0,t=0,n=A.size();i&lt;n||t&gt;0;++i)

&#123;

    // 获得当前位的乘积和

    if(i&lt;n)t+=A[i]*b;

    // 添加个位数字

    res.push_back(t%10);

    // 保留进位

    t/=10;

&#125;



 // 如 1234 * 0 = 0000，需要删除前导0

while(res.size()&gt;1&amp;&amp;res.back()==0)res.pop_back();

return res;
</code></pre>
<p>}</p>
<p>int main()</p>
<p>{</p>
<pre><code>int a,b;cin&gt;&gt;a&gt;&gt;b;



// 将 a 分解质因数

get_primes(a);



for(int i=0;i&lt;cnt;++i)

&#123;

    // 当前的质数为 p

    int p=primes[i];

    // 用分子里面 p 的个数减去分母里面 p 的个数。这里的计算组合数的公式为a!/(b!*(a-b)!)，因此用 a 里面 p 的个数减去 b 里面 p 的个数和 (a-b) 里面 p 的个数。

    sum[i]=get(a,p)-get(b,p)-get(a-b,p);

&#125;



// 使用高精度乘法把所有质因子乘到一块去就好了

vector&lt;int&gt; res=&#123;1&#125;;

for(int i=0;i&lt;cnt;++i)

    // res*p^k，这里是k个p相乘，不是k*p，所以需要使用一个循环

    for(int j=0;j&lt;sum[i];++j)

        res=mul(res,primes[i]);



// 倒序打印 res 即可，由于采用小端存储，所以高位在后，从后往前打印即可

for(int i=res.size()-1;i&gt;=0;i--)printf(&quot;%d&quot;,res[i]);

return 0;
</code></pre>
<p>}</p>
<h3 id="容斥原理应用"><a href="#容斥原理应用" class="headerlink" title="容斥原理应用"></a>容斥原理应用</h3><p>经典例题：[890. 能被整除的数 - AcWing题库]：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/892/">https://www.acwing.com/problem/content/892/</a></p>
<p>AC代码：</p>
<p> using namespace std;</p>
<p> typedef long long LL;</p>
<p> const int N &#x3D; 20;</p>
<p> int p[N], n, m;</p>
<p> int main() {</p>
<p> cin &gt;&gt; n &gt;&gt; m;</p>
<p> for(int i &#x3D; 0; i &lt; m; i++) cin &gt;&gt; p[i];</p>
<p> int res &#x3D; 0;</p>
<p> &#x2F;&#x2F;枚举从1 到 1111…(m个1)的每一个集合状态, (至少选中一个集合)</p>
<p> for(int i &#x3D; 1; i &lt; 1 &lt;&lt; m; i++) {</p>
<p>   int t &#x3D; 1;             &#x2F;&#x2F;选中集合对应质数的乘积</p>
<p>   int s &#x3D; 0;             &#x2F;&#x2F;选中的集合数量</p>
<p>   &#x2F;&#x2F;枚举当前状态的每一位</p>
<p>   for(int j &#x3D; 0; j &lt; m; j++){</p>
<pre><code>   //选中一个集合

   if(i &gt;&gt; j &amp; 1)&#123;

       //乘积大于n, 则n/t = 0, 跳出这轮循环

       if((LL)t * p[j] &gt; n)&#123;    

           t = -1;

           break;

       &#125;

       s++;                  //有一个1，集合数量+1

       t *= p[j];

   &#125;
</code></pre>
<p>   }</p>
<p>   if(t &#x3D;&#x3D; -1) continue;  </p>
<p>   if(s &amp; 1) res +&#x3D; n &#x2F; t;              &#x2F;&#x2F;选中奇数个集合, 则系数应该是1, n&#x2F;t为当前这种状态的集合数量</p>
<p>   else res -&#x3D; n &#x2F; t;                      &#x2F;&#x2F;反之则为 -1</p>
<p> }</p>
<p> cout &lt;&lt; res &lt;&lt; endl;</p>
<p> return 0;</p>
<p> }</p>
<p>详细题解：[AcWing 890. 能被整除的数 - AcWing]：<a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/29702/">https://www.acwing.com/solution/content/29702/</a></p>
<h3 id="博弈论"><a href="#博弈论" class="headerlink" title="博弈论"></a>博弈论</h3><h4 id="NIM游戏"><a href="#NIM游戏" class="headerlink" title="NIM游戏"></a>NIM游戏</h4><p>定理1：必胜态的后继状态至少存在一个必败态</p>
<p>定理2：必败态的后继状态均为必胜态</p>
<p><strong>NIM游戏科普：</strong>[尼姆游戏（学霸就是这样欺负人的）_哔哩哔哩_bilibili]：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1ek4y1q7JD/">https://www.bilibili.com/video/BV1ek4y1q7JD/</a></p>
<p>[再看nim游戏_哔哩哔哩_bilibili]：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1nt4y1C7Sk/">https://www.bilibili.com/video/BV1nt4y1C7Sk/</a></p>
<p>经典例题：[P2197 【模板】nim 游戏 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)]：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2197">https://www.luogu.com.cn/problem/P2197</a></p>
<p>AC代码：</p>
<p> using namespace std;</p>
<p> int T;</p>
<p> int main() {</p>
<pre><code> cin &gt;&gt; T;

 while (T--) &#123;

     int n;

     scanf(&quot;%d&quot;, &amp;n);

     int ans = 0;

     for (int i = 0; i &lt; n; i++) &#123;

         int k;

         scanf(&quot;%d&quot;, &amp;k);

         ans ^= k;

     &#125;

     if (ans)

         puts(&quot;Yes&quot;);

     else

         puts(&quot;No&quot;);

 &#125;

 return 0;
</code></pre>
<p> }</p>
<p>结论：</p>
<p>若初态为必胜态(a1⊕a2⊕…⊕an≠0</p>
<p>).则先手必胜</p>
<p>若初态为必败态(a1⊕a2⊕…⊕an&#x3D;0</p>
<p>).则先手必败</p>
<p>视频讲解：[581 尼姆（Nim）游戏【博弈论】_哔哩哔哩_bilibili]：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1ns4y1D7dg/">https://www.bilibili.com/video/BV1ns4y1D7dg/</a></p>
<p>台阶型NIM游戏</p>
<p>经典例题：[892. 台阶-Nim游戏 - AcWing题库]：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/894/">https://www.acwing.com/problem/content/894/</a></p>
<p>AC代码：</p>
<p> using namespace std;</p>
<p> const int N &#x3D; 100010;</p>
<p> int main()</p>
<p> {</p>
<pre><code>  int n;

  scanf(&quot;%d&quot;, &amp;n);
</code></pre>
<p>   int res &#x3D; 0;</p>
<pre><code>  for (int i = 1; i &lt;= n; i ++ )

  &#123;

      int x;

      scanf(&quot;%d&quot;, &amp;x);

      if (i &amp; 1) res ^= x;

  &#125;

  if (res) puts(&quot;Yes&quot;);
</code></pre>
<p>   else puts(“No”);</p>
<pre><code>  return 0;
</code></pre>
<p> }</p>
<p>结论：若奇数台阶上的a1⊕a3⊕a5⊕…≠0，则先手必胜，反之先手必败。</p>
<p>视频讲解：[582 台阶型 Nim游戏【博弈论】_哔哩哔哩_bilibili]：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV18M411M7TC/">https://www.bilibili.com/video/BV18M411M7TC/</a></p>
<p>集合型NIM游戏</p>
<p>经典例题：[893. 集合-Nim游戏 - AcWing题库]：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/895/">https://www.acwing.com/problem/content/895/</a></p>
<p>AC代码：</p>
<p> using namespace std;</p>
<p> const int N&#x3D;110,M&#x3D;10010;</p>
<p> int n,m;</p>
<p> int f[M],s[N];&#x2F;&#x2F;s存储的是可供选择的集合,f存储的是所有可能出现过的情况的sg值</p>
<p> int sg(int x)</p>
<p> {</p>
<pre><code>  if(f[x]!=-1) return f[x];

  //因为取石子数目的集合是已经确定了的,所以每个数的sg值也都是确定的,如果存储过了,直接返回即可

  unordered_set&lt;int&gt; S;

  //set代表的是有序集合(注:因为在函数内部定义,所以下一次递归中的S不与本次相同)

  for(int i=0;i&lt;m;i++)

  &#123;

      int sum=s[i];

      if(x&gt;=sum) S.insert(sg(x-sum));

      //先延伸到终点的sg值后,再从后往前排查出所有数的sg值

  &#125;

  for(int i=0;;i++)

  //循环完之后可以进行选出最小的没有出现的自然数的操作

   if(!S.count(i))

    return f[x]=i;
</code></pre>
<p> }</p>
<p> int main()</p>
<p> {</p>
<pre><code>  cin&gt;&gt;m;

  for(int i=0;i&lt;m;i++)

  cin&gt;&gt;s[i];



  cin&gt;&gt;n;

  memset(f,-1,sizeof(f));//初始化f均为-1,方便在sg函数中查看x是否被记录过



  int res=0;

  for(int i=0;i&lt;n;i++)

  &#123;

      int x;

      cin&gt;&gt;x;

      res^=sg(x);

      //观察异或值的变化,基本原理与Nim游戏相同

  &#125;



  if(res) printf(&quot;Yes&quot;);

  else printf(&quot;No&quot;);



  return 0;
</code></pre>
<p> }</p>
<p>思路：转换成有向图游戏</p>
<p>视频讲解：[583 有向图游戏 SG函数【博弈论】_哔哩哔哩_bilibili]：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1eT411B7A8/">https://www.bilibili.com/video/BV1eT411B7A8/</a></p>
<h2 id="五、动态规划"><a href="#五、动态规划" class="headerlink" title="五、动态规划"></a>五、动态规划</h2><p>动态规划三大特征：最优子结构、无后效性、重复子问题</p>
<p>闫式dp分析法.jpg</p>
<h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><p>01背包每件物品只能装一次</p>
<p>完全背包每件物品可以装无限次</p>
<p>多重背包每件物品只能装有限次（多次）</p>
<p>分组背包每组只能选择一件物品装入（01背包升级）</p>
<p>相关链接：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/166439661">https://zhuanlan.zhihu.com/p/166439661</a></p>
<p>01背包问题</p>
<p>01背包每件物品只能装一次</p>
<p>视频讲解：[408 背包DP【模板】01背包_哔哩哔哩_bilibili]：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1kp4y1e794/">https://www.bilibili.com/video/BV1kp4y1e794/</a></p>
<p>01背包DP分析.png</p>
<p>01背包.png</p>
<p>using namespace std;</p>
<p>const int N&#x3D;1010;</p>
<p>int n,m;</p>
<p>int v[N],w[N];&#x2F;&#x2F;v代表体积，w代表价值</p>
<p>int f[N][N];</p>
<p>int main(){</p>
<pre><code>cin&gt;&gt;n&gt;&gt;m;

for(int i=1;i&lt;=n;i++)cin&gt;&gt;v[i]&gt;&gt;w[i];

for(int i=1;i&lt;=n;i++)//i代表这n件物品

&#123;

    for(int j=1;j&lt;=m;j++)&#123;//j代表背包容量

        if(v[i]&gt;j)//如果v[i]的容量大于当前的背包容量则不装进行下一个

            f[i][j]=f[i-1][j];

        else f[i][j]=max(f[i-1][j],f[i-1][j-v[i]]+w[i]);//如果v[i]的容量小于当前背包容量则可以选择装与不装得到最大值 

    &#125;

&#125;



cout&lt;&lt;f[n][m]&lt;&lt;endl;//输出最后的一个一定是最大的

return 0;
</code></pre>
<p>}</p>
<p>01背包，使用滚动数组，倒序遍历</p>
<p>using namespace std;</p>
<p>const int N&#x3D;1010;</p>
<p>int n,m;</p>
<p>int v[N],w[N];&#x2F;&#x2F;v代表体积，w代表价值</p>
<p>int dp[N];</p>
<p>int main(){</p>
<pre><code>cin&gt;&gt;n&gt;&gt;m;

for(int i=1;i&lt;=n;i++)//i代表这n件物品

&#123;

    cin&gt;&gt;v[i]&gt;&gt;w[i];//在线算法

    for(int j=m;j&gt;=v[i];j--)&#123;//j代表背包容量，滚动数组必须倒序遍历

        dp[j]=max(dp[j],dp[j-v[i]]+w[i]);//滚动数组

    &#125;

&#125;

cout&lt;&lt;dp[m]&lt;&lt;endl;//输出最后的一个一定是最大的

return 0;
</code></pre>
<p>}</p>
<p>状态转移方程：dp[j]&#x3D;max(dp[j],dp[j-v[i]]+w[i]);</p>
<h4 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h4><p>完全背包每件物品可以装无限次</p>
<p>视频讲解：[409 背包DP 完全背包【动态规划】_哔哩哔哩_bilibili]：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV15v411y7Qz/">https://www.bilibili.com/video/BV15v411y7Qz/</a></p>
<p>using namespace std;</p>
<p>int v[N],w[N];</p>
<p>int dp[N];</p>
<p>int main(){</p>
<pre><code>int n,m;

cin&gt;&gt;n&gt;&gt;m;

for(int i=1;i&lt;=n;i++)&#123;//遍历物品

    cin&gt;&gt;v[i]&gt;&gt;w[i];//在线算法

    for(int j=v[i];j&lt;=m;j++)&#123;//正序遍历背包容量

        dp[j]=max(dp[j],dp[j-v[i]]+w[i]);//滚动数组

    &#125;

&#125;

cout&lt;&lt;dp[m]&lt;&lt;endl;//输出答案

return 0;
</code></pre>
<p>}</p>
<p>完全背包问题和01背包优化版的区别在于第二重循环的v[i]和m做交换</p>
<p>状态转移方程：dp[j]&#x3D;max(dp[j],dp[j-v[i]]+w[i]);</p>
<h4 id="多重背包问题1"><a href="#多重背包问题1" class="headerlink" title="多重背包问题1"></a>多重背包问题1</h4><p>多重背包每件物品只能装有限次（多次）</p>
<p>using namespace std;</p>
<p>int n,m;</p>
<p>int v[N],w[N],s[N];</p>
<p>int dp[N][N];</p>
<p>int main(){</p>
<pre><code>cin&gt;&gt;n&gt;&gt;m;

for(int i=1;i&lt;=n;i++)cin&gt;&gt;v[i]&gt;&gt;w[i]&gt;&gt;s[i];

for(int i=1;i&lt;=n;i++)//物品

    for(int j=0;j&lt;=m;j++)//背包容量

        for(int k=0;k&lt;=s[i]&amp;&amp;k*v[i]&lt;=j;k++)

            dp[i][j]=max(dp[i][j],dp[i-1][j-v[i]*k]+w[i]*k);

cout&lt;&lt;dp[n][m]&lt;&lt;endl;

return 0;
</code></pre>
<p>}</p>
<p>状态转移方程：dp[i][j]&#x3D;max(dp[i][j],dp[i-1][j-v[i]*k]+w[i]*k);k为第i个物品的个数</p>
<h4 id="多重背包问题2-二进制优化"><a href="#多重背包问题2-二进制优化" class="headerlink" title="多重背包问题2(二进制优化)"></a>多重背包问题2(二进制优化)</h4><p>思路：转换成2进制，再用01背包求解</p>
<p>视频讲解：[410 背包DP 多重背包 二进制优化【动态规划】_哔哩哔哩_bilibili]：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1MA41177cg/">https://www.bilibili.com/video/BV1MA41177cg/</a></p>
<p>using namespace std;</p>
<p>const int N &#x3D; 12010, M &#x3D; 2010;</p>
<p>int n, m;</p>
<p>int v[N], w[N];</p>
<p>int f[M];</p>
<p>int main()</p>
<p>{</p>
<pre><code>cin &gt;&gt; n &gt;&gt; m;



int cnt = 0;

for (int i = 1; i &lt;= n; i ++ )

&#123;

    int a, b, s;

    cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;

    int k = 1;

    while (k &lt;= s)

    &#123;

        cnt ++ ;

        v[cnt] = a * k;

        w[cnt] = b * k;

        s -= k;

        k *= 2;

    &#125;

    if (s &gt; 0)

    &#123;

        cnt ++ ;

        v[cnt] = a * s;

        w[cnt] = b * s;

    &#125;

&#125;//二进制优化操作



n = cnt;



for (int i = 1; i &lt;= n; i ++ )

    for (int j = m; j &gt;= v[i]; j -- )

        f[j] = max(f[j], f[j - v[i]] + w[i]);



cout &lt;&lt; f[m] &lt;&lt; endl;



return 0;
</code></pre>
<p>}</p>
<h4 id="分组背包问题"><a href="#分组背包问题" class="headerlink" title="分组背包问题"></a>分组背包问题</h4><p>分组背包每组只能选择一件物品装入</p>
<p>视频讲解：[416 背包DP 分组背包【动态规划】_哔哩哔哩_bilibili]：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV16a411w77X/">https://www.bilibili.com/video/BV16a411w77X/</a></p>
<p>using namespace std;</p>
<p>const int N&#x3D;110;</p>
<p>int f[N];</p>
<p>int v[N][N],w[N][N],s[N];</p>
<p>int n,m,k;</p>
<p>int main(){</p>
<pre><code>cin&gt;&gt;n&gt;&gt;m;

for(int i=0;i&lt;n;i++)&#123;

    cin&gt;&gt;s[i];

    for(int j=0;j&lt;s[i];j++)&#123;

        cin&gt;&gt;v[i][j]&gt;&gt;w[i][j];

    &#125;

&#125;



for(int i=0;i&lt;n;i++)&#123;

    for(int j=m;j&gt;=0;j--)&#123;

        for(int k=0;k&lt;s[i];k++)&#123;    //for(int k=s[i];k&gt;=1;k--)也可以

            if(j&gt;=v[i][k])

                f[j]=max(f[j],f[j-v[i][k]]+w[i][k]);  

        &#125;

    &#125;

&#125;

cout&lt;&lt;f[m]&lt;&lt;endl;
</code></pre>
<p>}</p>
<p>状态转移方程：f[j]&#x3D;max(f[j],f[j-v[i][k]]+w[i][k]);</p>
<p>线性DP</p>
<p>数字三角形</p>
<p>视频讲解：[402 线性DP 数字三角形【动态规划】_哔哩哔哩_bilibili]：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Rk4y1173p/">https://www.bilibili.com/video/BV1Rk4y1173p/</a></p>
<p>数字三角形DP分析.png</p>
<p>using namespace std;</p>
<p>const int N&#x3D;510,INF&#x3D;1e9;</p>
<p>int n;</p>
<p>int a[N][N];</p>
<p>int f[N][N];</p>
<p>int main(){</p>
<pre><code>scanf(&quot;%d&quot;,&amp;n);

for(int i=1;i&lt;=n;i++)&#123;

    for(int j=1;j&lt;=i;j++)&#123;

        scanf(&quot;%d&quot;,&amp;a[i][j]);

    &#125;

&#125;

for(int i=0;i&lt;=n;i++)&#123;

    for(int j=0;j&lt;=i+1;j++)&#123;

        f[i][j]=-INF;

    &#125;

&#125;

f[1][1]=a[1][1];

for(int i=2;i&lt;=n;i++)

    for(int j=1;j&lt;=i;j++)

        f[i][j]=max(f[i-1][j-1]+a[i][j],f[i-1][j]+a[i][j]);//状态转移方程

int res=-INF;

for(int i=1;i&lt;=n;i++)res=max(res,f[n][i]);

printf(&quot;%d&quot;,res);

return 0;
</code></pre>
<p>}</p>
<p>状态转移方程：f[i][j]&#x3D;max(f[i-1][j-1]+a[i][j],f[i-1][j]+a[i][j]);</p>
<h3 id="最长上升子序列1"><a href="#最长上升子序列1" class="headerlink" title="最长上升子序列1"></a>最长上升子序列1</h3><p>视频讲解：[403 线性DP 最长上升子序列【动态规划】_哔哩哔哩_bilibili]：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1KK4y1e7t7/">https://www.bilibili.com/video/BV1KK4y1e7t7/</a></p>
<p>using namespace std;</p>
<p>const int N &#x3D; 1010;</p>
<p>int n;</p>
<p>int a[N],f[N];</p>
<p>int main()</p>
<p>{</p>
<pre><code>scanf(&quot;%d&quot;, &amp;n);

for (int i = 1; i &lt;= n; i ++ )scanf(&quot;%d&quot;,&amp;a[i]);

for (int i = 1; i &lt;= n; i ++ )&#123;

    f[i]=1;//只有a[i]一个数

    for (int j = 1; j &lt;= i; j ++ )

        if(a[j]&lt;a[i])

            f[i]=max(f[i],f[j]+1);

&#125;

int res=0;

for (int i = 1; i &lt;= n; i ++ )res=max(res,f[i]);

printf(&quot;%d\n&quot;,res);

return 0;
</code></pre>
<p>}</p>
<p>状态转移方程：if(a[j]&lt;a[i])f[i]&#x3D;max(f[i],f[j]+1);</p>
<h4 id="最长上升子序列2-二分优化"><a href="#最长上升子序列2-二分优化" class="headerlink" title="最长上升子序列2(二分优化)"></a>最长上升子序列2(二分优化)</h4><p>视频讲解：[404 线性DP 最长上升子序列 二分优化_哔哩哔哩_bilibili]：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Kp4y1e77H/">https://www.bilibili.com/video/BV1Kp4y1e77H/</a></p>
<p>using namespace std;</p>
<p>const int N &#x3D; 100010;</p>
<p>int n;</p>
<p>int a[N];</p>
<p>int q[N];</p>
<p>int main()</p>
<p>{</p>
<pre><code>scanf(&quot;%d&quot;, &amp;n);

for (int i = 0; i &lt; n; i ++ ) scanf(&quot;%d&quot;, &amp;a[i]);



int len = 0;

for (int i = 0; i &lt; n; i ++ )

&#123;

    int l = 0, r = len;

    while (l &lt; r)

    &#123;

        int mid = l + r + 1 &gt;&gt; 1;

        if (q[mid] &lt; a[i]) l = mid;

        else r = mid - 1;

    &#125;

    len = max(len, r + 1);

    q[r + 1] = a[i];//替换或添加

&#125;



printf(&quot;%d\n&quot;, len);



return 0;
</code></pre>
<p>}</p>
<h4 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h4><p>视频讲解：[405 线性DP 最长公共子序列【动态规划】_哔哩哔哩_bilibili]：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1EK411K7Eb/">https://www.bilibili.com/video/BV1EK411K7Eb/</a></p>
<p>using namespace std;</p>
<p>const int N&#x3D;1010;</p>
<p>int n,m;</p>
<p>char a[N],b[N];</p>
<p>int f[N][N];</p>
<p>int main()</p>
<p>{</p>
<pre><code>cin&gt;&gt;n&gt;&gt;m&gt;&gt;a+1&gt;&gt;b+1;

for (int i = 1; i &lt;= n; i ++ )&#123;

    for (int j = 1; j &lt;= m; j ++ )&#123;

        f[i][j]=max(f[i-1][j],f[i][j-1]);

        if(a[i]==b[j])f[i][j]=max(f[i][j],f[i-1][j-1]+1);

    &#125;

&#125;

cout&lt;&lt;f[n][m]&lt;&lt;endl;

return 0;
</code></pre>
<p>}</p>
<p>状态转移方程：</p>
<p>f[i][j]&#x3D;max(f[i-1][j],f[i][j-1]);</p>
<p>if(a[i]&#x3D;&#x3D;b[j])f[i][j]&#x3D;max(f[i][j],f[i-1][j-1]+1);</p>
<h4 id="最短编辑距离"><a href="#最短编辑距离" class="headerlink" title="最短编辑距离"></a>最短编辑距离</h4><p>给定两个字符串 A和 B，现在要将 A 经过若干操作变为 B，可进行的操作有：</p>
<p>删除–将字符串 A中的某个字符删除。</p>
<p>插入–在字符串 A 的某个位置插入某个字符。</p>
<p>替换–将字符串 A中的某个字符替换为另一个字符。</p>
<p>现在请你求出，将 A变为 B 至少需要进行多少次操作。</p>
<p>视频讲解：[407 线性DP 编辑距离【动态规划】_哔哩哔哩_bilibili]：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1gk4y1177j/">https://www.bilibili.com/video/BV1gk4y1177j/</a></p>
<p>闫氏DP分析法【最短编辑距离】.png</p>
<p>using namespace std;</p>
<p>const int N &#x3D; 1010;</p>
<p>int n,m;</p>
<p>char a[N],b[N];</p>
<p>int f[N][N];</p>
<p>int main()</p>
<p>{</p>
<pre><code>scanf(&quot;%d%s&quot;, &amp;n, a+1);

scanf(&quot;%d%s&quot;, &amp;m, b+1);



for (int i = 0; i &lt;= m; i ++ )f[0][i]=i;

for (int i = 0; i &lt;= n; i ++ )f[i][0]=i;//初始化字符串的编辑操作

for (int i = 1; i &lt;= n; i ++ )&#123;

    for (int j = 1; j &lt;= m; j ++ )&#123;

        f[i][j]=min(f[i-1][j]+1,f[i][j-1]+1);

        if(a[i]==b[j])f[i][j]=min(f[i][j],f[i-1][j-1]);

        else f[i][j]=min(f[i][j],f[i-1][j-1]+1);//状态转移方程

    &#125;

&#125;

printf(&quot;%d\n&quot;,f[n][m]);

return 0;
</code></pre>
<p>}</p>
<p>状态转移方程:</p>
<p>f[i][j]&#x3D;min(f[i-1][j]+1,f[i][j-1]+1);</p>
<p>if(a[i]&#x3D;&#x3D;b[j])f[i][j]&#x3D;min(f[i][j],f[i-1][j-1]);</p>
<p>else f[i][j]&#x3D;min(f[i][j],f[i-1][j-1]+1);&#x2F;&#x2F;状态转移方程</p>
<h3 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h3><h4 id="石子合并"><a href="#石子合并" class="headerlink" title="石子合并"></a>石子合并</h4><p>每堆石子有一定的质量，可以用一个整数来描述，现在要将这 N堆石子合并成为一堆。</p>
<p>每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同。</p>
<p>视频讲解：[428 区间DP【模板】石子合并_哔哩哔哩_bilibili]：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1gz4y1y7Rv/">https://www.bilibili.com/video/BV1gz4y1y7Rv/</a></p>
<p>闫氏DP分析法</p>
<p>using namespace std;</p>
<p>const int N &#x3D; 310;</p>
<p>int n;</p>
<p>int s[N];</p>
<p>int f[N][N];&#x2F;&#x2F;状态表示：集合f[l][r]为[l,r]区间；属性：所堆成的最小值</p>
<p>int main()</p>
<p>{</p>
<pre><code>scanf(&quot;%d&quot;, &amp;n);

for (int i = 1; i &lt;= n; i ++ )scanf(&quot;%d&quot;,&amp;s[i]);

for (int i = 1; i &lt;= n; i ++ )s[i]+=s[i-1];//前缀和用来求一段区间的和



for (int len = 2; len &lt;= n; len ++ )//区间长度为len//枚举长度

    for (int i = 1; i+len-1 &lt;= n; i ++ )&#123;//意思就是i在区间[1,n-len+1]中去//枚举区间

        int l=i,r=i+len-1;//区间在[i,i+len-1]中间长度为len//设置l和r的区间

        f[l][r]=1e9;//初始化最大值

        for (int k = l; k &lt; r; k ++ )//枚举分界点//不取r

            f[l][r]=min(f[l][r],f[l][k]+f[k+1][r]+s[r]-s[l-1]);//找到最小值状态转移方程为f[l][k]+f[k+1][r]+s[r]-s[l-1];

    &#125;

printf(&quot;%d\n&quot;,f[1][n]);//输出区间[1,n]的最小值

return 0;
</code></pre>
<p>}</p>
<p>状态转移方程找到最小值状态转移方程为f[l][r]&#x3D;min(f[l][r],f[l][k]+f[k+1][r]+s[r]-s[l-1])</p>
<h3 id="计数类DP"><a href="#计数类DP" class="headerlink" title="计数类DP"></a>计数类DP</h3><h4 id="整数划分"><a href="#整数划分" class="headerlink" title="整数划分"></a>整数划分</h4><p>一个正整数 n 可以表示成若干个正整数之和，我们将这样的一种表示称为正整数 n 的一种划分。</p>
<p>现在给定一个正整数 n，请你求出 n共有多少种不同的划分方法。</p>
<p>完全背包写法</p>
<p>&#x2F;&#x2F;完全背包的写法</p>
<p>using namespace std;</p>
<p>const int M&#x3D;1e9+7;</p>
<p>int f[1010],n;</p>
<p>int main()</p>
<p>{</p>
<pre><code>cin&gt;&gt;n;

f[0]=1;

for (int i = 1; i &lt;= n; i ++ )

    for (int j = i; j &lt;= n; j ++ )&#123;

        f[j]=(f[j-i]+f[j])%M;

    &#125;

cout&lt;&lt;f[n]&lt;&lt;endl;

return 0;
</code></pre>
<p>}</p>
<p>状态转移方程：f[j]&#x3D;(f[j-i]+f[j])</p>
<h3 id="数位统计DP"><a href="#数位统计DP" class="headerlink" title="数位统计DP"></a>数位统计DP</h3><h4 id="计数问题"><a href="#计数问题" class="headerlink" title="计数问题"></a>计数问题</h4><p>题目链接：[338. 计数问题 - AcWing题库]：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/340/">https://www.acwing.com/problem/content/340/</a></p>
<p>计数问题分类讨论.png</p>
<p>using namespace std;</p>
<p>&#x2F;&#x2F;因为我们举的分类中，有需要求一串数字中某个区间的数字，例如abcdefg有一个分类需要求出efg+1</p>
<p>int get(vector<int> num,int l,int r){</p>
<pre><code>int res=0;

for(int i=l;i&gt;=r;i--)res=res*10+num[i];//这里从小到大枚举的是因为下面count的时候读入数据是从最低为读到最高位，那么此时在num里，最高位存的就是数字的最低位，那么假如我们要求efg，那就是从2算到0

return res;
</code></pre>
<p>}</p>
<p>int power10(int i)&#x2F;&#x2F;这里有power10是因为有一个分类需要求得十次方得值</p>
<p>{</p>
<pre><code>int res=1;

while(i--)res*=10;

return res;
</code></pre>
<p>}</p>
<p>int count(int n,int x){</p>
<pre><code>if(!n)return 0;//n=0则返回0

vector&lt;int&gt; num;//num用来存储数中的每一位数字

while(n)&#123;

    num.push_back(n%10);

    n/=10;

&#125;

n=num.size();//得出它的长度

int res=0;

for (int i = n-1-!x; i &gt;=0; i -- )

//这里需要注意，我们的长度需要减一，是因为num是从0开始存储，而长度是元素的个数，因此需要减1才能读到正确的数值，而!x出现的原因是因为我们不能让前导零出现，如果此时需要我们列举的是0得出现的次数，那么我们自然不能让他们出现第一位，而是从第二位开始枚举

&#123;

    if(i&lt;n-1)//其实这里可以不同if判断，因为for循环里面实际上就已经达成了if得判断，但为了方便理解还是加上if来理解，这里i要小于n-1的原因是因为我们不能越界只有7位数就最高从七位数开始读起

    &#123;

        res+=get(num,n-1,i+1)*power10(i);//这里就是第一个分类，000~abc-1，那么此时情况个数就会是abc*103,这里的3取决于后面的efg的长度，假如他是efgh，那么就是4

        //这里的n-1,i+1,自己将数组列出然后根据分类标准就可以得出为什么l是n-1,r=i+1

        if(!x)res-=power10(i);//假如此时我们要列举的是0出现的次数，因为不能出现前导零，这样是不合法也不符合我们的分类情况，例如abcdefg我们列举d，那么他就得从001~abc-1，这样就不会直接到efg，而是会到0efg，因为前面不是前导零，自然就可以列举这个时候0出现的次数，所以要减掉1个power10

    &#125;

    if(num[i]==x)res+=get(num,i-1,0)+1;

    else if(num[i]&gt;x)res+=power10(i);

&#125;

return res;//返回res，即出现次数
</code></pre>
<p>}</p>
<p>int main()</p>
<p>{</p>
<pre><code>int a,b;

while(cin&gt;&gt;a&gt;&gt;b,a||b)&#123;

    if(a&gt;b)swap(a,b);//a大于b则交换a，b使得变成合法参数

    for(int i=0;i&lt;10;i++)

        cout&lt;&lt;count(b,i)-count(a-1,i)&lt;&lt;&#39; &#39;;//使用前缀和思想解决[a,b]的i出现的次数

    cout&lt;&lt;endl;

&#125;

return 0;
</code></pre>
<p>}</p>
<h3 id="状态压缩DP"><a href="#状态压缩DP" class="headerlink" title="状态压缩DP"></a>状态压缩DP</h3><h4 id="蒙德里安的梦想"><a href="#蒙德里安的梦想" class="headerlink" title="蒙德里安的梦想"></a>蒙德里安的梦想</h4><p>题目链接：[U204941 蒙德里安的梦想 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)]：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/U204941">https://www.luogu.com.cn/problem/U204941</a></p>
<p>视频讲解：[431 状态压缩DP 蒙德里安的梦想【动态规划】_哔哩哔哩_bilibili]：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1cv411b7EG/">https://www.bilibili.com/video/BV1cv411b7EG/</a></p>
<p>using namespace std;</p>
<p>const int N &#x3D; 12,M&#x3D;1&lt;&lt;N;</p>
<p>int n,m;</p>
<p>long long f[N][M];</p>
<p>bool st[M];</p>
<p>int main()</p>
<p>{</p>
<pre><code>int n,m;

while(cin&gt;&gt;n&gt;&gt;m,n||m)&#123;

    memset(f, 0, sizeof f);

    //预处理：判断合并列的状态i是否合法

    //如果合并列的某行是1表示横放，是0表示竖放

    //如果合并列不存在连续的奇数个0，即为合法状态

    for (int i = 0; i &lt; 1&lt;&lt;n; i ++ )&#123;

        st[i]=true;

        int cnt=0;//记录合并列中连续0的个数

        for (int j = 0; j &lt; n; j ++ )&#123;

            if(i&gt;&gt;j&amp;1)&#123;//如果是1

                if(cnt&amp;1)&#123;//如果连续0的个数是奇数

                    st[i]=false;//记录i不合法

                    break;

                &#125;

            &#125;else cnt++;//如果是0，记录0的个数

        &#125;

        if(cnt&amp;1)st[i]=false;//处理高位0的个数

    &#125;

    //状态计算

    f[0][0]=1;//第0列不横放是一种合法的方案

    for (int i = 1; i &lt;= m; i ++ )//阶段：枚举列

        for (int j = 0; j &lt; 1&lt;&lt;n; j ++ )//状态：枚举i列的状态

            for (int k = 0; k &lt; 1&lt;&lt;n; k ++ )//状态：枚举i-1列的状态

                //两列状态兼容：不出现重叠的1，不出现连续奇数个0

                if((j&amp;k)==0&amp;&amp;st[j|k])

                    f[i][j]+=f[i-1][k];

    cout&lt;&lt;f[m][0]&lt;&lt;endl;//第m列不横放，既答案

&#125;

return 0;
</code></pre>
<p>}</p>
<p>状态转移方程：</p>
<p>if((j&amp;k)&#x3D;&#x3D;0&amp;&amp;st[j|k])</p>
<p> f[i][j]+&#x3D;f[i-1][k];</p>
<h4 id="最短Hamilton路径"><a href="#最短Hamilton路径" class="headerlink" title="最短Hamilton路径"></a>最短Hamilton路径</h4><p>题目链接：[U122241 最短Hamilton路径 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)]：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/U122241">https://www.luogu.com.cn/problem/U122241</a></p>
<p>using namespace std;</p>
<p>const int N &#x3D; 20,M &#x3D; 1 &lt;&lt; N;</p>
<p>int n;</p>
<p>int w[N][N];</p>
<p>int f[M][N];&#x2F;&#x2F;第一维表示是否访问到该点的压缩状态，第二维是走到点j</p>
<pre><code>        //f[i][j]表示状态为i并且到j的最短路径
</code></pre>
<p>int main(){</p>
<pre><code>cin&gt;&gt;n;

for (int i = 0; i &lt; n; i ++ )

    for (int j = 0; j &lt; n; j ++ )//读入i到j的距离

        cin&gt;&gt;w[i][j];

memset(f, 0x3f, sizeof f);

f[1][0]=0;

for (int i = 0; i &lt; 1 &lt;&lt; n; i ++ )//枚举压缩的状态

    for (int j = 0; j &lt; n; j ++ )//枚举到0~j的点

        if(i &gt;&gt; j &amp; 1)//该状态存在j点

            for (int k = 0; k &lt; n; k ++ )//枚举从j倒数第二个点k

                if(i &gt;&gt; k &amp; 1)//倒数点k存在

                    f[i][j]=min(f[i][j],f[i-(1&lt;&lt;j)][k]+w[k][j]);//状态转移方程，在f[i][j]和状态去掉j的点f[i-(i&lt;&lt;j)][k]+w[k][j]取最小值

cout&lt;&lt;f[(1&lt;&lt;n)-1][n-1]&lt;&lt;endl;//输出状态全满也就是所有点都经过且到最后一个点的最短距离

return 0;
</code></pre>
<p>}</p>
<p>状态转移方程：</p>
<p>f[i][j]&#x3D;min(f[i][j],f[i-(1&lt;&lt;j)][k]+w[k][j]);</p>
<h3 id="树形DP"><a href="#树形DP" class="headerlink" title="树形DP"></a>树形DP</h3><h4 id="没有上司的舞会"><a href="#没有上司的舞会" class="headerlink" title="没有上司的舞会"></a>没有上司的舞会</h4><p>题目：[P1352 没有上司的舞会 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)]：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1352">https://www.luogu.com.cn/problem/P1352</a></p>
<p>视频讲解：[417 树形DP 没有上司的舞会【动态规划】_哔哩哔哩_bilibili]：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1eK411N7Ly/">https://www.bilibili.com/video/BV1eK411N7Ly/</a></p>
<p>using namespace std;</p>
<p>const int N &#x3D; 6010;</p>
<p>int n;</p>
<p>int w[N];&#x2F;&#x2F;每个节点的高兴度</p>
<p>int h[N], e[N], ne[N], idx;&#x2F;&#x2F;邻接表存储树</p>
<p>bool st[N];&#x2F;&#x2F;判断是否有父节点</p>
<p>int f[N][2];</p>
<p>void add(int a, int b)  &#x2F;&#x2F; 添加一条边a-&gt;b</p>
<p>{</p>
<pre><code>e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
</code></pre>
<p>}</p>
<p>void dfs(int u){</p>
<pre><code>f[u][0]=0;

f[u][1]=w[u];//初始化f[u][1]，当第二维是0则不选该点即高兴度为0，同理f[u][1]=w[u];

for (int i = h[u]; i!=-1 ; i =ne[i] )&#123;//遍历u的子节点进行深度优先遍历

    int j=e[i];

    dfs(j);

    //状态转移方程

    f[u][0]+=max(f[j][0],f[j][1]);//f[u][0]表示不选择父节点u，所以在f[j][0]和f[j][1]取最大值

    f[u][1]+=f[j][0];//f[u][1]表示选择根节点u，所以累加不选择子节点的f[j][0]

&#125;
</code></pre>
<p>}</p>
<p>int main()</p>
<p>{</p>
<pre><code>cin&gt;&gt;n;

for (int i = 1; i &lt;= n; i ++ )cin&gt;&gt;w[i];

memset(h, -1, sizeof h);

for (int i = 0; i &lt; n-1; i ++ )&#123;

    int a,b;

    cin&gt;&gt;a&gt;&gt;b;

    add(b,a);

    st[a]=true;//存储是否存在父节点

&#125;

int root=1;

while(st[root])root++;//判断是否是根节点

dfs(root);//dfs对f[i][j]进行状态转移计算

cout&lt;&lt;max(f[root][0],f[root][1])&lt;&lt;endl;//取选与不选根节点的最大值

return 0;
</code></pre>
<p>}</p>
<p>状态转移方程：</p>
<p>f[u][0]+&#x3D;max(f[j][0],f[j][1]);</p>
<p>f[u][1]+&#x3D;f[j][0];</p>
<h3 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h3><h4 id="滑雪"><a href="#滑雪" class="headerlink" title="滑雪"></a>滑雪</h4><p>题目链接：[P1434 [SHOI2002] 滑雪 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)]：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1434">https://www.luogu.com.cn/problem/P1434</a></p>
<p>using namespace std;</p>
<p>const int N &#x3D; 310;</p>
<p>int n,m;</p>
<p>int h[N][N];</p>
<p>int f[N][N];</p>
<p>int dx[4]&#x3D;{-1,0,1,0},dy[4]&#x3D;{0,1,0,-1};</p>
<p>int dp(int x,int y){</p>
<pre><code>int &amp;v=f[x][y];

if(v!=-1)return v;//记忆化搜索核心

v=1;

for (int i = 0; i &lt; 4; i ++ )&#123;

    int a=x+dx[i],b=y+dy[i];

    if(a&gt;=1&amp;&amp;a&lt;=n&amp;&amp;b&gt;=1&amp;&amp;b&lt;=m&amp;&amp;h[a][b]&lt;h[x][y])//判断是否越界且上一个经过的点的高度是否大于当前高度

        v=max(v,dp(a,b)+1);

&#125;

return v;
</code></pre>
<p>}</p>
<p>int main()</p>
<p>{</p>
<pre><code>scanf(&quot;%d%d&quot;, &amp;n, &amp;m);

for (int i = 1; i &lt;= n; i ++ )

    for (int j = 1; j &lt;= m; j ++ )

        scanf(&quot;%d&quot;, &amp;h[i][j]);

memset(f, -1, sizeof f);

int res=0;

for (int i = 1; i &lt;= n; i ++ )

    for (int j = 1; j &lt;= m; j ++ )

        res=max(res,dp(i,j));

printf(&quot;%d\n&quot;,res);

return 0;
</code></pre>
<p>}</p>
<p>状态转移方程：v&#x3D;max(v,dp(a,b)+1);</p>
<h2 id="六、贪心"><a href="#六、贪心" class="headerlink" title="六、贪心"></a>六、贪心</h2><p>一个贪心算法总是做出当前最好的选择，也就是说，它期望通过局部最优选择从而得到全局最优的解决方案。—《算法导论》</p>
<h3 id="区间问题"><a href="#区间问题" class="headerlink" title="区间问题"></a>区间问题</h3><h4 id="区间选点"><a href="#区间选点" class="headerlink" title="区间选点"></a>区间选点</h4><p>给定 N个闭区间[ai,bi]，请你在数轴上选择尽量少的点，使得每个区间内至少包含一个选出的点</p>
<p>输出选择的点的最小数量。</p>
<p>using namespace std;</p>
<p>const int N &#x3D; 100010;</p>
<p>int n;</p>
<p>struct Range{</p>
<pre><code>int l,r;

bool operator &lt;(const Range&amp; W)const&#123;

    return r&lt;W.r;

&#125;//重载小于号
</code></pre>
<p>}range[N];</p>
<p>int main()</p>
<p>{</p>
<pre><code>scanf(&quot;%d&quot;, &amp;n);

for (int i = 0; i &lt; n; i ++ )&#123;

    int l,r;

    scanf(&quot;%d%d&quot;, &amp;l, &amp;r);

    range[i]=&#123;l,r&#125;;//读入l,r

&#125;

sort(range,range+n);//按右端点进行排序

int res=0,ed=-2e9;//ed代表上一个点的右端点

for (int i = 0; i &lt; n; i ++ )&#123;

    if(range[i].l&gt;ed)&#123;

        res++;//点的数量加一

        ed=range[i].r;

    &#125;

&#125;

printf(&quot;%d\n&quot;,res);

return 0;
</code></pre>
<p>}</p>
<h4 id="最大不相交区间数量"><a href="#最大不相交区间数量" class="headerlink" title="最大不相交区间数量"></a>最大不相交区间数量</h4><p>给定 N个闭区间 [ai,bi]，请你在数轴上选择若干区间，使得选中的区间之间互不相交（包括端点）。</p>
<p>输出可选取区间的最大数量。</p>
<p>结论：最大不相交区间数量&#x3D;最少覆盖区间点数</p>
<p>为什么最大不相交区间数&#x3D;最少覆盖区间点数呢？</p>
<p>因为如果几个区间能被同一个点覆盖</p>
<p>说明他们相交了，所以有几个点就是有几个不相交区间</p>
<p>using namespace std;</p>
<p>const int N &#x3D; 100010;</p>
<p>int n;</p>
<p>struct Range{</p>
<pre><code>int l,r;

bool operator &lt;(const Range&amp; W)const&#123;

    return r&lt;W.r;

&#125;
</code></pre>
<p>}range[N];</p>
<p>int main()</p>
<p>{</p>
<pre><code>scanf(&quot;%d&quot;, &amp;n);

for (int i = 0; i &lt; n; i ++ )&#123;

    int l,r;

    scanf(&quot;%d%d&quot;, &amp;l, &amp;r);

    range[i]=&#123;l,r&#125;;

&#125;

sort(range,range+n);

int res=0,ed=-2e9;

for (int i = 0; i &lt; n; i ++ )&#123;

    if(range[i].l&gt;ed)&#123;

        res++;

        ed=range[i].r;

    &#125;

&#125;

printf(&quot;%d\n&quot;,res);

return 0;
</code></pre>
<p>}</p>
<h3 id="区间分组"><a href="#区间分组" class="headerlink" title="区间分组"></a>区间分组</h3><p>区间分组.png</p>
<p>using namespace std;</p>
<p>const int N &#x3D; 1e5+10;</p>
<p>int n;</p>
<p>struct Range{</p>
<pre><code>int l,r;

bool operator&lt;(const Range &amp;W)const&#123;

    return l&lt;W.l;

&#125;//按左端点排序
</code></pre>
<p>}range[N];</p>
<p>int main()</p>
<p>{</p>
<pre><code>scanf(&quot;%d&quot;, &amp;n);

for (int i = 0; i &lt; n; i ++ )&#123;

    int l,r;

    scanf(&quot;%d%d&quot;, &amp;l, &amp;r);

    range[i]=&#123;l,r&#125;;

&#125;

sort(range,range+n);//sort排序

priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; heap;//小根堆维护所有组的右端点最小值

for (int i = 0; i &lt; n; i ++ )&#123;//从左往右枚举

    auto r=range[i];//选择当前区间

    if(heap.empty()||heap.top()&gt;=r.l)heap.push(r.r);

    else&#123;

        heap.pop();

        heap.push(r.r);

    &#125;

&#125;

printf(&quot;%d\n&quot;,heap.size());

return 0;
</code></pre>
<p>}</p>
<h3 id="排序不等式"><a href="#排序不等式" class="headerlink" title="排序不等式"></a>排序不等式</h3><h4 id="排队打水"><a href="#排队打水" class="headerlink" title="排队打水"></a>排队打水</h4><p>有 n个人排队到 1 个水龙头处打水，第 i 个人装满水桶所需的时间是 ti，请问如何安排他们的打水顺序才能使所有人的等待时间之和最小？</p>
<p>t[i]从小到大排序：</p>
<p>计算公式：t[0]×(n−1)+t[1]×(n−2)+t[2]×(n−3)…+t[n]×0</p>
<p>using namespace std;</p>
<p>typedef long long LL;</p>
<p>const int N &#x3D; 1e5 + 10;</p>
<p>int t[N];</p>
<p>int main() {</p>
<pre><code>int n;

scanf(&quot;%d&quot;, &amp;n);

for (int i = 0; i &lt; n; i++)

    scanf(&quot;%d&quot;, &amp;t[i]);

sort(t, t + n);//排序

LL  ans = 0;

for (int i = 0; i &lt; n; i++) &#123;

    ans += t[i] * (n - i - 1);//计算

&#125;

printf(&quot;%lld&quot;, ans);

return 0;
</code></pre>
<p>}</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-06-06T03:16:00.000Z" title="2024/6/6 11:16:00">2024-06-06</time>发表</span><span class="level-item"><time dateTime="2024-06-06T03:20:26.923Z" title="2024/6/6 11:20:26">2024-06-06</time>更新</span><span class="level-item">6 分钟读完 (大约877个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/06/06/KMP%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/">KMP字符串匹配</a></p><div class="content"><h1 id="KMP匹配算法实现"><a href="#KMP匹配算法实现" class="headerlink" title="KMP匹配算法实现"></a>KMP匹配算法实现</h1><p>KMP（Knuth-Morris-Pratt）算法是一种用于在文本中查找模式的高效字符串匹配算法。本文将介绍如何使用C++实现KMP算法。</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定一个文本字符串和一个模式字符串，找出模式字符串在文本字符串中的所有出现位置。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>以下是一个实现KMP匹配算法的完整C++代码示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> p[N], s[M];</span><br><span class="line"><span class="type">int</span> ne[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; p + <span class="number">1</span> &gt;&gt; m &gt;&gt; s + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 求 next 数组的过程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">        <span class="keyword">if</span>(p[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line">        ne[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// KMP 匹配算法</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">        <span class="keyword">if</span>(s[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line">        <span class="keyword">if</span>(j == n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i - n);</span><br><span class="line">            j = ne[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="示例输入输出"><a href="#示例输入输出" class="headerlink" title="示例输入输出"></a>示例输入输出</h2><p>以下是一些示例输入和对应的输出，帮助理解代码的工作原理。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h3><p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5 ababa 9 abababababa</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 2 4</span><br></pre></td></tr></table></figure>

<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h3><p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 abc 10 abcabcabcabc</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 3 6 9</span><br></pre></td></tr></table></figure>

<h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h3><p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 aa 6 aaaaaa</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4</span><br></pre></td></tr></table></figure>

<h2 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h2><h3 id="计算-next-数组："><a href="#计算-next-数组：" class="headerlink" title="计算 next 数组："></a>计算 next 数组：</h3><ul>
<li>通过遍历模式字符串 <code>p</code>，计算每个位置的最长公共前缀和后缀的长度，存储在数组 <code>ne</code> 中。</li>
</ul>
<h3 id="KMP-匹配算法："><a href="#KMP-匹配算法：" class="headerlink" title="KMP 匹配算法："></a>KMP 匹配算法：</h3><ul>
<li>遍历文本字符串 <code>s</code>，使用 <code>ne</code> 数组进行模式匹配，找到所有出现位置并输出。</li>
</ul>
<h3 id="主函数逻辑："><a href="#主函数逻辑：" class="headerlink" title="主函数逻辑："></a>主函数逻辑：</h3><ul>
<li>读取输入数据，计算 <code>ne</code> 数组，并使用 KMP 算法进行字符串匹配，输出所有匹配位置。</li>
</ul>
<p>我们用一个具体的例子来解释KMP算法的实现过程，并展示详细的计算过程。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><ul>
<li>模式串：<code>ABCDABD</code></li>
<li>文本串：<code>ABC ABCDAB ABCDABCDABDE</code></li>
</ul>
<p>我们需要找到模式串在文本串中的所有出现位置。</p>
<h3 id="计算过程"><a href="#计算过程" class="headerlink" title="计算过程"></a>计算过程</h3><h4 id="1-计算-next-数组"><a href="#1-计算-next-数组" class="headerlink" title="1. 计算 next 数组"></a>1. 计算 <code>next</code> 数组</h4><p>模式串：<code>ABCDABD</code><br>长度：<code>n = 7</code></p>
<p>初始化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ne[<span class="number">1</span>] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>计算<code>next</code>数组：</p>
<ul>
<li>i &#x3D; 2, j &#x3D; 0:<ul>
<li><code>p[2] != p[1]</code>，保持 <code>j = 0</code></li>
<li><code>ne[2] = j = 0</code></li>
</ul>
</li>
<li>i &#x3D; 3, j &#x3D; 0:<ul>
<li><code>p[3] != p[1]</code>，保持 <code>j = 0</code></li>
<li><code>ne[3] = j = 0</code></li>
</ul>
</li>
<li>i &#x3D; 4, j &#x3D; 0:<ul>
<li><code>p[4] != p[1]</code>，保持 <code>j = 0</code></li>
<li><code>ne[4] = j = 0</code></li>
</ul>
</li>
<li>i &#x3D; 5, j &#x3D; 0:<ul>
<li><code>p[5] == p[1]</code>，增加 <code>j++</code></li>
<li><code>ne[5] = j = 1</code></li>
</ul>
</li>
<li>i &#x3D; 6, j &#x3D; 1:<ul>
<li><code>p[6] != p[2]</code>，回退 <code>j = ne[1] = 0</code></li>
<li><code>p[6] != p[1]</code>，保持 <code>j = 0</code></li>
<li><code>ne[6] = j = 0</code></li>
</ul>
</li>
<li>i &#x3D; 7, j &#x3D; 0:<ul>
<li><code>p[7] == p[1]</code>，增加 <code>j++</code></li>
<li><code>ne[7] = j = 1</code></li>
</ul>
</li>
</ul>
<p>最终的 <code>next</code> 数组：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ne = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h4 id="2-KMP匹配过程"><a href="#2-KMP匹配过程" class="headerlink" title="2. KMP匹配过程"></a>2. KMP匹配过程</h4><p>文本串：<code>ABC ABCDAB ABCDABCDABDE</code><br>长度：<code>m = 23</code></p>
<p>初始化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">j = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>进行匹配：</p>
<ul>
<li>i &#x3D; 1, j &#x3D; 0:<ul>
<li><code>s[1] == p[1]</code>，增加 <code>j++</code></li>
<li>j &#x3D; 1</li>
</ul>
</li>
<li>i &#x3D; 2, j &#x3D; 1:<ul>
<li><code>s[2] == p[2]</code>，增加 <code>j++</code></li>
<li>j &#x3D; 2</li>
</ul>
</li>
<li>i &#x3D; 3, j &#x3D; 2:<ul>
<li><code>s[3] == p[3]</code>，增加 <code>j++</code></li>
<li>j &#x3D; 3</li>
</ul>
</li>
<li>i &#x3D; 4, j &#x3D; 3:<ul>
<li><code>s[4] == p[4]</code>，增加 <code>j++</code></li>
<li>j &#x3D; 4</li>
</ul>
</li>
<li>i &#x3D; 5, j &#x3D; 4:<ul>
<li><code>s[5] != p[5]</code>，回退 <code>j = ne[4] = 0</code></li>
<li><code>s[5] == p[1]</code>，增加 <code>j++</code></li>
<li>j &#x3D; 1</li>
</ul>
</li>
<li>i &#x3D; 6, j &#x3D; 1:<ul>
<li><code>s[6] == p[2]</code>，增加 <code>j++</code></li>
<li>j &#x3D; 2</li>
</ul>
</li>
<li>i &#x3D; 7, j &#x3D; 2:<ul>
<li><code>s[7] == p[3]</code>，增加 <code>j++</code></li>
<li>j &#x3D; 3</li>
</ul>
</li>
<li>i &#x3D; 8, j &#x3D; 3:<ul>
<li><code>s[8] == p[4]</code>，增加 <code>j++</code></li>
<li>j &#x3D; 4</li>
</ul>
</li>
<li>i &#x3D; 9, j &#x3D; 4:<ul>
<li><code>s[9] == p[5]</code>，增加 <code>j++</code></li>
<li>j &#x3D; 5</li>
</ul>
</li>
<li>i &#x3D; 10, j &#x3D; 5:<ul>
<li><code>s[10] == p[6]</code>，增加 <code>j++</code></li>
<li>j &#x3D; 6</li>
</ul>
</li>
<li>i &#x3D; 11, j &#x3D; 6:<ul>
<li><code>s[11] != p[7]</code>，回退 <code>j = ne[6] = 1</code></li>
<li><code>s[11] != p[2]</code>，回退 <code>j = ne[1] = 0</code></li>
</ul>
</li>
<li>i &#x3D; 12, j &#x3D; 0:<ul>
<li><code>s[12] == p[1]</code>，增加 <code>j++</code></li>
<li>j &#x3D; 1</li>
</ul>
</li>
<li>i &#x3D; 13, j &#x3D; 1:<ul>
<li><code>s[13] == p[2]</code>，增加 <code>j++</code></li>
<li>j &#x3D; 2</li>
</ul>
</li>
<li>i &#x3D; 14, j &#x3D; 2:<ul>
<li><code>s[14] == p[3]</code>，增加 <code>j++</code></li>
<li>j &#x3D; 3</li>
</ul>
</li>
<li>i &#x3D; 15, j &#x3D; 3:<ul>
<li><code>s[15] == p[4]</code>，增加 <code>j++</code></li>
<li>j &#x3D; 4</li>
</ul>
</li>
<li>i &#x3D; 16, j &#x3D; 4:<ul>
<li><code>s[16] == p[5]</code>，增加 <code>j++</code></li>
<li>j &#x3D; 5</li>
</ul>
</li>
<li>i &#x3D; 17, j &#x3D; 5:<ul>
<li><code>s[17] == p[6]</code>，增加 <code>j++</code></li>
<li>j &#x3D; 6</li>
</ul>
</li>
<li>i &#x3D; 18, j &#x3D; 6:<ul>
<li><code>s[18] == p[7]</code>，增加 <code>j++</code></li>
<li>j &#x3D; 7</li>
</ul>
</li>
</ul>
<p>匹配成功，输出 <code>i - n = 18 - 7 = 11</code>。回退 <code>j = ne[7] = 1</code>。</p>
<ul>
<li>i &#x3D; 19, j &#x3D; 1:<ul>
<li><code>s[19] == p[2]</code>，增加 <code>j++</code></li>
<li>j &#x3D; 2</li>
</ul>
</li>
<li>i &#x3D; 20, j &#x3D; 2:<ul>
<li><code>s[20] == p[3]</code>，增加 <code>j++</code></li>
<li>j &#x3D; 3</li>
</ul>
</li>
<li>i &#x3D; 21, j &#x3D; 3:<ul>
<li><code>s[21] == p[4]</code>，增加 <code>j++</code></li>
<li>j &#x3D; 4</li>
</ul>
</li>
<li>i &#x3D; 22, j &#x3D; 4:<ul>
<li><code>s[22] == p[5]</code>，增加 <code>j++</code></li>
<li>j &#x3D; 5</li>
</ul>
</li>
<li>i &#x3D; 23, j &#x3D; 5:<ul>
<li><code>s[23] == p[6]</code>，增加 <code>j++</code></li>
<li>j &#x3D; 6</li>
</ul>
</li>
</ul>
<p>匹配失败，结束匹配。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>最终匹配输出位置为 <code>11</code>。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-06-05T23:52:19.000Z" title="2024/6/6 07:52:19">2024-06-06</time>发表</span><span class="level-item"><time dateTime="2024-06-05T23:52:29.181Z" title="2024/6/6 07:52:29">2024-06-06</time>更新</span><span class="level-item">几秒读完 (大约0个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/06/06/%E9%98%9F%E5%88%97/">队列</a></p><div class="content"></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-06-05T23:49:01.000Z" title="2024/6/6 07:49:01">2024-06-06</time>发表</span><span class="level-item"><time dateTime="2024-06-05T23:49:10.026Z" title="2024/6/6 07:49:10">2024-06-06</time>更新</span><span class="level-item">3 分钟读完 (大约449个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/06/06/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/">滑动窗口</a></p><div class="content"><h1 id="滑动窗口实现"><a href="#滑动窗口实现" class="headerlink" title="滑动窗口实现"></a>滑动窗口实现</h1><p>滑动窗口是一种常用的算法技巧，用于在数组或列表上进行高效的区间操作。本文将介绍如何使用C++实现滑动窗口。</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定一个长度为 <code>n</code> 的数组和一个整数 <code>k</code>，找出每个长度为 <code>k</code> 的子数组的最小值和最大值。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>以下是一个实现滑动窗口的完整C++代码示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="type">int</span> a[N], q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 判断队头是否已经滑出窗口</span></span><br><span class="line">        <span class="keyword">if</span>(hh &lt;= tt &amp;&amp; i - k + <span class="number">1</span> &gt; q[hh]) hh++;</span><br><span class="line">        <span class="keyword">while</span>(hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt--;</span><br><span class="line">        q[++tt] = i;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[q[hh]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 判断队头是否已经滑出窗口</span></span><br><span class="line">        <span class="keyword">if</span>(hh &lt;= tt &amp;&amp; i - k + <span class="number">1</span> &gt; q[hh]) hh++;</span><br><span class="line">        <span class="keyword">while</span>(hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i]) tt--;</span><br><span class="line">        q[++tt] = i;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[q[hh]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="示例输入输出"><a href="#示例输入输出" class="headerlink" title="示例输入输出"></a>示例输入输出</h2><p>以下是一些示例输入和对应的输出，帮助理解代码的工作原理。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h3><p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8 3</span><br><span class="line">1 3 -1 -3 5 3 6 7</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-1 -3 -3 -3 3 3</span><br><span class="line">3 3 5 5 6 7</span><br></pre></td></tr></table></figure>

<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h3><p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5 2</span><br><span class="line">2 1 2 4 3</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 1 2 3</span><br><span class="line">2 2 4 4</span><br></pre></td></tr></table></figure>

<h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h3><p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6 4</span><br><span class="line">9 3 5 1 6 7</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 1 1</span><br><span class="line">9 6 6</span><br></pre></td></tr></table></figure>

<h2 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h2><h3 id="初始化滑动窗口："><a href="#初始化滑动窗口：" class="headerlink" title="初始化滑动窗口："></a>初始化滑动窗口：</h3><ul>
<li>定义数组 <code>a</code> 存储输入的数组，<code>q</code> 用作滑动窗口的队列。</li>
<li>读取数组长度 <code>n</code> 和窗口大小 <code>k</code>。</li>
</ul>
<h3 id="处理输入数据："><a href="#处理输入数据：" class="headerlink" title="处理输入数据："></a>处理输入数据：</h3><ul>
<li>读取输入的数组元素，维护两个滑动窗口，分别用于求最小值和最大值。</li>
</ul>
<h3 id="主函数逻辑："><a href="#主函数逻辑：" class="headerlink" title="主函数逻辑："></a>主函数逻辑：</h3><ul>
<li>初始化队列，处理输入数据，并按照滑动窗口的规则输出每个子数组的最小值和最大值。</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-06-05T13:28:21.000Z" title="2024/6/5 21:28:21">2024-06-05</time>发表</span><span class="level-item"><time dateTime="2024-06-05T23:29:35.603Z" title="2024/6/6 07:29:35">2024-06-06</time>更新</span><span class="level-item">2 分钟读完 (大约352个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/06/05/%E5%8D%95%E8%B0%83%E6%A0%88/">单调栈</a></p><div class="content"><h1 id="单调栈实现"><a href="#单调栈实现" class="headerlink" title="单调栈实现"></a>单调栈实现</h1><p>单调栈是一种常用的数据结构，用于解决一类特殊的栈问题。本文将介绍如何使用C++实现单调栈。</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定一个长度为 <code>n</code> 的数组，找出每个元素左边第一个比它小的数。如果不存在这样的元素，则输出 <code>-1</code>。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>以下是一个实现单调栈的完整C++代码示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N  = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> st[N], tt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="keyword">while</span>(tt &amp;&amp; st[tt] &gt;= x) tt--;</span><br><span class="line">        <span class="keyword">if</span>(tt) cout &lt;&lt; st[tt] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        st[++tt] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="示例输入输出"><a href="#示例输入输出" class="headerlink" title="示例输入输出"></a>示例输入输出</h2><p>以下是一些示例输入和对应的输出，帮助理解代码的工作原理。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h3><p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">2 4 3 1 5</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1 2 2 -1 1</span><br></pre></td></tr></table></figure>

<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h3><p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">1 2 3 4 5 6</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1 1 2 3 4 5</span><br></pre></td></tr></table></figure>

<h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h3><p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">6 5 4 3 2 1</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1 -1 -1 -1 -1 -1</span><br></pre></td></tr></table></figure>

<h2 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h2><h3 id="初始化单调栈："><a href="#初始化单调栈：" class="headerlink" title="初始化单调栈："></a>初始化单调栈：</h3><ul>
<li>定义数组 <code>st</code> 存储栈中的元素，<code>tt</code> 为栈顶指针。</li>
</ul>
<h3 id="处理输入数据："><a href="#处理输入数据：" class="headerlink" title="处理输入数据："></a>处理输入数据：</h3><ul>
<li>读取输入的整数 <code>n</code>，表示数组的长度。</li>
<li>遍历输入的每个元素 <code>x</code>，维护一个单调递增的栈，输出每个元素左边第一个小于它的元素。</li>
</ul>
<h3 id="主函数逻辑："><a href="#主函数逻辑：" class="headerlink" title="主函数逻辑："></a>主函数逻辑：</h3><ul>
<li>初始化栈，读取输入数据，并按照单调栈的规则处理和输出结果。</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-06-04T14:21:35.000Z" title="2024/6/4 22:21:35">2024-06-04</time>发表</span><span class="level-item"><time dateTime="2024-06-04T14:21:35.570Z" title="2024/6/4 22:21:35">2024-06-04</time>更新</span><span class="level-item">几秒读完 (大约0个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/06/04/%E6%A0%88/">栈</a></p><div class="content"></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-06-04T14:08:49.000Z" title="2024/6/4 22:08:49">2024-06-04</time>发表</span><span class="level-item"><time dateTime="2024-06-05T13:32:43.584Z" title="2024/6/5 21:32:43">2024-06-05</time>更新</span><span class="level-item">8 分钟读完 (大约1172个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/06/04/%E5%8D%95%E9%93%BE%E8%A1%A8/">单链表</a></p><div class="content"><h2 id="题目：单链表的基本操作"><a href="#题目：单链表的基本操作" class="headerlink" title="题目：单链表的基本操作"></a>题目：单链表的基本操作</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>实现一个单链表，并支持以下三种操作：</p>
<ol>
<li>将一个元素插入到链表的头部。</li>
<li>将一个元素插入到链表中指定元素的后面。</li>
<li>删除链表中指定元素的后一个元素。</li>
</ol>
<p>链表初始为空。每个操作保证合法，且不会删除链表中不存在的元素。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含一个整数 <code>m</code>，表示操作的次数。</p>
<p>接下来 <code>m</code> 行，每行包含一个操作指令，具体形式如下：</p>
<ul>
<li><code>H x</code>：将整数 <code>x</code> 插入到链表的头部。</li>
<li><code>D k</code>：删除链表中第 <code>k</code> 个元素的后一个元素（<code>k</code> 从 1 开始）。</li>
<li><code>I k x</code>：将整数 <code>x</code> 插入到链表中第 <code>k</code> 个元素的后面（<code>k</code> 从 1 开始）。</li>
</ul>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一行，表示最终链表中的所有元素，按顺序用空格隔开。</p>
<h3 id="输入输出示例"><a href="#输入输出示例" class="headerlink" title="输入输出示例"></a>输入输出示例</h3><h4 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h4><p><strong>输入</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">H 1</span><br><span class="line">H 2</span><br><span class="line">I 2 3</span><br><span class="line">D 1</span><br><span class="line">I 1 4</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 4 3</span><br></pre></td></tr></table></figure>

<h4 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h4><p><strong>输入</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">H 10</span><br><span class="line">H 20</span><br><span class="line">I 1 30</span><br><span class="line">D 2</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20 10</span><br></pre></td></tr></table></figure>

<h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>我们使用一个数组 <code>e</code> 存储链表的元素，数组 <code>ne</code> 存储每个节点的下一个节点的下标。<code>head</code> 存储链表头部节点的下标，<code>idx</code> 表示当前插入元素的下标。具体实现包括初始化链表、在头部插入元素、在指定位置插入元素，以及删除指定位置后的元素。</p>
<p>通过解析输入的操作指令，我们对链表进行相应的操作，最终输出链表中的所有元素。<br>这段代码实现了一个简单的单链表操作，包括在头部插入节点、在某个节点后插入节点、删除某个节点后的节点以及遍历链表。</p>
<h3 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h3><ol>
<li><p><strong>定义常量和变量</strong>：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> head, e[N], ne[N], idx;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>N</code> 是数组的最大大小。</li>
<li><code>head</code> 是链表的头指针。</li>
<li><code>e</code> 数组存储节点的值。</li>
<li><code>ne</code> 数组存储每个节点的下一个节点的索引。</li>
<li><code>idx</code> 是当前节点的索引。</li>
</ul>
</li>
<li><p><strong>初始化函数</strong>：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 初始化链表，将 <code>head</code> 设为 <code>-1</code> 表示链表为空，<code>idx</code> 设为 <code>0</code>。</p>
</li>
<li><p><strong>在头部插入节点</strong>：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_to_head</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = head;</span><br><span class="line">    head = idx;</span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 将值 <code>x</code> 插入到头部节点，更新头指针和 <code>idx</code>。</p>
</li>
<li><p><strong>在节点 <code>k</code> 后插入节点</strong>：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = ne[k];</span><br><span class="line">    ne[k] = idx;</span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 在节点 <code>k</code> 后插入值 <code>x</code> 的新节点。</p>
</li>
<li><p><strong>删除节点 <code>k</code> 后的节点</strong>：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    ne[k] = ne[ne[k]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 删除节点 <code>k</code> 后的节点。</p>
</li>
<li><p><strong>主函数</strong>：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="type">int</span> k, x;</span><br><span class="line">        <span class="type">char</span> op;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&#x27;H&#x27;</span>) &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add_to_head</span>(x);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;D&#x27;</span>) &#123;</span><br><span class="line">            cin &gt;&gt; k;</span><br><span class="line">            <span class="keyword">if</span> (!k) head = ne[head];</span><br><span class="line">            <span class="built_in">remove</span>(k - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add</span>(k - <span class="number">1</span>, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head; i != <span class="number">-1</span>; i = ne[i]) cout &lt;&lt; e[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>读取操作数量 <code>m</code>。</li>
<li>初始化链表。</li>
<li>循环处理每个操作，根据操作类型执行相应的链表操作。</li>
<li>最后遍历并输出链表中的所有节点值。</li>
</ul>
</li>
</ol>
<h3 id="处理流程示例"><a href="#处理流程示例" class="headerlink" title="处理流程示例"></a>处理流程示例</h3><p>假设输入如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">H 3</span><br><span class="line">H 2</span><br><span class="line">I 1 4</span><br><span class="line">D 2</span><br><span class="line">H 1</span><br></pre></td></tr></table></figure>

<h4 id="输入解释"><a href="#输入解释" class="headerlink" title="输入解释"></a>输入解释</h4><ul>
<li>第1行：<code>5</code> 表示有5个操作。</li>
<li>第2行：<code>H 3</code> 在头部插入值为3的节点。</li>
<li>第3行：<code>H 2</code> 在头部插入值为2的节点。</li>
<li>第4行：<code>I 1 4</code> 在第1个节点后插入值为4的节点。</li>
<li>第5行：<code>D 2</code> 删除第2个节点后的节点。</li>
<li>第6行：<code>H 1</code> 在头部插入值为1的节点。</li>
</ul>
<h4 id="按照代码处理流程"><a href="#按照代码处理流程" class="headerlink" title="按照代码处理流程"></a>按照代码处理流程</h4><ol>
<li><p><strong>初始化链表</strong>：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">head = <span class="number">-1</span>;</span><br><span class="line">idx = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>执行操作</strong>：</p>
<ul>
<li><p>操作 <code>H 3</code>：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">add_to_head</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>  更新后 <code>e = [3]</code>，<code>ne = [-1]</code>，<code>head = 0</code>，<code>idx = 1</code>。</p>
</li>
<li><p>操作 <code>H 2</code>：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">add_to_head</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>  更新后 <code>e = [3, 2]</code>，<code>ne = [-1, 0]</code>，<code>head = 1</code>，<code>idx = 2</code>。</p>
</li>
<li><p>操作 <code>I 1 4</code>：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">add</span>(<span class="number">0</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<p>  更新后 <code>e = [3, 2, 4]</code>，<code>ne = [2, 0, -1]</code>，<code>head = 1</code>，<code>idx = 3</code>。</p>
</li>
<li><p>操作 <code>D 2</code>：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">remove</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>  更新后 <code>ne = [2, -1, -1]</code>。</p>
</li>
<li><p>操作 <code>H 1</code>：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">add_to_head</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>  更新后 <code>e = [3, 2, 4, 1]</code>，<code>ne = [2, -1, -1, 1]</code>，<code>head = 3</code>，<code>idx = 4</code>。</p>
</li>
</ul>
</li>
<li><p><strong>遍历并输出链表</strong>：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = head; i != <span class="number">-1</span>; i = ne[i]) cout &lt;&lt; e[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br></pre></td></tr></table></figure>
<p> 从头指针 <code>head = 3</code> 开始遍历，输出结果为：</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过这个例子，可以看到如何按照输入操作动态地更新链表，并最终输出链表的内容。每个操作都按照代码中的逻辑逐步进行，链表结构在每一步都进行了相应的更新和调整。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-06-02T01:52:25.000Z" title="2024/6/2 09:52:25">2024-06-02</time>发表</span><span class="level-item"><time dateTime="2024-06-02T03:03:49.160Z" title="2024/6/2 11:03:49">2024-06-02</time>更新</span><span class="level-item">10 分钟读完 (大约1509个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/06/02/%E5%89%8D%E7%BC%80%E5%92%8C-1/">高级前缀和</a></p><div class="content"><h1 id="高级前缀和实现"><a href="#高级前缀和实现" class="headerlink" title="高级前缀和实现"></a>高级前缀和实现</h1><p>在处理大范围坐标的区间求和时，可以使用离散化技术和前缀和结合来提高效率。本文将介绍如何使用C++实现这一方法。</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>假定有一个无限长的数轴，数轴上每个坐标都是0。<br>现在，我们首先进行n次操作，每次操作将某一位置x上的数加c。<br>接下来，进行m次询问，每个询问包含两个整数l和r，你需要求出在区间[l,r]之间所有数的和。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含两个整数n、m。<br>接下来n行，每行包括两个整数x和c。<br>再接下来里m行，每行包括两个整数l和r。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>共m行，每行输入一个询问中所求得区间内数字和。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>以下是一个实现高级前缀和的完整C++代码示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII; </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">300010</span>;</span><br><span class="line"><span class="type">int</span> a[N]; <span class="comment">// 离散化后的数组，用于存储离散化坐标对应的值</span></span><br><span class="line"><span class="type">int</span> s[N]; <span class="comment">// 前缀和数组，用于快速查询区间和</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; alls; <span class="comment">// 用于存储所有需要离散化的坐标</span></span><br><span class="line">vector&lt;PII&gt; add, question; <span class="comment">// add存储添加操作，question存储查询操作</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">// 二分查找函数，找到x在alls中的位置（离散化后的坐标）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>, r=alls.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(alls[mid] &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r + <span class="number">1</span>; <span class="comment">// 返回离散化后的坐标索引</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    ios; <span class="comment">// 优化输入输出</span></span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n; <span class="comment">// 读取操作的数量，m是添加操作的数量，n是查询操作的数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取添加操作</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> b, c;</span><br><span class="line">        cin &gt;&gt; b &gt;&gt; c; <span class="comment">// 读取添加操作的坐标和值</span></span><br><span class="line">        alls.<span class="built_in">push_back</span>(b); <span class="comment">// 将坐标存入alls中</span></span><br><span class="line">        add.<span class="built_in">push_back</span>(&#123;b, c&#125;); <span class="comment">// 将操作存入add中</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取查询操作</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> b, c;</span><br><span class="line">        cin &gt;&gt; b &gt;&gt; c; <span class="comment">// 读取查询操作的区间起点和终点</span></span><br><span class="line">        alls.<span class="built_in">push_back</span>(b); <span class="comment">// 将查询区间的两个坐标都存入alls中</span></span><br><span class="line">        alls.<span class="built_in">push_back</span>(c);</span><br><span class="line">        question.<span class="built_in">push_back</span>(&#123;b, c&#125;); <span class="comment">// 将查询操作存入question中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 离散化：对所有的坐标进行排序，并去重</span></span><br><span class="line">    <span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>());</span><br><span class="line">    alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 离散化并执行添加操作</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x : add)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> h = <span class="built_in">find</span>(x.first); <span class="comment">// 找到离散化后的坐标索引</span></span><br><span class="line">        a[h] += x.second; <span class="comment">// 在离散化后的数组中进行添加操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造前缀和数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= alls.<span class="built_in">size</span>(); i++) </span><br><span class="line">        s[i] = s[i - <span class="number">1</span>] + a[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理查询操作</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x : question)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> h = <span class="built_in">find</span>(x.first); <span class="comment">// 找到查询区间起点的离散化坐标</span></span><br><span class="line">        <span class="type">int</span> t = <span class="built_in">find</span>(x.second); <span class="comment">// 找到查询区间终点的离散化坐标</span></span><br><span class="line">        cout &lt;&lt; s[t] - s[h - <span class="number">1</span>] &lt;&lt; <span class="string">&quot;&quot;</span>; <span class="comment">// 输出查询结果，即区间和</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="示例输入输出"><a href="#示例输入输出" class="headerlink" title="示例输入输出"></a>示例输入输出</h2><p>以下是一些示例输入和对应的输出，帮助理解代码的工作原理。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h3><p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3 2</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">4 5</span><br><span class="line">1 2</span><br><span class="line">2 4</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">8</span><br></pre></td></tr></table></figure>

<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h3><p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">4 3</span><br><span class="line">1 1</span><br><span class="line">2 2</span><br><span class="line">3 3</span><br><span class="line">4 4</span><br><span class="line">1 3</span><br><span class="line">2 4</span><br><span class="line">1 4</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td></tr></table></figure>

<h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h3><p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2 2</span><br><span class="line">100 1</span><br><span class="line">200 2</span><br><span class="line">100 200</span><br><span class="line">150 250</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<h2 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h2><h3 id="输入处理："><a href="#输入处理：" class="headerlink" title="输入处理："></a>输入处理：</h3><ul>
<li>使用 <code>cin</code> 函数读取操作数 <code>m</code> 和查询数 <code>n</code>。</li>
<li>读取操作和查询的坐标，存储在对应的向量中，并记录所有需要的坐标。</li>
</ul>
<h3 id="离散化和前缀和实现："><a href="#离散化和前缀和实现：" class="headerlink" title="离散化和前缀和实现："></a>离散化和前缀和实现：</h3><ul>
<li>通过排序和去重对坐标进行离散化。</li>
<li>使用离散化后的坐标构造前缀和数组。</li>
</ul>
<h3 id="主函数逻辑："><a href="#主函数逻辑：" class="headerlink" title="主函数逻辑："></a>主函数逻辑：</h3><ul>
<li>读取输入数据并进行离散化处理。</li>
<li>构造前缀和数组，并处理每个查询，输出对应的区间和。</li>
</ul>
<p>当然可以。下面是一个具体的例子以及按照代码处理流程的解释：</p>
<h3 id="输入示例"><a href="#输入示例" class="headerlink" title="输入示例"></a>输入示例</h3><p>假设输入如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3 2</span><br><span class="line">1 5</span><br><span class="line">2 6</span><br><span class="line">3 7</span><br><span class="line">1 3</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure>

<h3 id="输入解释"><a href="#输入解释" class="headerlink" title="输入解释"></a>输入解释</h3><ul>
<li>第1行：<code>3 2</code> 表示有3个添加操作和2个查询操作。</li>
<li>第2-4行：<code>1 5</code>，<code>2 6</code>，<code>3 7</code> 是3个添加操作，表示在坐标1加上5，在坐标2加上6，在坐标3加上7。</li>
<li>第5-6行：<code>1 3</code>，<code>2 3</code> 是2个查询操作，分别查询区间 <code>[1, 3]</code> 和 <code>[2, 3]</code> 的和。</li>
</ul>
<h3 id="按照代码处理流程"><a href="#按照代码处理流程" class="headerlink" title="按照代码处理流程"></a>按照代码处理流程</h3><ol>
<li><p><strong>读取输入并存储操作</strong>：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> m, n;</span><br><span class="line">cin &gt;&gt; m &gt;&gt; n;</span><br></pre></td></tr></table></figure>
<p> <code>m = 3</code>，<code>n = 2</code>。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="type">int</span> b, c;</span><br><span class="line">    cin &gt;&gt; b &gt;&gt; c;</span><br><span class="line">    alls.<span class="built_in">push_back</span>(b);</span><br><span class="line">    add.<span class="built_in">push_back</span>(&#123;b, c&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 处理添加操作，将坐标 <code>b</code> 存入 <code>alls</code>，并将操作 <code>(b, c)</code> 存入 <code>add</code>。</p>
<p> <code>alls = [1, 2, 3]</code>，<br> <code>add = [(1, 5), (2, 6), (3, 7)]</code>。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> b, c;</span><br><span class="line">    cin &gt;&gt; b &gt;&gt; c;</span><br><span class="line">    alls.<span class="built_in">push_back</span>(b);</span><br><span class="line">    alls.<span class="built_in">push_back</span>(c);</span><br><span class="line">    question.<span class="built_in">push_back</span>(&#123;b, c&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 处理查询操作，将区间起点和终点 <code>b, c</code> 存入 <code>alls</code>，并将操作 <code>(b, c)</code> 存入 <code>question</code>。</p>
<p> <code>alls = [1, 2, 3, 1, 3, 2, 3]</code>，<br> <code>question = [(1, 3), (2, 3)]</code>。</p>
</li>
<li><p><strong>离散化处理</strong>：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>());</span><br><span class="line">alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>
<p> 对 <code>alls</code> 进行排序和去重。</p>
<p> <code>alls = [1, 2, 3]</code>。</p>
</li>
<li><p><strong>执行添加操作</strong>：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x : add) &#123;</span><br><span class="line">    <span class="type">int</span> h = <span class="built_in">find</span>(x.first);</span><br><span class="line">    a[h] += x.second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 将添加操作应用到离散化后的数组 <code>a</code> 中。</p>
<p> <code>find(1) = 1</code>，<code>find(2) = 2</code>，<code>find(3) = 3</code>。</p>
<p> 更新后 <code>a</code> 数组的变化：<br> <code>a = [0, 5, 6, 7]</code>。</p>
</li>
<li><p><strong>构建前缀和数组</strong>：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= alls.<span class="built_in">size</span>(); i++)</span><br><span class="line">    s[i] = s[i - <span class="number">1</span>] + a[i];</span><br></pre></td></tr></table></figure>
<p> 构建前缀和数组 <code>s</code>。</p>
<p> 前缀和数组 <code>s</code>：<br> <code>s = [0, 5, 11, 18]</code>。</p>
</li>
<li><p><strong>处理查询操作并输出结果</strong>：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x : question) &#123;</span><br><span class="line">    <span class="type">int</span> h = <span class="built_in">find</span>(x.first);</span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">find</span>(x.second);</span><br><span class="line">    cout &lt;&lt; s[t] - s[h - <span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 处理查询操作并输出结果。</p>
<ul>
<li>查询区间 <code>[1, 3]</code>：<br>  <code>find(1) = 1</code>，<code>find(3) = 3</code>，<br>  结果：<code>s[3] - s[0] = 18 - 0 = 18</code>。</li>
<li>查询区间 <code>[2, 3]</code>：<br>  <code>find(2) = 2</code>，<code>find(3) = 3</code>，<br>  结果：<code>s[3] - s[1] = 18 - 5 = 13</code>。</li>
</ul>
</li>
</ol>
<h3 id="最终输出"><a href="#最终输出" class="headerlink" title="最终输出"></a>最终输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">18 13</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过这个例子，我们可以看到代码是如何处理添加和查询操作的。代码通过离散化技术将原始坐标映射到较小的连续整数范围，从而在固定大小的数组上执行操作，这显著提高了处理效率。</p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/page/0/">上一页</a></div><div class="pagination-next"><a href="/page/2/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li><li><a class="pagination-link" href="/page/3/">3</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/icon.jpg" alt="Xiongyuqi"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Xiongyuqi</p><p class="is-size-6 is-block">Edward</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Dalian</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">22</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">7</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/Mr-xiongyq" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/Mr-xiongyq"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:xiongxixi666@gmail.com"><i class="fas fa-envelope"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-06-27T07:03:20.000Z">2024-06-27</time></p><p class="title"><a href="/2024/06/27/%E9%9D%A2%E7%BB%8F2-attention-%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/">面经2-attention(注意力机制)</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-06-27T06:53:24.000Z">2024-06-27</time></p><p class="title"><a href="/2024/06/27/%E9%9D%A2%E7%BB%8F/">面经</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-06-13T12:15:51.000Z">2024-06-13</time></p><p class="title"><a href="/2024/06/13/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/">算法总结</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-06-06T03:16:00.000Z">2024-06-06</time></p><p class="title"><a href="/2024/06/06/KMP%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/">KMP字符串匹配</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-06-05T23:52:19.000Z">2024-06-06</time></p><p class="title"><a href="/2024/06/06/%E9%98%9F%E5%88%97/">队列</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/06/"><span class="level-start"><span class="level-item">六月 2024</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/05/"><span class="level-start"><span class="level-item">五月 2024</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/03/"><span class="level-start"><span class="level-item">三月 2024</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Computer/"><span class="tag">Computer</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"><span class="tag">字符串</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="tag">数据结构</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%97%A5%E5%B8%B8/"><span class="tag">日常</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag">13</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%9D%A2%E7%BB%8F1-swimtransformer/"><span class="tag">面经1-swimtransformer</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%9D%A2%E7%BB%8F2-attention-%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/"><span class="tag">面经2-attention(注意力机制)</span><span class="tag">1</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Blogs" height="28"></a><p class="is-size-7"><span>&copy; 2024 Xiongyuqi</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="GitHub上下载" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://npm.elemecdn.com/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://npm.elemecdn.com/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://npm.elemecdn.com/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://npm.elemecdn.com/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://npm.elemecdn.com/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://npm.elemecdn.com/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/javascript" id="MathJax-script" async>MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      },
      svg: {
        fontCache: 'global'
      },
      chtml: {
        matchFontHeight: false
      }
    };</script><script src="https://npm.elemecdn.com/mathjax@3.2.2/es5/tex-mml-chtml.js"></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>