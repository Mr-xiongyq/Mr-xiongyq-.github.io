<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Blogs</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#ffffff"><meta name="application-name" content="Edward&#039;s Blogs"><meta name="msapplication-TileImage" content="/source/icon.jpg"><meta name="msapplication-TileColor" content="#ffffff"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Edward&#039;s Blogs"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Blogs"><meta property="og:url" content="https://mr-xiongyq.github.io/"><meta property="og:site_name" content="Blogs"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://mr-xiongyq.github.io/img/og_image.png"><meta property="article:author" content="Xiongyuqi"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://mr-xiongyq.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://mr-xiongyq.github.io"},"headline":"Blogs","image":["https://mr-xiongyq.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Xiongyuqi"},"publisher":{"@type":"Organization","name":"Blogs","logo":{"@type":"ImageObject","url":"https://mr-xiongyq.github.io/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/6.0.0/css/all.min.css"><link rel="stylesheet" href="https://npm.elemecdn.com/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.lug.ustc.edu.cn/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://npm.elemecdn.com/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://npm.elemecdn.com/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://npm.elemecdn.com/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.1.1"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Blogs" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item is-active" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" target="_blank" rel="noopener" href="https://github.com/Mr-xiongyq">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="GitHub上下载" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-06-27T07:03:20.000Z" title="2024/6/27 15:03:20">2024-06-27</time>发表</span><span class="level-item"><time dateTime="2024-06-27T07:11:39.085Z" title="2024/6/27 15:11:39">2024-06-27</time>更新</span><span class="level-item">24 分钟读完 (大约3528个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/06/27/%E9%9D%A2%E7%BB%8F2-attention-%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/">面经2-attention(注意力机制)</a></p><div class="content"><h2 id="1-通俗的解释什么是attention"><a href="#1-通俗的解释什么是attention" class="headerlink" title="1.通俗的解释什么是attention"></a>1.通俗的解释什么是attention</h2><p>注意力机制（Attention Mechanism）是深度学习中一种非常重要的技术，它帮助模型更好地“关注”输入数据中的重要部分。为了更通俗地解释，我们可以用一个简单的类比来帮助理解。</p>
<h3 id="类比：读书做笔记"><a href="#类比：读书做笔记" class="headerlink" title="类比：读书做笔记"></a>类比：读书做笔记</h3><p>假设你在阅读一本书，并且需要在阅读过程中做一些笔记。书中的内容非常多，但你不能也不需要记住每一个字。那么你会怎么做呢？你会重点关注那些对你来说重要的信息。注意力机制就像你在读书时选择性地关注重要内容一样。</p>
<h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><ol>
<li><p><strong>输入信息</strong>：</p>
<ul>
<li>你有一本书（输入数据），每一页上有很多文字（输入序列）。</li>
</ul>
</li>
<li><p><strong>关键内容</strong>：</p>
<ul>
<li>你要做笔记，所以你需要找到哪些内容是最重要的，比如关键的段落、句子或单词。</li>
</ul>
</li>
<li><p><strong>注意力权重</strong>：</p>
<ul>
<li>你给每个句子或段落分配一个重要性分数（权重）。更重要的内容分数更高，不太重要的内容分数更低。</li>
</ul>
</li>
<li><p><strong>加权求和</strong>：</p>
<ul>
<li>你根据这些分数来决定每段内容在你笔记中的重要性。重要性高的内容，你会详细记下（加权求和后保留更多信息），重要性低的内容，你会略过或简要记下。</li>
</ul>
</li>
</ol>
<h3 id="在深度学习中的应用"><a href="#在深度学习中的应用" class="headerlink" title="在深度学习中的应用"></a>在深度学习中的应用</h3><p>在深度学习中，注意力机制通过以下步骤工作：</p>
<ol>
<li><p><strong>输入序列</strong>：</p>
<ul>
<li>模型接收一段输入序列，比如一句话的每个单词的表示（向量）。</li>
</ul>
</li>
<li><p><strong>计算注意力分数</strong>：</p>
<ul>
<li>模型计算每个单词对当前处理单词的重要性，类似于你给每段内容分配一个重要性分数。</li>
</ul>
</li>
<li><p><strong>生成注意力权重</strong>：</p>
<ul>
<li>使用这些分数通过一个softmax函数转化为注意力权重，这些权重和分数可以理解为“关注度”。</li>
</ul>
</li>
<li><p><strong>加权求和</strong>：</p>
<ul>
<li>对输入序列中的所有单词的表示进行加权求和，权重高的单词对最终表示的影响更大。</li>
</ul>
</li>
</ol>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>假设你在翻译一个句子：”The cat sat on the mat.”</p>
<p>在翻译时，模型需要决定哪些单词对当前正在翻译的单词最重要。例如，在翻译“sat”时，模型可能会发现“cat”和“mat”也很重要，因为它们在语义上相关。这时，注意力机制会给“cat”和“mat”更高的权重，而给其他不太相关的单词更低的权重。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>注意力机制帮助模型在处理大量信息时，更加高效地聚焦于最相关和重要的部分。这不仅提高了模型的性能，也使得模型在处理复杂任务时更加灵活和精确。就像你在读书时会重点标记和记住重要的部分一样，注意力机制使得模型在处理数据时能够有效地“注意”到关键信息。</p>
<h2 id="2-注意力机制的计算"><a href="#2-注意力机制的计算" class="headerlink" title="2.注意力机制的计算"></a>2.注意力机制的计算</h2><p>注意力机制（Attention Mechanism）在深度学习中的计算方法主要包括三个步骤：计算注意力分数、生成注意力权重、加权求和。以下是详细的计算过程，以自注意力（Self-Attention）为例进行解释。</p>
<h3 id="1-输入表示"><a href="#1-输入表示" class="headerlink" title="1. 输入表示"></a>1. 输入表示</h3><p>假设我们有一个输入序列，表示为矩阵 (X)，其中每一行是输入序列中一个词的向量表示。对于一个长度为 (n) 的序列，每个词的向量维度为 (d)，输入矩阵 (X) 的形状为 (n \times d)。</p>
<h3 id="2-计算查询（Query）、键（Key）和值（Value）"><a href="#2-计算查询（Query）、键（Key）和值（Value）" class="headerlink" title="2. 计算查询（Query）、键（Key）和值（Value）"></a>2. 计算查询（Query）、键（Key）和值（Value）</h3><p>首先，我们需要为每个输入向量计算查询（Query）、键（Key）和值（Value）向量。这是通过三个不同的线性变换完成的。假设 (W_Q)、(W_K) 和 (W_V) 分别是查询、键和值的权重矩阵，它们的形状都是 (d \times d_k)。</p>
<p>[ Q &#x3D; XW_Q ]<br>[ K &#x3D; XW_K ]<br>[ V &#x3D; XW_V ]</p>
<p>其中，(Q)、(K) 和 (V) 分别是查询、键和值的矩阵，它们的形状都是 (n \times d_k)。</p>
<h3 id="3-计算注意力分数（Attention-Scores）"><a href="#3-计算注意力分数（Attention-Scores）" class="headerlink" title="3. 计算注意力分数（Attention Scores）"></a>3. 计算注意力分数（Attention Scores）</h3><p>接下来，我们计算查询和键的点积来得到注意力分数。注意力分数表示每个词对其他词的重要性。</p>
<p>[ \text{scores} &#x3D; QK^T ]</p>
<p>这里，(\text{scores}) 的形状是 (n \times n)，表示每个词对其他所有词的注意力分数。</p>
<h3 id="4-生成注意力权重（Attention-Weights）"><a href="#4-生成注意力权重（Attention-Weights）" class="headerlink" title="4. 生成注意力权重（Attention Weights）"></a>4. 生成注意力权重（Attention Weights）</h3><p>为了使得注意力分数更稳定，我们会对其进行缩放，除以 (\sqrt{d_k})。接下来，应用softmax函数将注意力分数转化为注意力权重，这些权重表示每个词对其他词的注意力分配。</p>
<p>[ \text{scaled_scores} &#x3D; \frac{QK^T}{\sqrt{d_k}} ]<br>[ \text{weights} &#x3D; \text{softmax}(\text{scaled_scores}) ]</p>
<p>注意力权重矩阵 (\text{weights}) 的形状也是 (n \times n)。</p>
<h3 id="5-加权求和（Weighted-Sum）"><a href="#5-加权求和（Weighted-Sum）" class="headerlink" title="5. 加权求和（Weighted Sum）"></a>5. 加权求和（Weighted Sum）</h3><p>最后，使用注意力权重对值（Value）向量进行加权求和，得到最终的输出。</p>
<p>[ \text{output} &#x3D; \text{weights}V ]</p>
<p>输出矩阵 (\text{output}) 的形状是 (n \times d_k)。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>注意力机制的计算过程可以总结为以下几个步骤：</p>
<ol>
<li><p><strong>计算查询、键和值</strong>：<br>[ Q &#x3D; XW_Q, \quad K &#x3D; XW_K, \quad V &#x3D; XW_V ]</p>
</li>
<li><p><strong>计算注意力分数</strong>：<br>[ \text{scores} &#x3D; QK^T ]</p>
</li>
<li><p><strong>缩放注意力分数并应用softmax</strong>：<br>[ \text{scaled_scores} &#x3D; \frac{\text{scores}}{\sqrt{d_k}}, \quad \text{weights} &#x3D; \text{softmax}(\text{scaled_scores}) ]</p>
</li>
<li><p><strong>计算加权求和</strong>：<br>[ \text{output} &#x3D; \text{weights}V ]</p>
</li>
</ol>
<p>这个过程实现了从输入序列到输出序列的自适应权重计算，使得模型能够关注到输入序列中的重要部分。这种机制在各种任务（如机器翻译、文本生成、图像处理等）中都表现出了强大的性能。</p>
<h2 id="3-注意力机制的k-q相似度计算都有哪些方法，各自有什么优缺点"><a href="#3-注意力机制的k-q相似度计算都有哪些方法，各自有什么优缺点" class="headerlink" title="3.注意力机制的k,q相似度计算都有哪些方法，各自有什么优缺点"></a>3.注意力机制的k,q相似度计算都有哪些方法，各自有什么优缺点</h2><p>在注意力机制中，查询（Query，Q）和键（Key，K）之间的相似度计算是核心步骤，用于确定注意力权重。不同的相似度计算方法有不同的优缺点。以下是几种常见的方法及其优缺点：</p>
<h3 id="1-点积相似度（Dot-Product-Similarity）"><a href="#1-点积相似度（Dot-Product-Similarity）" class="headerlink" title="1. 点积相似度（Dot-Product Similarity）"></a>1. 点积相似度（Dot-Product Similarity）</h3><h4 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h4><p>[ \text{score}(Q, K) &#x3D; Q \cdot K^T ]</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li><strong>计算简单</strong>：点积相似度计算非常高效，尤其是在硬件加速（如GPU）上可以充分利用矩阵乘法的优化。</li>
<li><strong>常用方法</strong>：点积相似度是Transformer模型中的默认选择，被广泛使用和验证。</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li><strong>维度影响</strong>：随着向量维度增加，点积值可能会变得很大，导致softmax函数的梯度过小。为此，通常需要缩放因子（如 (\sqrt{d_k})）来稳定计算。</li>
</ul>
<h3 id="2-缩放点积相似度（Scaled-Dot-Product-Similarity）"><a href="#2-缩放点积相似度（Scaled-Dot-Product-Similarity）" class="headerlink" title="2. 缩放点积相似度（Scaled Dot-Product Similarity）"></a>2. 缩放点积相似度（Scaled Dot-Product Similarity）</h3><h4 id="计算方法-1"><a href="#计算方法-1" class="headerlink" title="计算方法"></a>计算方法</h4><p>[ \text{score}(Q, K) &#x3D; \frac{Q \cdot K^T}{\sqrt{d_k}} ]</p>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul>
<li><strong>稳定梯度</strong>：通过缩放因子 (\sqrt{d_k}) 减少了随着维度增加而导致的梯度消失问题。</li>
<li><strong>广泛应用</strong>：在Transformer模型中被默认使用，性能稳定。</li>
</ul>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li><strong>需要缩放</strong>：虽然解决了梯度问题，但增加了一步额外的缩放计算。</li>
</ul>
<h3 id="3-余弦相似度（Cosine-Similarity）"><a href="#3-余弦相似度（Cosine-Similarity）" class="headerlink" title="3. 余弦相似度（Cosine Similarity）"></a>3. 余弦相似度（Cosine Similarity）</h3><h4 id="计算方法-2"><a href="#计算方法-2" class="headerlink" title="计算方法"></a>计算方法</h4><p>[ \text{score}(Q, K) &#x3D; \frac{Q \cdot K^T}{|Q| |K|} ]</p>
<h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ul>
<li><strong>归一化相似度</strong>：将向量的相似度归一化到[-1, 1]之间，消除了向量长度对相似度的影响。</li>
<li><strong>可解释性强</strong>：余弦相似度在各种应用中都有较好的解释性。</li>
</ul>
<h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li><strong>计算复杂度</strong>：需要计算向量的范数，增加了计算复杂度。</li>
<li><strong>性能问题</strong>：在某些场景下，余弦相似度的效果可能不如点积相似度。</li>
</ul>
<h3 id="4-加性注意力（Additive-Attention-或-Bahdanau-Attention）"><a href="#4-加性注意力（Additive-Attention-或-Bahdanau-Attention）" class="headerlink" title="4. 加性注意力（Additive Attention 或 Bahdanau Attention）"></a>4. 加性注意力（Additive Attention 或 Bahdanau Attention）</h3><h4 id="计算方法-3"><a href="#计算方法-3" class="headerlink" title="计算方法"></a>计算方法</h4><p>[ \text{score}(Q, K) &#x3D; w^T \tanh(W_Q Q + W_K K + b) ]<br>其中，(w)、(W_Q)、(W_K) 和 (b) 是可训练的参数。</p>
<h4 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h4><ul>
<li><strong>灵活性高</strong>：通过可训练参数，可以更灵活地学习不同类型的相似度。</li>
<li><strong>广泛应用</strong>：特别是在早期的Seq2Seq模型中应用广泛。</li>
</ul>
<h4 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li><strong>计算开销大</strong>：涉及更多的参数和非线性操作（tanh），计算开销较大。</li>
<li><strong>复杂度高</strong>：相比点积相似度，计算更复杂。</li>
</ul>
<h3 id="5-高斯注意力（Gaussian-Attention）"><a href="#5-高斯注意力（Gaussian-Attention）" class="headerlink" title="5. 高斯注意力（Gaussian Attention）"></a>5. 高斯注意力（Gaussian Attention）</h3><h4 id="计算方法-4"><a href="#计算方法-4" class="headerlink" title="计算方法"></a>计算方法</h4><p>[ \text{score}(Q, K) &#x3D; \exp\left(-\frac{|Q - K|^2}{2\sigma^2}\right) ]</p>
<h4 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h4><ul>
<li><strong>平滑注意力分布</strong>：使用高斯函数计算相似度，可以产生更加平滑的注意力分布。</li>
<li><strong>与距离相关</strong>：自然地反映了向量之间的欧氏距离。</li>
</ul>
<h4 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li><strong>参数选择</strong>：需要选择合适的 (\sigma) 值，参数选择不当可能导致效果不佳。</li>
<li><strong>计算开销大</strong>：计算欧氏距离和指数函数增加了计算开销。</li>
</ul>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>每种相似度计算方法都有其特定的优缺点，选择哪种方法通常取决于具体应用场景和需求：</p>
<ul>
<li><strong>点积相似度和缩放点积相似度</strong>：计算简单高效，适用于大多数Transformer模型。</li>
<li><strong>余弦相似度</strong>：适用于需要归一化相似度的场景，但计算复杂度较高。</li>
<li><strong>加性注意力</strong>：灵活性高，但计算开销大，适用于需要灵活相似度计算的应用。</li>
<li><strong>高斯注意力</strong>：平滑分布和距离相关，但计算复杂度和参数选择是挑战。</li>
</ul>
<p>实际应用中，缩放点积相似度是最常用和有效的方法，尤其是在Transformer架构中。</p>
<h2 id="4-attention的计算中为什么要除以根号dk"><a href="#4-attention的计算中为什么要除以根号dk" class="headerlink" title="4.attention的计算中为什么要除以根号dk"></a>4.attention的计算中为什么要除以根号dk</h2><p>在注意力机制的计算中，将点积相似度除以 (\sqrt{d_k}) 是为了稳定计算过程，防止数值溢出。这一步骤通常称为<strong>缩放点积相似度</strong>（Scaled Dot-Product Attention）。以下是详细的原因和解释：</p>
<h3 id="原因和解释"><a href="#原因和解释" class="headerlink" title="原因和解释"></a>原因和解释</h3><h4 id="1-避免数值不稳定"><a href="#1-避免数值不稳定" class="headerlink" title="1. 避免数值不稳定"></a>1. 避免数值不稳定</h4><ul>
<li><p><strong>高维点积值过大</strong>：</p>
<ul>
<li>在高维空间中，向量的点积值随着维度的增加会变得很大。这是因为点积的结果是多个元素乘积的累加，维度越高，累加的值越大。假设两个向量 (Q) 和 (K) 的每个元素都是均值为零、方差为1的独立随机变量，那么它们的点积 (\sum_{i&#x3D;1}^{d_k} Q_i K_i) 的方差是 (d_k)。随着 (d_k) 增加，点积的值会越来越大。</li>
</ul>
</li>
<li><p><strong>softmax梯度消失</strong>：</p>
<ul>
<li>在计算注意力权重时，点积相似度值作为输入会被传递到softmax函数中。如果这些值很大，softmax函数的输出会变得极端，即接近0或1。这会导致梯度消失问题，使得模型在训练过程中难以有效更新参数。</li>
</ul>
</li>
</ul>
<h4 id="2-缩放稳定计算"><a href="#2-缩放稳定计算" class="headerlink" title="2. 缩放稳定计算"></a>2. 缩放稳定计算</h4><ul>
<li><strong>缩放因子 (\sqrt{d_k})</strong>：<ul>
<li>为了避免上述问题，我们在计算点积相似度后，除以 (\sqrt{d_k})。这一缩放因子将点积相似度值缩小到一个更合理的范围，防止值过大。</li>
<li>具体地，缩放后的值更接近于均值为0、方差为1的标准正态分布。这使得softmax函数的输入值不会太大，从而生成的注意力权重更加平滑，梯度更新也更稳定。</li>
</ul>
</li>
</ul>
<h3 id="数学解释"><a href="#数学解释" class="headerlink" title="数学解释"></a>数学解释</h3><p>假设 (Q) 和 (K) 是维度为 (d_k) 的向量：<br>[ \text{score}(Q, K) &#x3D; Q \cdot K^T &#x3D; \sum_{i&#x3D;1}^{d_k} Q_i K_i ]</p>
<p>如果 (Q_i) 和 (K_i) 的元素是均值为0、方差为1的随机变量，那么点积的结果的期望值为0，但方差为 (d_k)：<br>[ \text{Var}(Q \cdot K^T) &#x3D; d_k ]</p>
<p>为了使得点积相似度的方差不随 (d_k) 增加，我们将其除以 (\sqrt{d_k})：<br>[ \text{scaled_score}(Q, K) &#x3D; \frac{Q \cdot K^T}{\sqrt{d_k}} ]</p>
<p>这将点积的方差标准化为1，输入到softmax函数的值范围更加稳定。</p>
<h3 id="例子和效果"><a href="#例子和效果" class="headerlink" title="例子和效果"></a>例子和效果</h3><p>例如，在维度 (d_k &#x3D; 64) 的情况下，如果不进行缩放，点积的值可能会变得很大（例如，在0到64之间）。经过softmax后，权重会极端化，导致某些注意力权重接近1，而其他接近0。这种极端的权重分布会使模型的学习变得困难。而通过缩放因子 (\sqrt{64} &#x3D; 8)，点积值会被缩小到一个更合理的范围（例如，在0到8之间），使得softmax输出的权重更平滑，梯度更稳定。</p>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>将点积相似度除以 (\sqrt{d_k}) 的目的是为了：</p>
<ol>
<li>防止高维向量点积值过大导致的数值不稳定问题。</li>
<li>生成更平滑的注意力权重分布，避免softmax输出的极端化，稳定梯度更新过程。</li>
</ol>
<p>这一步骤是Transformer模型中的一个重要细节，确保了注意力机制在高维情况下的有效性和稳定性。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-06-27T06:53:24.000Z" title="2024/6/27 14:53:24">2024-06-27</time>发表</span><span class="level-item"><time dateTime="2024-06-27T07:01:43.404Z" title="2024/6/27 15:01:43">2024-06-27</time>更新</span><span class="level-item">19 分钟读完 (大约2890个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/06/27/%E9%9D%A2%E7%BB%8F/">面经</a></p><div class="content"><h2 id="1-Transformer模型的结构"><a href="#1-Transformer模型的结构" class="headerlink" title="1. Transformer模型的结构"></a>1. Transformer模型的结构</h2><p>Transformer模型是由Vaswani等人在2017年提出的一种深度学习模型，主要用于自然语言处理任务，如翻译、文本生成等。Transformer模型的核心架构由编码器（Encoder）和解码器（Decoder）组成。以下是Transformer模型的详细结构：</p>
<h3 id="1-编码器（Encoder）"><a href="#1-编码器（Encoder）" class="headerlink" title="1. 编码器（Encoder）"></a>1. 编码器（Encoder）</h3><p>编码器部分由N个相同的编码器层（Encoder Layer）堆叠而成。每个编码器层包括两个子层：</p>
<h4 id="a-多头自注意力机制（Multi-Head-Self-Attention-Mechanism）"><a href="#a-多头自注意力机制（Multi-Head-Self-Attention-Mechanism）" class="headerlink" title="a. 多头自注意力机制（Multi-Head Self-Attention Mechanism）"></a>a. 多头自注意力机制（Multi-Head Self-Attention Mechanism）</h4><ul>
<li><strong>输入</strong>：一组向量表示（如单词的词嵌入）。</li>
<li><strong>输出</strong>：对输入向量进行加权求和，以捕捉全局依赖关系。</li>
<li><strong>多头机制</strong>：通过多个注意力头（Attention Heads）来捕捉不同子空间的特征。</li>
</ul>
<h4 id="b-前馈神经网络（Feed-Forward-Neural-Network）"><a href="#b-前馈神经网络（Feed-Forward-Neural-Network）" class="headerlink" title="b. 前馈神经网络（Feed-Forward Neural Network）"></a>b. 前馈神经网络（Feed-Forward Neural Network）</h4><ul>
<li>包含两个线性变换层和一个激活函数（通常是ReLU）。</li>
<li><strong>输入</strong>：经过多头自注意力机制后的输出。</li>
<li><strong>输出</strong>：经过非线性变换后的表示。</li>
</ul>
<p>每个子层后都有一个残差连接（Residual Connection）和层归一化（Layer Normalization）。</p>
<h3 id="2-解码器（Decoder）"><a href="#2-解码器（Decoder）" class="headerlink" title="2. 解码器（Decoder）"></a>2. 解码器（Decoder）</h3><p>解码器部分也由N个相同的解码器层（Decoder Layer）堆叠而成。每个解码器层包括三个子层：</p>
<h4 id="a-多头自注意力机制（Masked-Multi-Head-Self-Attention-Mechanism）"><a href="#a-多头自注意力机制（Masked-Multi-Head-Self-Attention-Mechanism）" class="headerlink" title="a. 多头自注意力机制（Masked Multi-Head Self-Attention Mechanism）"></a>a. 多头自注意力机制（Masked Multi-Head Self-Attention Mechanism）</h4><ul>
<li>类似于编码器中的多头自注意力机制，但这里的自注意力是被掩盖的，以确保解码过程中当前词只能关注到之前的词。</li>
</ul>
<h4 id="b-编码器-解码器注意力机制（Encoder-Decoder-Attention-Mechanism）"><a href="#b-编码器-解码器注意力机制（Encoder-Decoder-Attention-Mechanism）" class="headerlink" title="b. 编码器-解码器注意力机制（Encoder-Decoder Attention Mechanism）"></a>b. 编码器-解码器注意力机制（Encoder-Decoder Attention Mechanism）</h4><ul>
<li><strong>输入</strong>：编码器的输出和解码器自注意力的输出。</li>
<li><strong>输出</strong>：结合编码器信息和当前解码步骤信息的表示。</li>
</ul>
<h4 id="c-前馈神经网络（Feed-Forward-Neural-Network）"><a href="#c-前馈神经网络（Feed-Forward-Neural-Network）" class="headerlink" title="c. 前馈神经网络（Feed-Forward Neural Network）"></a>c. 前馈神经网络（Feed-Forward Neural Network）</h4><ul>
<li>与编码器中的前馈神经网络类似。</li>
</ul>
<p>每个子层后也有残差连接和层归一化。</p>
<h3 id="3-位置编码（Positional-Encoding）"><a href="#3-位置编码（Positional-Encoding）" class="headerlink" title="3. 位置编码（Positional Encoding）"></a>3. 位置编码（Positional Encoding）</h3><p>由于Transformer没有卷积和循环结构，它使用位置编码来注入关于序列顺序的信息。这些位置编码是添加到输入向量中的。</p>
<h3 id="4-全局架构"><a href="#4-全局架构" class="headerlink" title="4. 全局架构"></a>4. 全局架构</h3><ul>
<li><strong>编码器</strong>：将输入序列编码为一组隐层表示。</li>
<li><strong>解码器</strong>：基于编码器的表示和之前生成的词，生成输出序列。</li>
</ul>
<h3 id="注意力机制（Attention-Mechanism）"><a href="#注意力机制（Attention-Mechanism）" class="headerlink" title="注意力机制（Attention Mechanism）"></a>注意力机制（Attention Mechanism）</h3><p>Transformer的核心是注意力机制，特别是自注意力机制。以下是其关键步骤：</p>
<ol>
<li><p><strong>计算注意力分数（Scores）</strong>：<br>[<br>\text{Attention}(Q, K, V) &#x3D; \text{softmax}\left(\frac{QK^T}{\sqrt{d_k}}\right) V<br>]<br>其中，( Q ) 是查询矩阵，( K ) 是键矩阵，( V ) 是值矩阵，( d_k ) 是键向量的维度。</p>
</li>
<li><p><strong>多头注意力（Multi-Head Attention）</strong>：<br>通过并行的多个注意力头来学习不同的特征表示：<br>[<br>\text{MultiHead}(Q, K, V) &#x3D; \text{Concat}(\text{head}_1, \text{head}_2, …, \text{head}_h) W^O<br>]<br>每个头的计算方法类似，但使用不同的参数。</p>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Transformer模型通过并行化的多头自注意力机制和前馈神经网络，极大地提高了序列到序列任务的效率和性能。它在许多自然语言处理任务中都取得了显著的成功，并成为了现代自然语言处理的基石。</p>
<h2 id="2-为什么要用-SwimTransformer-而不用cnn"><a href="#2-为什么要用-SwimTransformer-而不用cnn" class="headerlink" title="2. 为什么要用 SwimTransformer 而不用cnn"></a>2. 为什么要用 SwimTransformer 而不用cnn</h2><p>Swin Transformer 和 CNN（卷积神经网络）在架构和处理图像的方式上有显著的区别。以下是对这两者的详细比较以及Swin Transformer的优势：</p>
<h3 id="1-架构区别"><a href="#1-架构区别" class="headerlink" title="1. 架构区别"></a>1. 架构区别</h3><h4 id="CNN（卷积神经网络）"><a href="#CNN（卷积神经网络）" class="headerlink" title="CNN（卷积神经网络）"></a>CNN（卷积神经网络）</h4><ul>
<li><strong>基本单元</strong>：卷积层（Convolutional Layer），通过卷积核（filter）提取局部特征。</li>
<li><strong>特征提取方式</strong>：局部感受野（Local Receptive Field），在输入图像的局部区域内滑动卷积核进行特征提取。</li>
<li><strong>池化层（Pooling Layer）</strong>：用于下采样，减小特征图尺寸，通常使用最大池化（Max Pooling）或平均池化（Average Pooling）。</li>
<li><strong>层次结构</strong>：通常由多个卷积层、池化层和全连接层（Fully Connected Layer）堆叠而成。</li>
</ul>
<h4 id="Swin-Transformer（滑动窗口Transformer）"><a href="#Swin-Transformer（滑动窗口Transformer）" class="headerlink" title="Swin Transformer（滑动窗口Transformer）"></a>Swin Transformer（滑动窗口Transformer）</h4><ul>
<li><strong>基本单元</strong>：Transformer编码器层（Transformer Encoder Layer），采用自注意力机制（Self-Attention Mechanism）。</li>
<li><strong>特征提取方式</strong>：通过滑动窗口（Sliding Window）进行局部注意力计算，划分图像为不重叠的窗口，在每个窗口内计算自注意力。</li>
<li><strong>分层结构</strong>：包括多层Swin Transformer块，每个块包含局部注意力机制、跨窗口连接和前馈网络。</li>
<li><strong>多尺度表示</strong>：通过分层设计实现多尺度特征提取，类似于CNN中的层次结构，但更灵活。</li>
</ul>
<h3 id="2-优势比较"><a href="#2-优势比较" class="headerlink" title="2. 优势比较"></a>2. 优势比较</h3><h4 id="CNN-的优势"><a href="#CNN-的优势" class="headerlink" title="CNN 的优势"></a>CNN 的优势</h4><ol>
<li><strong>计算效率高</strong>：卷积操作在计算和内存上都非常高效，特别适合在图像处理中应用。</li>
<li><strong>局部特征提取</strong>：擅长提取局部特征，如边缘、纹理等，适用于大多数图像识别任务。</li>
<li><strong>结构简单</strong>：卷积层和池化层的设计简单明了，易于理解和实现。</li>
</ol>
<h4 id="Swin-Transformer-的优势"><a href="#Swin-Transformer-的优势" class="headerlink" title="Swin Transformer 的优势"></a>Swin Transformer 的优势</h4><ol>
<li><strong>全局建模能力</strong>：通过自注意力机制，能够在整个图像范围内建立全局上下文关系，而不仅仅局限于局部区域。</li>
<li><strong>灵活的窗口设计</strong>：滑动窗口机制结合了局部和全局特征提取的优势，通过窗口内和跨窗口的注意力计算，能够更好地捕捉多尺度信息。</li>
<li><strong>适应性强</strong>：可以通过改变窗口大小和层数，灵活调整模型以适应不同规模和复杂度的任务。</li>
<li><strong>统一架构</strong>：Transformer架构在自然语言处理和计算机视觉任务中的成功应用，表明其在处理不同类型数据上的强大适应性。</li>
</ol>
<h3 id="为什么使用-Swin-Transformer-而不是-CNN"><a href="#为什么使用-Swin-Transformer-而不是-CNN" class="headerlink" title="为什么使用 Swin Transformer 而不是 CNN"></a>为什么使用 Swin Transformer 而不是 CNN</h3><ol>
<li><strong>全局特征提取</strong>：Swin Transformer的自注意力机制可以在整个图像上建模长距离依赖关系，适合处理需要全局上下文信息的任务，如目标检测和语义分割。</li>
<li><strong>多尺度特征</strong>：通过滑动窗口和分层设计，Swin Transformer能够更好地捕捉不同尺度的特征，这在多尺度特征非常重要的任务中表现出色。</li>
<li><strong>灵活性和扩展性</strong>：Swin Transformer具有很强的灵活性，可以方便地扩展和调整以适应不同的任务和数据规模。而CNN的结构较为固定，适应性相对较差。</li>
<li><strong>一致性和统一性</strong>：Transformer在不同任务中的成功应用，使其成为一种通用的架构，便于在不同任务之间共享和转移学习，而不需要设计不同的模型。</li>
</ol>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>虽然CNN在计算效率和局部特征提取方面具有优势，但Swin Transformer通过结合自注意力机制和滑动窗口设计，实现了更强的全局建模能力和多尺度特征提取能力，适应性更强，尤其在处理复杂图像任务时表现出色。因此，在需要全局上下文信息和多尺度特征的任务中，使用Swin Transformer往往能够获得更好的效果。</p>
<h2 id="3-为什么transformer-需要mask（掩码）"><a href="#3-为什么transformer-需要mask（掩码）" class="headerlink" title="3.为什么transformer 需要mask（掩码）"></a>3.为什么transformer 需要mask（掩码）</h2><p>Transformer中的mask（掩码）在不同的阶段和子模块中有不同的用途，主要是为了控制注意力机制的范围和确保模型生成输出时的正确性。以下是Transformer中不同类型mask的详细说明及其原因：</p>
<h3 id="1-自注意力中的Mask（Self-Attention-Mask）"><a href="#1-自注意力中的Mask（Self-Attention-Mask）" class="headerlink" title="1. 自注意力中的Mask（Self-Attention Mask）"></a>1. 自注意力中的Mask（Self-Attention Mask）</h3><h4 id="a-Padding-Mask（填充掩码）"><a href="#a-Padding-Mask（填充掩码）" class="headerlink" title="a. Padding Mask（填充掩码）"></a>a. Padding Mask（填充掩码）</h4><ul>
<li><strong>用途</strong>：用于忽略填充部分的影响。</li>
<li><strong>位置</strong>：在输入序列中。</li>
<li><strong>原因</strong>：在处理变长序列时，输入序列通常被填充到相同长度。填充部分（通常是零）不应该影响注意力机制的计算，因此使用填充掩码来忽略这些位置。</li>
<li><strong>实现</strong>：将填充位置的注意力分数设为负无穷大，以确保softmax后的注意力权重为零。</li>
</ul>
<h4 id="b-Look-Ahead-Mask（前瞻掩码，也称为Causal-Mask-未来掩码）"><a href="#b-Look-Ahead-Mask（前瞻掩码，也称为Causal-Mask-未来掩码）" class="headerlink" title="b. Look-Ahead Mask（前瞻掩码，也称为Causal Mask&#x2F;未来掩码）"></a>b. Look-Ahead Mask（前瞻掩码，也称为Causal Mask&#x2F;未来掩码）</h4><ul>
<li><strong>用途</strong>：确保在解码阶段，每个位置只能看到当前及之前的位置，不能看到未来的位置。</li>
<li><strong>位置</strong>：在解码器中的自注意力层。</li>
<li><strong>原因</strong>：在序列生成任务中（如语言模型或翻译），当前步骤的输出不能依赖未来的输入，因此需要前瞻掩码来阻止模型在当前时间步关注到未来时间步的信息。</li>
<li><strong>实现</strong>：通过一个上三角矩阵来掩盖未来位置，将未来位置的注意力分数设为负无穷大。</li>
</ul>
<h3 id="2-编码器-解码器注意力中的Mask"><a href="#2-编码器-解码器注意力中的Mask" class="headerlink" title="2. 编码器-解码器注意力中的Mask"></a>2. 编码器-解码器注意力中的Mask</h3><h4 id="a-Padding-Mask"><a href="#a-Padding-Mask" class="headerlink" title="a. Padding Mask"></a>a. Padding Mask</h4><ul>
<li><strong>用途</strong>：在编码器-解码器注意力中，解码器需要关注编码器的输出，因此也需要忽略填充部分的影响。</li>
<li><strong>位置</strong>：在解码器的编码器-解码器注意力层。</li>
<li><strong>原因</strong>：类似于自注意力中的填充掩码，确保解码器不会在注意力计算中考虑编码器输出中的填充位置。</li>
<li><strong>实现</strong>：与自注意力中的填充掩码相同，将填充位置的注意力分数设为负无穷大。</li>
</ul>
<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><h4 id="为什么需要Mask？"><a href="#为什么需要Mask？" class="headerlink" title="为什么需要Mask？"></a>为什么需要Mask？</h4><ol>
<li><strong>处理变长输入</strong>：保证填充部分不会影响注意力机制的计算，确保模型只关注实际输入部分。</li>
<li><strong>保证因果性</strong>：在序列生成任务中，保证生成的每一步只依赖于当前及之前的信息，而不泄露未来的信息。</li>
<li><strong>提高模型性能</strong>：通过适当的掩码操作，可以提高模型训练的有效性和稳定性，避免无意义的注意力计算。</li>
</ol>
<h3 id="实际例子"><a href="#实际例子" class="headerlink" title="实际例子"></a>实际例子</h3><h4 id="自注意力中的Look-Ahead-Mask"><a href="#自注意力中的Look-Ahead-Mask" class="headerlink" title="自注意力中的Look-Ahead Mask"></a>自注意力中的Look-Ahead Mask</h4><p>假设我们有一个输入序列<code>[A, B, C, D]</code>，在生成时，模型不应该在生成<code>B</code>时看到<code>C</code>和<code>D</code>。</p>
<p>生成Look-Ahead Mask的矩阵如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line"> [0, -inf, -inf, -inf],</span><br><span class="line"> [0, 0, -inf, -inf],</span><br><span class="line"> [0, 0, 0, -inf],</span><br><span class="line"> [0, 0, 0, 0]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>在这个矩阵中，<code>0</code>表示可以关注，<code>-inf</code>表示掩盖。</p>
<h4 id="Padding-Mask"><a href="#Padding-Mask" class="headerlink" title="Padding Mask"></a>Padding Mask</h4><p>假设输入序列<code>[A, B, PAD, PAD]</code>，<code>PAD</code>表示填充位置。</p>
<p>生成的Padding Mask如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line"> [1, 1, 0, 0]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>在这个向量中，<code>1</code>表示实际输入位置，<code>0</code>表示填充位置。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>Mask在Transformer中起到了重要的作用，通过控制注意力机制的范围，确保模型在训练和推理过程中关注正确的信息，提高模型的性能和稳定性。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-06-13T12:15:51.000Z" title="2024/6/13 20:15:51">2024-06-13</time>发表</span><span class="level-item"><time dateTime="2024-06-13T12:16:38.964Z" title="2024/6/13 20:16:38">2024-06-13</time>更新</span><span class="level-item">2 小时读完 (大约19469个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/06/13/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/">算法总结</a></p><div class="content"><p>目录</p>
<p>一、基础算法	3</p>
<p>快速排序算法模板	3</p>
<p>归并排序算法模板	4</p>
<p>逆序对数量	5</p>
<p>整数二分算法模板	6</p>
<p>浮点数二分算法模板	7</p>
<p>高精度加法	7</p>
<p>高精度减法	8</p>
<p>高精度比大小（cmp函数）	8</p>
<p>高精度乘低精度	8</p>
<p>高精度乘高精度	9</p>
<p>高精度除低精度	9</p>
<p>高精度除高精度	10</p>
<p>一维前缀和	11</p>
<p>二维前缀和	11</p>
<p>一维差分	12</p>
<p>二维差分	13</p>
<p>位运算	14</p>
<p>双指针算法	14</p>
<p>离散化	14</p>
<p>区间合并	16</p>
<p>二、数据结构	17</p>
<p>单链表	17</p>
<p>双链表	18</p>
<p>栈	19</p>
<p>队列	20</p>
<p>循环队列	21</p>
<p>单调栈	22</p>
<p>单调队列	23</p>
<p>KMP字符串匹配	24</p>
<p>二叉树的存储与遍历	25</p>
<p>Trie树	28</p>
<p>并查集	29</p>
<p>堆	32</p>
<p>一般hash	33</p>
<p>字符串哈希	34</p>
<p>三、搜索与图论	37</p>
<p>树与图的存储	38</p>
<p>邻接矩阵	38</p>
<p>邻接表	38</p>
<p>树与图的遍历	38</p>
<p>应用：数字全排列	39</p>
<p>应用：树的重心	39</p>
<p>应用：n-皇后问题	41</p>
<p>宽度优先遍历	42</p>
<p>应用：走迷宫	42</p>
<p>应用：八数码	43</p>
<p>拓扑排序	44</p>
<p>Dijkstra算法	46</p>
<p>Bellman-Ford算法	49</p>
<p>SPFA算法（队列优化的Bellman-Ford算法）	52</p>
<p>floyd算法	55</p>
<p>最短路算法总结	57</p>
<p>prim算法	57</p>
<p>Kruskal算法	59</p>
<p>染色法判别二分图	62</p>
<p>匈牙利算法	64</p>
<p>四、数学知识	67</p>
<p>试除法判定质数	68</p>
<p>试除法分解质因数	68</p>
<p>埃氏筛法求质数	68</p>
<p>线性筛法求质数	69</p>
<p>试除法求所有约数	69</p>
<p>约数个数	69</p>
<p>约数之和	70</p>
<p>欧几里得算法(求最大公约数)	71</p>
<p>最小公倍数	72</p>
<p>求欧拉函数	72</p>
<p>线性筛法求欧拉函数	73</p>
<p>快速幂	74</p>
<p>扩展欧几里得算法	74</p>
<p>中国剩余定理	75</p>
<p>扩展中国剩余定理	76</p>
<p>高斯消元法	76</p>
<p>求组合数	79</p>
<p>Lucas定理求组合数	81</p>
<p>分解质因数法求组合数	83</p>
<p>容斥原理应用	87</p>
<p>博弈论	88</p>
<p>五、动态规划	91</p>
<p>闫式dp分析法.jpg	91</p>
<p>背包问题	91</p>
<p>区间DP	100</p>
<p>计数类DP	102</p>
<p>数位统计DP	102</p>
<p>状态压缩DP	104</p>
<p>树形DP	106</p>
<p>记忆化搜索	108</p>
<p>六、贪心	109</p>
<p>区间问题	109</p>
<p>区间选点	109</p>
<p>区间分组	111</p>
<p>排序不等式	112</p>
<p>排队打水	112</p>
<h2 id="一、基础算法"><a href="#一、基础算法" class="headerlink" title="一、基础算法"></a>一、基础算法</h2><h3 id="快速排序算法模板"><a href="#快速排序算法模板" class="headerlink" title="快速排序算法模板"></a>快速排序算法模板</h3><p>void quick_sort(int q[], int l, int r)</p>
<p>{</p>
<pre><code>//递归的终止情况

if (l &gt;= r) return;



 //选取分界线。这里选数组中间那个数

int i = l - 1, j = r + 1, x = q[l + r &gt;&gt; 1];

//划分成左右两个部分

while (i &lt; j)

&#123;

    do i ++ ; while (q[i] &lt; x);

    do j -- ; while (q[j] &gt; x);

    if (i &lt; j) swap(q[i], q[j]);

&#125;

//对左右部分排序

quick_sort(q, l, j), quick_sort(q, j + 1, r);
</code></pre>
<p>}</p>
<p>边界问题：因为边界问题只有这两种组合，不能随意搭配</p>
<p>1.x不能取q[l]和q[l+r&gt;&gt;1];</p>
<p>quick_sort(q,l,i-1),quick_sort(q,i,r);</p>
<p>2.x不能取q[r]和q[(l+r+1)&gt;&gt;1];</p>
<p>quick_sort(q,l,j),quick_sort(q,j+1,r);</p>
<h3 id="归并排序算法模板"><a href="#归并排序算法模板" class="headerlink" title="归并排序算法模板"></a>归并排序算法模板</h3><p>void merge_sort(int q[], int l, int r)</p>
<p>{</p>
<pre><code>//递归的终止情况

if (l &gt;= r) return;

//第一步：分成子问题

int mid = l + r &gt;&gt; 1;

//第二步：递归处理子问题

merge_sort(q, l, mid);

merge_sort(q, mid + 1, r);



//第三步：合并子问题

int k = 0, i = l, j = mid + 1;

while (i &lt;= mid &amp;&amp; j &lt;= r)

    if (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];

    else tmp[k ++ ] = q[j ++ ];



while (i &lt;= mid) tmp[k ++ ] = q[i ++ ];

while (j &lt;= r) tmp[k ++ ] = q[j ++ ];

//第四步：复制回原数组

for (i = l, j = 0; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];
</code></pre>
<p>}</p>
<h3 id="逆序对数量"><a href="#逆序对数量" class="headerlink" title="逆序对数量"></a>逆序对数量</h3><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。</p>
<p>思路：归并排序</p>
<p>举个例子：</p>
<p>在合并 {4 ,5} {1 , 2} 的时候，首先我们判断 1 &lt; 4，我们即可统计出逆序对为2，为什么呢？这利用了数组的部分有序性。因为我们知道 {4 ,5} 这个数组必然是有序的，因为是合并上来的。此时当 1比4小的时候，证明4以后的数也都比1大，此时就构成了从4开始到 {4,5}这个数组结束，这么多个逆序对（2个），此时利用一个临时数组，将1存放起来，接着比较2和4的大小，同样可以得到有2个逆序对，于是将2也放进临时数组中，此时右边数组已经完全没有元素了，则将左边剩余的元素全部放进临时元素中，最后将临时数组中的元素放进原数组对应的位置。</p>
<p>最后接着向上合并~</p>
<p>逆序对数量.png</p>
<p>归并排序求逆序对.gif</p>
<p>using namespace std;</p>
<p>typedef long long  LL;</p>
<p>const int N &#x3D; 100010;</p>
<p>int n;</p>
<p>int q[N], tmp[N];</p>
<p>LL merge_sort(int l, int r) {</p>
<pre><code>if (l &gt;= r)return 0;

int mid = (l + r) &gt;&gt; 1;

LL res = merge_sort(l, mid) + merge_sort(mid + 1, r);

// 归并的过程

int k = 0, i = l, j = mid + 1;

while (i &lt;= mid &amp;&amp; j &lt;= r)

    if (q[i] &lt;= q[j])tmp[k++] = q[i++];

    else &#123;

        tmp[k++] = q[j++];

        res += mid - i + 1;

    &#125;

//扫尾

while (i &lt;= mid)tmp[k++] = q[i++];

while (j &lt;= r)tmp[k++] = q[j++];

//物归原主

for (i = l, j = 0; i &lt;= r; j++, i++)q[i] = tmp[j];

return res;
</code></pre>
<p>}</p>
<p>int main() {</p>
<pre><code>cin &gt;&gt; n;

for (int i = 0; i &lt; n; i++)cin &gt;&gt; q[i];

cout &lt;&lt; merge_sort(0, n - 1) &lt;&lt; endl;

return 0;
</code></pre>
<p>}</p>
<h3 id="整数二分算法模板"><a href="#整数二分算法模板" class="headerlink" title="整数二分算法模板"></a>整数二分算法模板</h3><p>对lower_bound来说，它寻找的就是第一个满足条件“值大于等于x”的元素的位置；对upper_bound函数来说，它寻找的是第一个满足“值大于 x”的元素的位置。</p>
<p>bool check(int x) {&#x2F;* … *&#x2F;} &#x2F;&#x2F; 检查x是否满足某种性质</p>
<p>&#x2F;&#x2F; 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</p>
<p>int bsearch_1(int l, int r)</p>
<p>{</p>
<pre><code>while (l &lt; r)

&#123;

    int mid = l + r &gt;&gt; 1;

    if (check(mid)) r = mid;    // check()判断mid是否满足性质

    else l = mid + 1;//左加右减

&#125;

return l;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</p>
<p>int bsearch_2(int l, int r)</p>
<p>{</p>
<pre><code>while (l &lt; r)

&#123;

    int mid = l + r + 1 &gt;&gt; 1;//如果下方else后面是l则这里加1

    if (check(mid)) l = mid;

    else r = mid - 1;//左加右减

&#125;

return l;
</code></pre>
<p>}</p>
<h3 id="浮点数二分算法模板"><a href="#浮点数二分算法模板" class="headerlink" title="浮点数二分算法模板"></a>浮点数二分算法模板</h3><p>bool check(double x) {&#x2F;* … *&#x2F;} &#x2F;&#x2F; 检查x是否满足某种性质</p>
<p>double bsearch_3(double l, double r)</p>
<p>{</p>
<pre><code>const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求

while (r - l &gt; eps)

&#123;

    double mid = (l + r) / 2;

    if (check(mid)) r = mid;

    else l = mid;

&#125;

return l;
</code></pre>
<p>}</p>
<h3 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h3><p>&#x2F;&#x2F; C &#x3D; A + B, A &gt;&#x3D; 0, B &gt;&#x3D; 0</p>
<p>vector<int> add(vector<int> &amp;a,vector<int> &amp;b){</p>
<pre><code>//c为答案

vector&lt;int&gt; c;

//t为进位

int t=0;

for(int i=0;i&lt;a.size()||i&lt;b.size();i++)&#123;

    //不超过a的范围添加a[i]

    if(i&lt;a.size())t+=a[i];

    //不超过b的范围添加b[i]

    if(i&lt;b.size())t+=b[i];

    //取当前位的答案

    c.push_back(t%10);

    //是否进位

    t/=10;

&#125;

//如果t!=0的话向后添加1

if(t)c.push_back(1);

return c;
</code></pre>
<p>}</p>
<h3 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h3><p>&#x2F;&#x2F; C &#x3D; A - B, 满足A &gt;&#x3D; B, A &gt;&#x3D; 0, B &gt;&#x3D; 0</p>
<p>vector<int> sub(vector<int> &amp;A, vector<int> &amp;B)</p>
<p>{</p>
<pre><code>//答案

vector&lt;int&gt; C;

//遍历最大的数

for (int i = 0, t = 0; i &lt; A.size(); i ++ )

&#123;

    //t为进位

    t = A[i] - t;

    //不超过B的范围t=A[i]-B[i]-t;

    if (i &lt; B.size()) t -= B[i];

    //合二为一，取当前位的答案

    C.push_back((t + 10) % 10);

    //t&lt;0则t=1

    if (t &lt; 0) t = 1;

    //t&gt;=0则t=0

    else t = 0;

&#125;

//去除前导零

while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();

return C;
</code></pre>
<p>}</p>
<h3 id="高精度比大小（cmp函数）"><a href="#高精度比大小（cmp函数）" class="headerlink" title="高精度比大小（cmp函数）"></a>高精度比大小（cmp函数）</h3><p>&#x2F;&#x2F;高精度比大小</p>
<p>bool cmp(vector<int> &amp;A, vector<int> &amp;B) {</p>
<pre><code>if (A.size() != B.size())

    return A.size() &gt; B.size();

for (int i = A.size() - 1; i &gt;= 0; i -- )

    if (A[i] != B[i])

        return A[i] &gt; B[i];

return true;
</code></pre>
<p>}</p>
<h3 id="高精度乘低精度"><a href="#高精度乘低精度" class="headerlink" title="高精度乘低精度"></a>高精度乘低精度</h3><p>&#x2F;&#x2F; C &#x3D; A * b, A &gt;&#x3D; 0, b &gt;&#x3D; 0</p>
<p>vector<int> mul(vector<int> &amp;A, int b)</p>
<p>{</p>
<pre><code>//类似于高精度加法

vector&lt;int&gt; C;

//t为进位

int t = 0;

for (int i = 0; i &lt; A.size() || t; i ++ )

&#123;

    //不超过A的范围t=t+A[i]*b

    if (i &lt; A.size()) t += A[i] * b;

    //取当前位的答案

    C.push_back(t % 10);

    //进位

    t /= 10;

&#125;

//去除前导零

while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();



return C;
</code></pre>
<p>}</p>
<h3 id="高精度乘高精度"><a href="#高精度乘高精度" class="headerlink" title="高精度乘高精度"></a>高精度乘高精度</h3><p><strong>高精度加减乘除</strong>：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1LA411v7mt/">https://www.bilibili.com/video/BV1LA411v7mt/</a></p>
<p>vector<int> mul(vector<int> &amp;A, vector<int> &amp;B) {</p>
<pre><code>vector&lt;int&gt; C(A.size() + B.size()); // 初始化为 0，C的size可以大一点



for (int i = 0; i &lt; A.size(); i++)

    for (int j = 0; j &lt; B.size(); j++)

        C[i + j] += A[i] * B[j];

for (int i = 0, t = 0; i &lt; C.size(); i++) &#123; // i = C.size() - 1时 t 一定小于 10

    t += C[i];

    C[i] = t % 10;

    t /= 10;

&#125;



while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); // 必须要去前导 0，因为最高位很可能是 0

return C;
</code></pre>
<p>}</p>
<h3 id="高精度除低精度"><a href="#高精度除低精度" class="headerlink" title="高精度除低精度"></a>高精度除低精度</h3><p>&#x2F;&#x2F; A &#x2F; b &#x3D; C … r, A &gt;&#x3D; 0, b &gt; 0</p>
<p>vector<int> div(vector<int> &amp;A, int b, int &amp;r)&#x2F;&#x2F;高精度A，低精度b，余数r</p>
<p>{</p>
<pre><code>vector&lt;int&gt; C;//答案

r = 0;

for (int i = A.size() - 1; i &gt;= 0; i -- )

&#123;

    r = r * 10 + A[i];//补全r&gt;=b

    C.push_back(r / b);//取当前位的答案

    r %= b;//r%b为下一次计算

&#125;

reverse(C.begin(), C.end());//倒序为答案

while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();//去除前导零

return C;
</code></pre>
<p>}</p>
<h3 id="高精度除高精度"><a href="#高精度除高精度" class="headerlink" title="高精度除高精度"></a>高精度除高精度</h3><p><strong>高精度加减乘除</strong>：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1LA411v7mt/">https://www.bilibili.com/video/BV1LA411v7mt/</a></p>
<p>vector<int> div(vector<int> &amp;A, vector<int> &amp;B, vector<int> &amp;r) {</p>
<pre><code>vector&lt;int&gt; C;

if (!cmp(A, B)) &#123;

    C.push_back(0);

    r.assign(A.begin(), A.end());

    return C;

&#125;

int j = B.size();

r.assign(A.end() - j, A.end());

while (j &lt;= A.size()) &#123;

    int k = 0;

    while (cmp(r, B)) &#123;

        r = sub(r, B);

        k ++;

    &#125;

    C.push_back(k);

    if (j &lt; A.size())

        r.insert(r.begin(), A[A.size() - j - 1]);

    if (r.size() &gt; 1 &amp;&amp; r.back() == 0)

        r.pop_back();

    j++;

&#125;

reverse(C.begin(), C.end());

while (C.size() &gt; 1 &amp;&amp; C.back() == 0)

    C.pop_back();

return C;
</code></pre>
<p>}</p>
<h3 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h3><p>前缀和可以用于快速计算一个序列的区间和，也有很多问题里不是直接用前缀和，但是借用了前缀和的思想。</p>
<p>预处理:s[i]&#x3D;a[i]+a[i-1]</p>
<p>求区间[l,r]:sum&#x3D;s[r]-s[l-1]</p>
<p>“前缀和数组”和”原数组”可以合二为一</p>
<p>应用</p>
<p>const int N&#x3D;100010;</p>
<p>int a[N];</p>
<p>int main(){</p>
<pre><code>int n,m;

scanf(&quot;%d&quot;,&amp;n);

for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]);

for(int i=1;i&lt;=n;i++)a[i]=a[i-1]+a[i];

scanf(&quot;%d&quot;,&amp;m);

while(m--)&#123;

    int l,r;

    scanf(&quot;%d%d&quot;,&amp;l,&amp;r);

    printf(&quot;%d\n&quot;,a[r]-a[l-1]);

&#125;

return 0;
</code></pre>
<p>}</p>
<h3 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h3><p>计算矩阵的前缀和：s[x][y] &#x3D; s[x - 1][y] + s[x][y -1] - s[x-1][y-1] + a[x][y]</p>
<p>以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：</p>
<p>计算子矩阵的和：s &#x3D; s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 -1]</p>
<p>应用</p>
<p>int s[1010][1010];</p>
<p>int n,m,q;</p>
<p>int main(){</p>
<pre><code>scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;q);

for(int i=1;i&lt;=n;i++)

    for(int j=1;j&lt;=m;j++)

        scanf(&quot;%d&quot;,&amp;s[i][j]);

for(int i=1;i&lt;=n;i++)

    for(int j=1;j&lt;=m;j++)

        s[i][j]+=s[i-1][j]+s[i][j-1]-s[i-1][j-1];

while(q--)&#123;

    int x1,y1,x2,y2;

    scanf(&quot;%d%d%d%d&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2);

    printf(&quot;%d\n&quot;,s[x2][y2]-s[x2][y1-1]-s[x1-1][y2]+s[x1-1][y1-1]);

&#125;

return 0;
</code></pre>
<p>}</p>
<h3 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h3><p>差分是前缀和的逆运算，对于一个数组a，其差分数组b的每一项都是a [ i ]和前一项a [ i − 1 ]的差。</p>
<p>注意：差分数组和原数组必须分开存放！！！！</p>
<p>给区间[l, r]中的每个数加上c：B[l] +&#x3D; c, B[r + 1] -&#x3D; c</p>
<p>应用</p>
<p>using namespace std;</p>
<p>int a[100010],s[100010];</p>
<p>int main(){</p>
<pre><code>int n,m;

cin&gt;&gt;n&gt;&gt;m;

for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i];   

for(int i=1;i&lt;=n;i++)s[i]=a[i]-a[i-1];// 读入并计算差分数组

while(m--)&#123;

    int l,r,c;

    cin&gt;&gt;l&gt;&gt;r&gt;&gt;c;

    s[l]+=c;

    s[r+1]-=c;// 在原数组中将区间[l, r]加上c

&#125;

for(int i=1;i&lt;=n;i++)&#123;

    s[i]+=s[i-1];

    cout&lt;&lt;s[i]&lt;&lt;&#39; &#39;;

&#125;// 给差分数组计算前缀和，就求出了原数组

return 0;
</code></pre>
<p>}</p>
<h3 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h3><p>给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：</p>
<p>S[x1, y1] +&#x3D; c, S[x2 + 1, y1] -&#x3D; c, S[x1, y2 + 1] -&#x3D; c, S[x2 + 1, y2 + 1] +&#x3D; c</p>
<p>应用</p>
<p>const int N &#x3D; 1e3 + 10;</p>
<p>int a[N][N], b[N][N];</p>
<p>void insert(int x1, int y1, int x2, int y2, int c)</p>
<p>{</p>
<pre><code>b[x1][y1] += c;

b[x2 + 1][y1] -= c;

b[x1][y2 + 1] -= c;

b[x2 + 1][y2 + 1] += c;
</code></pre>
<p>}</p>
<p>int main()</p>
<p>{</p>
<pre><code>int n, m, q;

cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;

for (int i = 1; i &lt;= n; i++)

    for (int j = 1; j &lt;= m; j++)

        cin &gt;&gt; a[i][j];

for (int i = 1; i &lt;= n; i++)

&#123;

    for (int j = 1; j &lt;= m; j++)

    &#123;

        insert(i, j, i, j, a[i][j]);      //构建差分数组

    &#125;

&#125;

while (q--)

&#123;

    int x1, y1, x2, y2, c;

    cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c;

    insert(x1, y1, x2, y2, c);//加c

&#125;

for (int i = 1; i &lt;= n; i++)

&#123;

    for (int j = 1; j &lt;= m; j++)

    &#123;

        b[i][j] += b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1];  //二维前缀和

    &#125;

&#125;

for (int i = 1; i &lt;= n; i++)

&#123;

    for (int j = 1; j &lt;= m; j++)

    &#123;

        printf(&quot;%d &quot;, b[i][j]);

    &#125;

    printf(&quot;\n&quot;);

&#125;

return 0;
</code></pre>
<p>}</p>
<p>关于前缀和与差分的相关博客链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39757593/article/details/129219491">https://blog.csdn.net/qq_39757593/article/details/129219491</a></p>
<h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>求n的第k位数字: n &gt;&gt; k &amp; 1</p>
<p>返回n的最后一位1：lowbit(n) &#x3D; n &amp; -n</p>
<h3 id="双指针算法"><a href="#双指针算法" class="headerlink" title="双指针算法"></a>双指针算法</h3><p>for (int i &#x3D; 0, j &#x3D; 0; i &lt; n; i ++ )</p>
<p>{</p>
<pre><code>while (j &lt; i &amp;&amp; check(i, j)) j ++ ;

// 具体问题的逻辑
</code></pre>
<p>}</p>
<p>常见问题分类：</p>
<pre><code>(1) 对于一个序列，用两个指针维护一段区间

(2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作
</code></pre>
<h3 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h3><p>离散化的本质是建立了一段数列到自然数之间的映射关系（value -&gt; index)，通过建立新索引，来缩小目标区间，使得可以进行一系列连续数组可以进行的操作比如二分，前缀和等…</p>
<p>离散化首先需要排序去重：</p>
<p>1.排序：sort(alls.begin(),alls.end())</p>
<p>2.去重：alls.earse(unique(alls.begin(),alls.end()),alls.end());</p>
<p>vector<int> alls; &#x2F;&#x2F; 存储所有待离散化的值</p>
<p>sort(alls.begin(), alls.end()); &#x2F;&#x2F; 将所有值排序</p>
<p>alls.erase(unique(alls.begin(), alls.end()), alls.end());   &#x2F;&#x2F; 去掉重复元素</p>
<p>&#x2F;&#x2F; 二分求出x对应的离散化的值</p>
<p>int find(int x) &#x2F;&#x2F; 找到第一个大于等于x的位置</p>
<p>{</p>
<pre><code>int l = 0, r = alls.size() - 1;

while (l &lt; r)

&#123;

    int mid = l + r &gt;&gt; 1;

    if (alls[mid] &gt;= x) r = mid;

    else l = mid + 1;

&#125;

return r + 1; // 映射到1, 2, ...n
</code></pre>
<p>}</p>
<p>应用</p>
<p>typedef pair&lt;int, int&gt; PII;</p>
<p>const int N &#x3D; 300010;</p>
<p>int n, m;</p>
<p>int a[N], s[N];</p>
<p>vector<int> alls;&#x2F;&#x2F;存入下标容器</p>
<p>vector<PII> add, query;&#x2F;&#x2F;add增加容器，存入对应下标和增加的值的大小</p>
<p>&#x2F;&#x2F;query存入需要计算下标区间和的容器</p>
<p>int find(int x)</p>
<p>{</p>
<pre><code>int l = 0, r = alls.size() - 1;

while (l &lt; r)//查找大于等于x的最小的值的下标

&#123;

    int mid = l + r &gt;&gt; 1;

    if (alls[mid] &gt;= x) r = mid;

    else l = mid + 1;

&#125;

return r + 1;//因为使用前缀和，其下标要+1可以不考虑边界问题
</code></pre>
<p>}</p>
<p>int main()</p>
<p>{</p>
<pre><code>cin &gt;&gt; n &gt;&gt; m;

for (int i = 0; i &lt; n; i ++ )

&#123;

    int x, c;

    cin &gt;&gt; x &gt;&gt; c;

    add.push_back(&#123;x, c&#125;);//存入下标即对应的数值c



    alls.push_back(x);//存入数组下标x=add.first

&#125;



for (int i = 0; i &lt; m; i ++ )

&#123;

    int l, r;

    cin &gt;&gt; l &gt;&gt; r;

    query.push_back(&#123;l, r&#125;);//存入要求的区间



    alls.push_back(l);//存入区间左右下标

    alls.push_back(r);

&#125;



// 区间去重

sort(alls.begin(), alls.end());

alls.erase(unique(alls.begin(), alls.end()), alls.end());



// 处理插入

for (auto item : add)

&#123;

    int x = find(item.first);//将add容器的add.secend值存入数组a[]当中，

    a[x] += item.second;//在去重之后的下标集合alls内寻找对应的下标并添加数值

&#125;



// 预处理前缀和

for (int i = 1; i &lt;= alls.size(); i ++ ) s[i] = s[i - 1] + a[i];



// 处理询问

for (auto item : query)

&#123;

    int l = find(item.first), r = find(item.second);//在下标容器中查找对应的左右两端[l~r]下标，然后通过下标得到前缀和相减再得到区间a[l~r]的和

    cout &lt;&lt; s[r] - s[l - 1] &lt;&lt; endl;

&#125;



return 0;
</code></pre>
<p>}</p>
<h3 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h3><p>&#x2F;&#x2F; 将所有存在交集的区间合并</p>
<p>void merge(vector<PII> &amp;segs)</p>
<p>{</p>
<pre><code>vector&lt;PII&gt; res;



sort(segs.begin(), segs.end());



int st = -2e9, ed = -2e9;

for (auto seg : segs)

    if (ed &lt; seg.first)

    &#123;

        if (st != -2e9) res.push_back(&#123;st, ed&#125;);

        st = seg.first, ed = seg.second;

    &#125;

    else ed = max(ed, seg.second);



if (st != -2e9) res.push_back(&#123;st, ed&#125;);



segs = res;
</code></pre>
<p>}</p>
<h2 id="二、数据结构"><a href="#二、数据结构" class="headerlink" title="二、数据结构"></a>二、数据结构</h2><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>const int N&#x3D;100010;</p>
<p>int head,e[N],ne[N],idx;</p>
<p>&#x2F;&#x2F;初始化</p>
<p>void init(){</p>
<pre><code>head=-1;

idx=0;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F;在链表头部添加节点</p>
<p>void add_to_head(int x){</p>
<pre><code>e[idx]=x,ne[idx]=head,head=idx++;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F;在位置k添加节点x</p>
<p>void add(int k,int x){</p>
<pre><code>e[idx]=x,ne[idx]=ne[k],ne[k]=idx++;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F;删除位置k的节点</p>
<p>void remove(int k){</p>
<pre><code>ne[k]=ne[ne[k]];
</code></pre>
<p>}</p>
<p>应用</p>
<p>int main(){</p>
<pre><code>int m;

init();

cin&gt;&gt;m;

while(m--)&#123;

    int k,x;

    char op;

    cin&gt;&gt;op;

    if(op==&#39;H&#39;)&#123;

        cin&gt;&gt;x;

        add_to_head(x);

    &#125;else if(op==&#39;D&#39;)&#123;

        cin&gt;&gt;k;

        if(!k)head=ne[head];

        remove(k-1);

    &#125;else &#123;

        cin&gt;&gt;k&gt;&gt;x;

        add(k-1,x);

    &#125;

&#125;

for(int i=head;i!=-1;i=ne[i])cout&lt;&lt;e[i]&lt;&lt;&#39; &#39;;

cout&lt;&lt;endl;

return 0;
</code></pre>
<p>}</p>
<h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><p>const int N&#x3D;100010;</p>
<p>int e[N],l[N],r[N],idx;</p>
<p>&#x2F;&#x2F;初始化</p>
<p>void init(){</p>
<pre><code>l[1]=0;

r[0]=1;

idx=2;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F;在节点a的右边插入一个数x</p>
<p>void insert(int a,int x){</p>
<pre><code>e[idx]=x;

l[idx]=a,r[idx]=r[a];

l[r[a]]=idx,r[a]=idx++;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F;删除节点a</p>
<p>void remove(int a){</p>
<pre><code>l[r[a]]=l[a];

r[l[a]]=r[a];
</code></pre>
<p>}</p>
<p>应用</p>
<p>int main(){</p>
<pre><code>int m;

cin&gt;&gt;m;

init();

while(m--)&#123;

    string op;

    cin&gt;&gt;op;

    int k,x;

    if(op==&quot;L&quot;)&#123;//在最左端插入数x

        cin&gt;&gt;x;

        insert(0,x);

    &#125;else if(op==&quot;R&quot;)&#123;//在最右端插入数x

        cin&gt;&gt;x;

        insert(l[1],x);

    &#125;else if(op==&quot;D&quot;)&#123;//删除第k个插入的数

        cin&gt;&gt;k;

        remove(k+1);

    &#125;else if(op==&quot;IL&quot;)&#123;//在第k个位置的左侧插入一个数

        cin&gt;&gt;k&gt;&gt;x;

        insert(l[k+1],x);

    &#125;else if(op==&quot;LR&quot;)&#123;//在第k个位置的右侧插入一个数

        cin&gt;&gt;k&gt;&gt;x;

        insert(k+1,x);

    &#125;

&#125;

for(int i=r[0];i!=1;i=r[i])printf(&quot;%d &quot;,e[i]);

cout&lt;&lt;endl;

return 0;
</code></pre>
<p>}</p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>&#x2F;&#x2F; tt表示栈顶</p>
<p>int stk[N], tt &#x3D; 0;</p>
<p>&#x2F;&#x2F; 向栈顶插入一个数</p>
<p>stk[ ++ tt] &#x3D; x;</p>
<p>&#x2F;&#x2F; 从栈顶弹出一个数</p>
<p>tt – ;</p>
<p>&#x2F;&#x2F; 栈顶的值</p>
<p>stk[tt];</p>
<p>&#x2F;&#x2F; 判断栈是否为空，如果 tt &gt; 0，则表示不为空</p>
<p>if (tt &gt; 0)</p>
<p>{</p>
<p>}</p>
<p>应用</p>
<p>const int N&#x3D;100010;</p>
<p>int stk[N],tt;</p>
<p>int main(){</p>
<pre><code>int m;

cin&gt;&gt;m;

while(m--)&#123;

    string op;

    int x;

    cin&gt;&gt;op;

    if(op==&quot;push&quot;)&#123;

        cin&gt;&gt;x;

        stk[tt++]=x;

    &#125;else if(op==&quot;pop&quot;)&#123;

        tt--;

    &#125;else if(op==&quot;query&quot;)&#123;

        cout&lt;&lt;stk[tt-1]&lt;&lt;endl;

    &#125;else&#123;

        if(!tt)cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;

        else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;

    &#125;

&#125;

return 0;
</code></pre>
<p>}</p>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>普通队列</p>
<p>&#x2F;&#x2F; hh 表示队头，tt表示队尾</p>
<p>int q[N], hh &#x3D; 0, tt &#x3D; -1;</p>
<p>&#x2F;&#x2F; 向队尾插入一个数</p>
<p>q[ ++ tt] &#x3D; x;</p>
<p>&#x2F;&#x2F; 从队头弹出一个数</p>
<p>hh ++ ;</p>
<p>&#x2F;&#x2F; 队头的值</p>
<p>q[hh];</p>
<p>&#x2F;&#x2F; 判断队列是否为空，如果 hh &lt;&#x3D; tt，则表示不为空</p>
<p>if (hh &lt;&#x3D; tt)</p>
<p>{</p>
<p>}</p>
<p>应用</p>
<p>int const N&#x3D;100010;</p>
<p>int que[N],hh,tt&#x3D;-1;</p>
<p>int main(){</p>
<pre><code>int m;

cin&gt;&gt;m;

while(m--)&#123;

    string op;

    int x;

    cin&gt;&gt;op;

    if(op==&quot;push&quot;)&#123;

        cin&gt;&gt;x;

        que[++tt]=x;

    &#125;else if(op==&quot;query&quot;)&#123;

        cout&lt;&lt;que[hh]&lt;&lt;endl;

    &#125;else if(op==&quot;pop&quot;)&#123;

        hh++;

    &#125;else&#123;

        if(hh&gt;tt)cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;

        else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;

    &#125;

&#125;

return 0;
</code></pre>
<p>}</p>
<h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>&#x2F;&#x2F; hh 表示队头，tt表示队尾的后一个位置</p>
<p>int q[N], hh &#x3D; 0, tt &#x3D; 0;</p>
<p>&#x2F;&#x2F; 向队尾插入一个数</p>
<p>q[tt ++ ] &#x3D; x;</p>
<p>if (tt &#x3D;&#x3D; N) tt &#x3D; 0;</p>
<p>&#x2F;&#x2F; 从队头弹出一个数</p>
<p>hh ++ ;</p>
<p>if (hh &#x3D;&#x3D; N) hh &#x3D; 0;</p>
<p>&#x2F;&#x2F; 队头的值</p>
<p>q[hh];</p>
<p>&#x2F;&#x2F; 判断队列是否为空，如果hh !&#x3D; tt，则表示不为空</p>
<p>if (hh !&#x3D; tt)</p>
<p>{</p>
<p>}</p>
<h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p>常见模型：找出每个数左边离它最近的比它大&#x2F;小的数</p>
<p>int tt &#x3D; 0;</p>
<p>for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )</p>
<p>{</p>
<pre><code>while (tt &amp;&amp; check(stk[tt], i)) tt -- ;

stk[ ++ tt] = i;
</code></pre>
<p>}</p>
<p>应用</p>
<p>找出每个数左边离它最近的比它大&#x2F;小的数</p>
<p>stack<int> stk;</p>
<p>int main(){</p>
<pre><code>int n;

cin &gt;&gt; n;

stk.push(-1);

for (int i = 0; i &lt; n; i ++)&#123;

    int x; 

    cin &gt;&gt; x;

    while (stk.size() &amp;&amp; stk.top() &gt;= x) stk.pop();

    cout &lt;&lt; stk.top() &lt;&lt; &quot; &quot;;

    stk.push(x);

&#125;

return 0;
</code></pre>
<p>}</p>
<h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><p>常见模型：找出滑动窗口中的最大值&#x2F;最小值</p>
<p>int hh &#x3D; 0, tt &#x3D; -1;</p>
<p>for (int i &#x3D; 0; i &lt; n; i ++ )</p>
<p>{</p>
<pre><code>while (hh &lt;= tt &amp;&amp; check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口

while (hh &lt;= tt &amp;&amp; check(q[tt], i)) tt -- ;

q[ ++ tt] = i;
</code></pre>
<p>}</p>
<p>const int N &#x3D; 1000010;</p>
<p>int a[N];</p>
<p>int main()</p>
<p>{</p>
<pre><code>int n, k;

cin &gt;&gt; n &gt;&gt; k;

for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; a[i];//读入数据

deque&lt;int&gt; q;

for(int i = 1; i &lt;= n; i++)

&#123;

    while(q.size() &amp;&amp; q.back() &gt; a[i]) //新进入窗口的值小于队尾元素，则队尾出队列

        q.pop_back();

    q.push_back(a[i]);//将新进入的元素入队

    if(i - k &gt;= 1 &amp;&amp; q.front() == a[i - k])//若队头是否滑出了窗口，队头出队 

        q.pop_front();

    if(i &gt;= k)//当窗口形成，输出队头对应的值

        cout &lt;&lt; q.front() &lt;&lt;&quot; &quot;;

&#125;

q.clear();

cout &lt;&lt; endl;



//最大值亦然

for(int i = 1; i &lt;= n; i++)

&#123;

    while(q.size() &amp;&amp; q.back() &lt; a[i]) q.pop_back();

    q.push_back(a[i]);

    if(i - k &gt;= 1 &amp;&amp; a[i - k] == q.front()) q.pop_front(); 

    if(i &gt;= k) cout &lt;&lt; q.front() &lt;&lt; &quot; &quot;;



&#125;
</code></pre>
<p>}</p>
<h3 id="KMP字符串匹配"><a href="#KMP字符串匹配" class="headerlink" title="KMP字符串匹配"></a>KMP字符串匹配</h3><p>视频讲解：[最浅显易懂的 KMP 算法讲解_哔哩哔哩_bilibili]：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1AY4y157yL">https://www.bilibili.com/video/BV1AY4y157yL</a></p>
<p>下标从1开始的kmp算法</p>
<p>const int N &#x3D; 100010, M &#x3D; 1000010;</p>
<p>int n, m;</p>
<p>int ne[N];</p>
<p>char s[M], p[N];</p>
<p>int main()</p>
<p>{</p>
<pre><code>cin &gt;&gt; n &gt;&gt; p + 1 &gt;&gt; m &gt;&gt; s + 1;

for (int i = 2, j = 0; i &lt;= n; i ++ )

&#123;

    while (j &amp;&amp; p[i] != p[j + 1]) j = ne[j];

    if (p[i] == p[j + 1]) j ++ ;

    ne[i] = j;

&#125;//处理ne数组

for (int i = 1, j = 0; i &lt;= m; i ++ )

&#123;

    while (j &amp;&amp; s[i] != p[j + 1]) j = ne[j];

    if (s[i] == p[j + 1]) j ++ ;

    if (j == n)

    &#123;

        printf(&quot;%d &quot;, i - n);

        j = ne[j];

    &#125;

&#125;//匹配算法

return 0;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; s[]是长文本，p[]是模式串，n是s的长度，m是p的长度</p>
<p>求模式串的Next数组：</p>
<p>for (int i &#x3D; 2, j &#x3D; 0; i &lt;&#x3D; m; i ++ )</p>
<p>{</p>
<pre><code>while (j &amp;&amp; p[i] != p[j + 1]) j = ne[j];

if (p[i] == p[j + 1]) j ++ ;

ne[i] = j;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; 匹配</p>
<p>for (int i &#x3D; 1, j &#x3D; 0; i &lt;&#x3D; n; i ++ )</p>
<p>{</p>
<pre><code>while (j &amp;&amp; s[i] != p[j + 1]) j = ne[j];

if (s[i] == p[j + 1]) j ++ ;

if (j == m)

&#123;

    j = ne[j];

    // 匹配成功后的逻辑

&#125;
</code></pre>
<p>}</p>
<p>下标从0开始的kmp算法</p>
<p>const int N &#x3D; 1000010;</p>
<p>int n, m;</p>
<p>char s[N], p[N];</p>
<p>int ne[N];</p>
<p>int main()</p>
<p>{</p>
<pre><code>cin &gt;&gt; m &gt;&gt; p &gt;&gt; n &gt;&gt; s;

ne[0] = -1;

for (int i = 1, j = -1; i &lt; m; i ++ )

&#123;

    while (j &gt;= 0 &amp;&amp; p[j + 1] != p[i]) j = ne[j];

    if (p[j + 1] == p[i]) j ++ ;

    ne[i] = j;

&#125;

for (int i = 0, j = -1; i &lt; n; i ++ )

&#123;

    while (j != -1 &amp;&amp; s[i] != p[j + 1]) j = ne[j];

    if (s[i] == p[j + 1]) j ++ ;

    if (j == m - 1)

    &#123;

        cout &lt;&lt; i - j &lt;&lt; &#39; &#39;;

        j = ne[j];

    &#125;

&#125;

return 0;
</code></pre>
<p>}</p>
<h3 id="二叉树的存储与遍历"><a href="#二叉树的存储与遍历" class="headerlink" title="二叉树的存储与遍历"></a>二叉树的存储与遍历</h3><p>const int N &#x3D; 1e6 + 10;</p>
<p>&#x2F;&#x2F; 二叉树的存储,l数组为左节点,r数组为右结点</p>
<p>int l[N], r[N];</p>
<p>&#x2F;&#x2F; 存储节点的数据</p>
<p>char w[N];</p>
<p>&#x2F;&#x2F; 节点的下标指针</p>
<p>int idx &#x3D; 0;</p>
<p>&#x2F;&#x2F; 先序创建</p>
<p>int pre_create(int n) {</p>
<pre><code>cin &gt;&gt; w[n];

if (w[n] == &#39;#&#39;) return -1;

l[n] = pre_create(++idx);

r[n] = pre_create(++idx);

return n;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; 中序创建</p>
<p>int in_create(int n) {</p>
<pre><code>if (w[n] == &#39;#&#39;) return -1;

l[n] = in_create(++idx);

cin &gt;&gt; w[n];

r[n] = in_create(++idx);

return n;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; 后序创建</p>
<p>int back_create(int n) {</p>
<pre><code>if (w[n] == &#39;#&#39;) return -1;

l[n] = back_create(++idx);

r[n] = back_create(++idx);

cin &gt;&gt; w[n];

return n;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; 先序遍历</p>
<p>void pre_print(int n){</p>
<pre><code>if (w[n] != &#39;#&#39;) cout &lt;&lt; w[n] &lt;&lt; &#39; &#39;;

if (l[n] &gt; 0) pre_print(l[n]);

if (r[n] &gt; 0) pre_print(r[n]);
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; 中序遍历</p>
<p>void in_print(int n){</p>
<pre><code>if (l[n] &gt; 0) in_print(l[n]);

if (w[n] != &#39;#&#39;) cout &lt;&lt; w[n] &lt;&lt; &#39; &#39;;

if (r[n] &gt; 0) in_print(r[n]);
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; 后序遍历</p>
<p>void back_print(int n){</p>
<pre><code>if (l[n] &gt; 0) back_print(l[n]);

if (r[n] &gt; 0) back_print(r[n]);

if (w[n] != &#39;#&#39;) cout &lt;&lt; w[n] &lt;&lt; &#39; &#39;;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; 层序遍历</p>
<p>void bfs(int root){</p>
<pre><code>queue&lt;int&gt; que;

que.push(root);

while (!que.empty()) &#123;

    int t = que.front();

    cout &lt;&lt; w[t] &lt;&lt; &#39; &#39;;

    que.pop();

    if (l[t] &gt; 0 &amp;&amp; w[l[t]] != &#39;#&#39;)

        que.push(l[t]);

    if (r[t] &gt; 0 &amp;&amp; w[r[t]] != &#39;#&#39;)

        que.push(r[t]);

&#125;
</code></pre>
<p>}</p>
<p>应用</p>
<p>int main(){</p>
<pre><code>// 先序创建

pre_create(++idx);

// 中序创建

// in_create(++idx);

// 后序创建

// back_create(++idx);

// 先序遍历

pre_print(1);

// 中序遍历

in_print(1);

// 后序遍历

back_print(1);

// 层序遍历

bfs(1);

// 测试数据abc##de#g##f###

// 输出如下：

// a b c d e g f 

// c b e g d f a 

// c g e f d b a 

// a b c d e f g 

return 0;
</code></pre>
<p>}</p>
<h3 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h3><p>Trie 树是一种多叉树的结构，每个节点保存一个字符，一条路径表示一个字符串。</p>
<p>相关链接：<a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/27771/">https://www.acwing.com/solution/content/27771/</a></p>
<p>int son[N][26], cnt[N], idx;</p>
<p>&#x2F;&#x2F; 0号点既是根节点，又是空节点</p>
<p>&#x2F;&#x2F; son[][]存储树中每个节点的子节点</p>
<p>&#x2F;&#x2F; cnt[]存储以每个节点结尾的单词数量</p>
<p>&#x2F;&#x2F; 插入一个字符串</p>
<p>void insert(char *str)</p>
<p>{</p>
<pre><code>int p = 0;

for (int i = 0; str[i]; i ++ )

&#123;

    int u = str[i] - &#39;a&#39;;

    if (!son[p][u]) son[p][u] = ++ idx;

    p = son[p][u];

&#125;

cnt[p] ++ ;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; 查询字符串出现的次数</p>
<p>int query(char *str)</p>
<p>{</p>
<pre><code>int p = 0;

for (int i = 0; str[i]; i ++ )

&#123;

    int u = str[i] - &#39;a&#39;;

    if (!son[p][u]) return 0;

    p = son[p][u];

&#125;

return cnt[p];
</code></pre>
<p>}</p>
<p>const int N &#x3D; 100010;</p>
<p>int son[N][26], cnt[N], idx;</p>
<p>char str[N];</p>
<p>void insert(char *str)</p>
<p>{</p>
<pre><code>int p = 0;

for (int i = 0; str[i]; i ++ )

&#123;

    int u = str[i] - &#39;a&#39;;

    if (!son[p][u]) son[p][u] = ++ idx;

    p = son[p][u];

&#125;

cnt[p] ++ ;
</code></pre>
<p>}&#x2F;&#x2F;插入</p>
<p>int query(char *str)</p>
<p>{</p>
<pre><code>int p = 0;

for (int i = 0; str[i]; i ++ )

&#123;

    int u = str[i] - &#39;a&#39;;

    if (!son[p][u]) return 0;

    p = son[p][u];

&#125;

return cnt[p];
</code></pre>
<p>}&#x2F;&#x2F;查询</p>
<p>int main()</p>
<p>{</p>
<pre><code>int n;

scanf(&quot;%d&quot;, &amp;n);

while (n -- )

&#123;

    char op[2];

    scanf(&quot;%s%s&quot;, op, str);

    if (*op == &#39;I&#39;) insert(str);

    else printf(&quot;%d\n&quot;, query(str));

&#125;



return 0;
</code></pre>
<p>}</p>
<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>(1)朴素并查集：</p>
<pre><code>int p[N]; //存储每个点的祖宗节点



// 返回x的祖宗节点

int find(int x)

&#123;

    if (p[x] != x) p[x] = find(p[x]);

    return p[x];

&#125;



// 初始化，假定节点编号是1~n

for (int i = 1; i &lt;= n; i ++ ) p[i] = i;



// 合并a和b所在的两个集合：

p[find(a)] = find(b);
</code></pre>
<p>(2)维护size的并查集：</p>
<pre><code>int p[N], size[N];

//p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量



// 返回x的祖宗节点

int find(int x)

&#123;

    if (p[x] != x) p[x] = find(p[x]);

    return p[x];

&#125;



// 初始化，假定节点编号是1~n

for (int i = 1; i &lt;= n; i ++ )

&#123;

    p[i] = i;

    size[i] = 1;

&#125;



// 合并a和b所在的两个集合：

size[find(b)] += size[find(a)];

p[find(a)] = find(b);
</code></pre>
<p>(3)维护到祖宗节点距离的并查集：</p>
<pre><code>int p[N], d[N];

//p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离



// 返回x的祖宗节点

int find(int x)

&#123;

    if (p[x] != x)

    &#123;

        int u = find(p[x]);

        d[x] += d[p[x]];

        p[x] = u;

    &#125;

    return p[x];

&#125;



// 初始化，假定节点编号是1~n

for (int i = 1; i &lt;= n; i ++ )

&#123;

    p[i] = i;

    d[i] = 0;

&#125;



// 合并a和b所在的两个集合：

p[find(a)] = find(b);

d[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量
</code></pre>
<p>应用</p>
<p>const int N&#x3D;100010;</p>
<p>int p[N],n,m;</p>
<p>int find(int x){&#x2F;&#x2F;找到祖宗节点+路径压缩</p>
<pre><code>if(p[x]!=x)p[x]=find(p[x]);

return p[x];
</code></pre>
<p>}</p>
<p>int main(){</p>
<pre><code>scanf(&quot;%d%d&quot;,&amp;n,&amp;m);

for(int i=1;i&lt;=n;i++)p[i]=i;

while(m--)&#123;

    char op[2];

    int a,b;

    scanf(&quot;%s%d%d&quot;,op,&amp;a,&amp;b);

    if(op[0]==&#39;M&#39;)p[find(a)]=find(b);

    else &#123;

        if(find(a)==find(b))puts(&quot;Yes&quot;);

        else puts(&quot;No&quot;);

    &#125;

&#125;

return 0;
</code></pre>
<p>}</p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>&#x2F;&#x2F; h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1</p>
<p>&#x2F;&#x2F; ph[k]存储第k个插入的点在堆中的位置</p>
<p>&#x2F;&#x2F; hp[k]存储堆中下标是k的点是第几个插入的</p>
<p>int h[N], ph[N], hp[N], size;</p>
<p>&#x2F;&#x2F; 交换两个点，及其映射关系</p>
<p>void heap_swap(int a, int b)</p>
<p>{</p>
<pre><code>swap(ph[hp[a]],ph[hp[b]]);

swap(hp[a], hp[b]);

swap(h[a], h[b]);
</code></pre>
<p>}</p>
<p>void down(int u)</p>
<p>{</p>
<pre><code>int t = u;

if (u * 2 &lt;= size &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2;

if (u * 2 + 1 &lt;= size &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1;

if (u != t)

&#123;

    heap_swap(u, t);

    down(t);

&#125;
</code></pre>
<p>}</p>
<p>void up(int u)</p>
<p>{</p>
<pre><code>while (u / 2 &amp;&amp; h[u] &lt; h[u / 2])

&#123;

    heap_swap(u, u / 2);

    u &gt;&gt;= 1;

&#125;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; O(n)建堆</p>
<p>for (int i &#x3D; n &#x2F; 2; i; i – ) down(i);</p>
<p>应用：堆排序</p>
<p>const int N&#x3D;100010;</p>
<p>int heap[N],cnt;</p>
<p>void down(int u){</p>
<pre><code>int t=u;

if(u*2&lt;=cnt&amp;&amp;heap[u*2]&lt;=heap[t])t=u*2;

if(u*2+1&lt;=cnt&amp;&amp;heap[u*2+1]&lt;=heap[t])t=u*2+1;

if(t!=u)&#123;

    swap(heap[t],heap[u]);

    down(t);

&#125;
</code></pre>
<p>}&#x2F;&#x2F;down操作</p>
<p>void up(int u){</p>
<pre><code>while(u/2&amp;&amp;heap[u/2]&gt;heap[u])&#123;

    swap(heap[u/2],heap[u]);

    u&gt;&gt;=1;

&#125;
</code></pre>
<p>}&#x2F;&#x2F;up操作</p>
<p>int main(){</p>
<pre><code>int n,m;

scanf(&quot;%d%d&quot;,&amp;n,&amp;m);

for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;heap[i]);

cnt=n;

for(int i=n/2;i;i--)down(i);

while(m--)&#123;

    printf(&quot;%d &quot;,heap[1]);

    heap[1]=heap[cnt--];

    down(1);

&#125;

return 0;
</code></pre>
<p>}</p>
<h3 id="一般hash"><a href="#一般hash" class="headerlink" title="一般hash"></a>一般hash</h3><p>(1) 拉链法</p>
<pre><code>int h[N], e[N], ne[N], idx;



// 向哈希表中插入一个数

void insert(int x)

&#123;

    int k = (x % N + N) % N;

    e[idx] = x;

    ne[idx] = h[k];

    h[k] = idx ++ ;

&#125;



// 在哈希表中查询某个数是否存在

bool find(int x)

&#123;

    int k = (x % N + N) % N;

    for (int i = h[k]; i != -1; i = ne[i])

        if (e[i] == x)

            return true;



    return false;

&#125;
</code></pre>
<p>(2) 开放寻址法</p>
<pre><code>int h[N];



// 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置

int find(int x)

&#123;

    int t = (x % N + N) % N;

    while (h[t] != null &amp;&amp; h[t] != x)

    &#123;

        t ++ ;

        if (t == N) t = 0;

    &#125;

    return t;

&#125;
</code></pre>
<h3 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h3><p>核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低</p>
<p>小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果</p>
<p>typedef unsigned long long ULL;</p>
<p>ULL h[N], p[N]; &#x2F;&#x2F; h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64</p>
<p>&#x2F;&#x2F; 初始化</p>
<p>p[0] &#x3D; 1;</p>
<p>for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )</p>
<p>{</p>
<pre><code>h[i] = h[i - 1] * P + str[i];

p[i] = p[i - 1] * P;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; 计算子串 str[l ~ r] 的哈希值</p>
<p>ULL get(int l, int r)</p>
<p>{</p>
<pre><code>return h[r] - h[l - 1] * p[r - l + 1];
</code></pre>
<p>}</p>
<h3 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h3><p>STL容器.png</p>
<p>视频讲解：[100 STL 容器_哔哩哔哩_bilibili]：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1tF411G73c/">https://www.bilibili.com/video/BV1tF411G73c/</a></p>
<p>vector, 变长数组，倍增的思想</p>
<pre><code>size()  返回元素个数

empty()  返回是否为空

clear()  清空

front()/back()

push_back()/pop_back()

begin()/end()

[]

支持比较运算，按字典序
</code></pre>
<p>pair&lt;int, int&gt;</p>
<pre><code>first, 第一个元素

second, 第二个元素

支持比较运算，以first为第一关键字，以second为第二关键字（字典序）
</code></pre>
<p>string，字符串</p>
<pre><code>size()/length()  返回字符串长度

empty()

clear()

substr(起始下标，(子串长度))  返回子串

c_str()  返回字符串所在字符数组的起始地址
</code></pre>
<p>queue, 队列</p>
<pre><code>size()

empty()

push()  向队尾插入一个元素

front()  返回队头元素

back()  返回队尾元素

pop()  弹出队头元素
</code></pre>
<p>priority_queue, 优先队列，默认是大根堆</p>
<pre><code>size()

empty()

push()  插入一个元素

top()  返回堆顶元素

pop()  弹出堆顶元素

定义成小根堆的方式：priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;
</code></pre>
<p>stack, 栈</p>
<pre><code>size()

empty()

push()  向栈顶插入一个元素

top()  返回栈顶元素

pop()  弹出栈顶元素
</code></pre>
<p>deque, 双端队列</p>
<pre><code>size()

empty()

clear()

front()/back()

push_back()/pop_back()

push_front()/pop_front()

begin()/end()

[]
</code></pre>
<p>set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列</p>
<pre><code>size()

empty()

clear()

begin()/end()

++, -- 返回前驱和后继，时间复杂度 O(logn)



set/multiset

    insert()  插入一个数

    find()  查找一个数

    count()  返回某一个数的个数

    erase()

        (1) 输入是一个数x，删除所有x   O(k + logn)

        (2) 输入一个迭代器，删除这个迭代器

    lower_bound()/upper_bound()

        lower_bound(x)  返回大于等于x的最小的数的迭代器

        upper_bound(x)  返回大于x的最小的数的迭代器

map/multimap

    insert()  插入的数是一个pair

    erase()  输入的参数是pair或者迭代器

    find()

    []  注意multimap不支持此操作。 时间复杂度是 O(logn)

    lower_bound()/upper_bound()
</code></pre>
<p>unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表</p>
<pre><code>和上面类似，增删改查的时间复杂度是 O(1)

不支持 lower_bound()/upper_bound()， 迭代器的++，--
</code></pre>
<p>bitset, 圧位</p>
<pre><code>bitset&lt;10000&gt; s;

~, &amp;, |, ^

&gt;&gt;, &lt;&lt;

==, !=

[]



count()  返回有多少个1



any()  判断是否至少有一个1

none()  判断是否全为0



set()  把所有位置成1

set(k, v)  将第k位变成v

reset()  把所有位变成0

flip()  等价于~

flip(k) 把第k位取反
</code></pre>
<h2 id="三、搜索与图论"><a href="#三、搜索与图论" class="headerlink" title="三、搜索与图论"></a>三、搜索与图论</h2><h3 id="树与图的存储"><a href="#树与图的存储" class="headerlink" title="树与图的存储"></a>树与图的存储</h3><p>树是一种特殊的图，与图的存储方式相同。</p>
<p>对于无向图中的边ab，存储两条有向边a-&gt;b, b-&gt;a。</p>
<p>因此我们可以只考虑有向图的存储。</p>
<h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>邻接矩阵：g[a][b] 存储边a-&gt;b的距离</p>
<h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>&#x2F;&#x2F; 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点</p>
<p>int h[N], e[N], ne[N], idx;</p>
<p>&#x2F;&#x2F; 添加一条边a-&gt;b </p>
<p>void add(int a, int b)</p>
<p>{</p>
<pre><code>//存下b的值，b下一个指向a的下个一节点，a的下一个节点指向b

e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; 初始化</p>
<p>idx &#x3D; 0;</p>
<p>memset(h, -1, sizeof h);</p>
<h3 id="树与图的遍历"><a href="#树与图的遍历" class="headerlink" title="树与图的遍历"></a>树与图的遍历</h3><p>时间复杂度O(n+m)，n表示点数，m表示边数</p>
<p>深度优先遍历</p>
<p>int dfs(int u)</p>
<p>{</p>
<pre><code>st[u] = true; // st[u] 表示点u已经被遍历过



for (int i = h[u]; i != -1; i = ne[i])

&#123;

    int j = e[i];

    if (!st[j]) dfs(j);

&#125;
</code></pre>
<p>}</p>
<h3 id="应用：数字全排列"><a href="#应用：数字全排列" class="headerlink" title="应用：数字全排列"></a>应用：数字全排列</h3><p>#include <iostream></p>
<p>using namespace std;</p>
<p>int res[10],b[10],n;</p>
<p>void dfs(int k){</p>
<pre><code>if(k==n)&#123;//k==n则输出n个数字

    for(int i=0;i&lt;n;i++)printf(&quot;%d &quot;,res[i]);

    cout&lt;&lt;endl;

&#125;

for(int i=1;i&lt;=n;i++)&#123;

    if(!b[i])&#123;//判断是否被用过

        res[k]=i;//当前k位存入位置

        b[i]=1;//表示被占用

        dfs(k+1);

        b[i]=0;//恢复现场

    &#125;

&#125;
</code></pre>
<p>}</p>
<p>int main(){</p>
<pre><code>cin&gt;&gt;n;

dfs(0);//从0开始枚举

return 0;
</code></pre>
<p>}</p>
<h3 id="应用：树的重心"><a href="#应用：树的重心" class="headerlink" title="应用：树的重心"></a>应用：树的重心</h3><p>#include <cstdio></p>
<p>#include <cstring></p>
<p>#include <iostream></p>
<p>#include <algorithm></p>
<p>using namespace std;</p>
<p>const int N &#x3D; 100010, M &#x3D; N * 2;&#x2F;&#x2F;无向图n条边时，最多2n个idx，因为每条边在邻接表中会出现两次</p>
<p>int n;&#x2F;&#x2F;n个结点,n-1条边</p>
<p>int h[N], e[M], ne[M], idx;&#x2F;&#x2F;n个链表头，e每一个结点的值，ne每一个结点的next指针</p>
<p>int ans &#x3D; N;&#x2F;&#x2F;最小的最大值</p>
<p>bool st[N];&#x2F;&#x2F;状态数组，防止子节点搜索父节点</p>
<p>void add(int a, int b)&#x2F;&#x2F;a-&gt;b</p>
<p>{&#x2F;&#x2F;e记录当前点的值(地址-&gt;值),ne下一点的地址(地址-&gt;地址)，h记录指向的第一个点的地址(值-&gt;地址)</p>
<pre><code>e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
</code></pre>
<p>}&#x2F;&#x2F;头插法</p>
<p>int dfs(int u)&#x2F;&#x2F;通过h数组找到子结点的向</p>
<p>{</p>
<pre><code>st[u] = true;//st标记当前点被搜过



int size = 0, sum = 0;

//size删掉元素后各个子连通块的最大值

//sum当前子树大小，遍历叶节点时，返回1



for (int i = h[u]; i != -1; i = ne[i])//遍历单链表，链表末端初始化为-1

&#123;

    int j=e[i];

    if(st[j])continue;//此处防逆向dfs

    int s = dfs(j);//s各个子连通块的大小

    size = max(size, s);//size删掉元素后各个连通块的最大值

    sum += s;//各个连通块大小之和

&#125;



size = max(size, n - sum - 1);//判断最大子连通块与父连通块的最大值

ans = min(ans, size);//全局变量ans存最小的最大值
</code></pre>
<p>&#x2F;&#x2F;注意：本题若求最大的最大值，则只需去除任意叶节点即可，即n-1</p>
<pre><code>return sum + 1;//各个子连通块，当前结点之和
</code></pre>
<p>}</p>
<p>int main()</p>
<p>{</p>
<pre><code>scanf(&quot;%d&quot;, &amp;n);



memset(h, -1, sizeof h);//n个头节点全部指向-1



for (int i = 0; i &lt; n - 1; i ++ )//n个结点，n-1条边

&#123;

    int a, b;

    scanf(&quot;%d%d&quot;, &amp;a, &amp;b);

    add(a, b), add(b, a);//不知道子节点还是父节点，所以需要建两条边可以双向查找

&#125;



dfs(1);//结点编号为1~n且可能只有一个结点，则参数只能为1

printf(&quot;%d\n&quot;, ans);

return 0;
</code></pre>
<p>}</p>
<h3 id="应用：n-皇后问题"><a href="#应用：n-皇后问题" class="headerlink" title="应用：n-皇后问题"></a>应用：n-皇后问题</h3><p>n皇后搜索图示</p>
<p>using namespace std;</p>
<p>const int N &#x3D; 11;</p>
<p>char q[N][N];&#x2F;&#x2F;存储棋盘</p>
<p>bool dg[N * 2], udg[N * 2], cor[N];&#x2F;&#x2F;点对应的两个斜线以及列上是否有皇后</p>
<p>int n;</p>
<p>void dfs(int r)</p>
<p>{</p>
<pre><code>if(r == n)//放满了棋盘，输出棋盘

&#123;

    for(int i = 0; i &lt; n; i++)

    &#123;

        for(int j = 0; j &lt; n; j++)

            cout &lt;&lt; q[i][j];

        cout &lt;&lt; endl;

    &#125;

    cout &lt;&lt; endl;

    return;

&#125;



for(int i = 0; i &lt; n; i++)//第 r 行，第 i 列 是否放皇后

&#123;

    if(!cor[i] &amp;&amp; !dg[i + r] &amp;&amp; !udg[n - i + r])//不冲突，放皇后

    &#123;

        q[r][i] = &#39;Q&#39;;

        cor[i] = dg[i + r] = udg[n - i + r] = 1;//对应的 列， 斜线 状态改变

        dfs(r + 1);//处理下一行

        cor[i] = dg[i + r] = udg[n - i + r] = 0;//恢复现场

        q[r][i] = &#39;.&#39;;

    &#125;

&#125;
</code></pre>
<p>}</p>
<p>int main()</p>
<p>{</p>
<pre><code>cin &gt;&gt; n;

for (int i = 0; i &lt; n; i ++ )

    for (int j = 0; j &lt; n; j ++ )

        q[i][j] = &#39;.&#39;;

dfs(0);

return 0;
</code></pre>
<p>}</p>
<h3 id="宽度优先遍历"><a href="#宽度优先遍历" class="headerlink" title="宽度优先遍历"></a>宽度优先遍历</h3><p>queue<int> q;</p>
<p>st[1] &#x3D; true; &#x2F;&#x2F; 表示1号点已经被遍历过</p>
<p>q.push(1);</p>
<p>while (q.size())</p>
<p>{</p>
<pre><code>int t = q.front();

q.pop();



for (int i = h[t]; i != -1; i = ne[i])

&#123;

    int j = e[i];

    if (!st[j])

    &#123;

        st[j] = true; // 表示点j已经被遍历过

        q.push(j);

    &#125;

&#125;
</code></pre>
<p>}</p>
<h3 id="应用：走迷宫"><a href="#应用：走迷宫" class="headerlink" title="应用：走迷宫"></a>应用：走迷宫</h3><p>typedef pair&lt;int,int&gt; PII;&#x2F;&#x2F;声明pair时候必须要在代码前面写上using namespace std;</p>
<p>const int N&#x3D;110;</p>
<p>int g[N][N],f[N][N],n,m;</p>
<p>int bfs(int x,int y){</p>
<pre><code>queue&lt;PII&gt; que;

que.push(&#123;x,y&#125;);

int dx[4]=&#123;0,1,0,-1&#125;,dy[4]=&#123;1,0,-1,0&#125;;

while(!que.empty())&#123;

    PII t=que.front();

    que.pop();

    g[t.first][t.second]=1;

    for(int i=0;i&lt;4;i++)&#123;

        int a=t.first+dx[i],b=t.second+dy[i];

        if(a&gt;=0&amp;&amp;b&gt;=0&amp;&amp;a&lt;n&amp;&amp;b&lt;m&amp;&amp;!g[a][b])&#123;

            g[a][b]=1;

            f[a][b]=f[t.first][t.second]+1;

            que.push(&#123;a,b&#125;);

        &#125;

    &#125;

&#125;

return f[n-1][m-1];
</code></pre>
<p>}</p>
<p>int main(){</p>
<pre><code>scanf(&quot;%d%d&quot;,&amp;n,&amp;m);

for(int i=0;i&lt;n;i++)

    for(int j=0;j&lt;m;j++)

        scanf(&quot;%d&quot;,&amp;g[i][j]);

cout&lt;&lt;bfs(0,0)&lt;&lt;endl;

return 0;
</code></pre>
<p>}</p>
<h3 id="应用：八数码"><a href="#应用：八数码" class="headerlink" title="应用：八数码"></a>应用：八数码</h3><p>using namespace std;</p>
<p>int bfs(string state) {</p>
<pre><code>queue&lt;string&gt; q;

unordered_map&lt;string, int&gt; d;



int dx[4] = &#123;-1, 0, 1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;;

string ed = &quot;12345678x&quot;;

q.push(state);

d[state] = 0;



while (q.size()) &#123;

    auto t = q.front();

    q.pop();

    if (t == ed)//等于结果就输出步数

        return d[t];

    int distance = d[t];

    int k = t.find(&#39;x&#39;);//寻找x

    int x = k / 3, y = k % 3;//计算下标

    for (int i = 0; i &lt; 4; i ++ ) &#123;

        int a = x + dx[i], b = y + dy[i];

        if (a &gt;= 0 &amp;&amp; a &lt; 3 &amp;&amp; b &gt;= 0 &amp;&amp; b &lt; 3) &#123;

            swap(t[a * 3 + b], t[k]);//交换

            if (!d.count(t)) &#123;//不存在就入队

                d[t] = distance + 1;

                q.push(t);

            &#125;

            swap(t[a * 3 + b], t[k]);//还原

        &#125;

    &#125;

&#125;

return -1;
</code></pre>
<p>}</p>
<p>int main() {</p>
<pre><code>char s[2];

string state;

for (int i = 0; i &lt; 9; i ++ ) &#123;

    cin &gt;&gt; s;

    state += *s;

&#125;

cout&lt;&lt;bfs(state)&lt;&lt;endl;

return 0;
</code></pre>
<p>}</p>
<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>啥是拓扑排序？</p>
<p>一个有向图，如果图中有入度为 0 的点，就把这个点删掉，同时也删掉这个点所连的边。</p>
<p>一直进行上面出处理，如果所有点都能被删掉，则这个图可以进行拓扑排序。</p>
<h4 id="纯净版"><a href="#纯净版" class="headerlink" title="纯净版"></a>纯净版</h4><p>bool topsort()</p>
<p>{</p>
<pre><code>int hh = 0, tt = -1;



// d[i] 存储点i的入度

for (int i = 1; i &lt;= n; i ++ )

    if (!d[i])

        q[ ++ tt] = i;



while (hh &lt;= tt)

&#123;

    int t = q[hh ++ ];



    for (int i = h[t]; i != -1; i = ne[i])

    &#123;

        int j = e[i];

        if (-- d[j] == 0)

            q[ ++ tt] = j;

    &#125;

&#125;



// 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。

return tt == n - 1;
</code></pre>
<p>}</p>
<h4 id="解说版"><a href="#解说版" class="headerlink" title="解说版"></a>解说版</h4><p>using namespace std;</p>
<p>const int N &#x3D; 100010;</p>
<p>int e[N], ne[N], idx; &#x2F;&#x2F;邻接表存储图</p>
<p>int h[N];&#x2F;&#x2F;邻接表的每个头链表</p>
<p>int q[N], hh &#x3D; 0, tt &#x3D; -1; &#x2F;&#x2F;队列保存入度为0的点，也就是能够输出的点</p>
<p>int n, m; &#x2F;&#x2F;保存图的点数和边数</p>
<p>int d[N];&#x2F;&#x2F;保存各个点的入度</p>
<p>void add(int a, int b) {</p>
<pre><code>e[idx] = b, ne[idx] = h[a], h[a] = idx++;
</code></pre>
<p>}</p>
<p>void topsort() {</p>
<pre><code>for (int i = 1; i &lt;= n; i++) &#123;//遍历一遍顶点的入度。

    if (!d[i])//如果入度为0，则可以入队列

        q[++tt] = i;

&#125;

while (tt &gt;= hh) &#123; //循环处理队列中点的

    int a = q[hh++];

    for (int i = h[a]; i != -1; i = ne[i]) &#123;

        int b = e[i]; //a 有一条边指向b

        d[b]--;//删除边后，b的入度减1

        if (!d[b])//如果b的入度减为 0,则 b 可以输出，入队列

            q[++tt] = b;

    &#125;

&#125;

if (tt == n - 1) &#123;//如果队列中的点的个数与图中点的个数相同，则可以进行拓扑排序

    for (int i = 0; i &lt; n; i++)//队列中保存了所有入度为0的点，依次输出

        printf(&quot;%d &quot;, q[i]);

&#125; else//如果队列中的点的个数与图中点的个数不相同，则可以进行拓扑排序

    cout &lt;&lt; -1;
</code></pre>
<p>}</p>
<p>int main() {</p>
<pre><code>cin &gt;&gt; n &gt;&gt; m; //保存点的个数和边的个数

memset(h, -1, sizeof h); //初始化领接矩阵

while (m--) &#123; //依次读入边

    int a, b;

    cin &gt;&gt; a &gt;&gt; b;

    d[b]++;//顶点b的入度+1

    add(a, b); //添加到邻接矩阵

&#125;

topsort();//进行拓扑排序

return 0;
</code></pre>
<p>}</p>
<h3 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h3><h4 id="朴素版"><a href="#朴素版" class="headerlink" title="朴素版"></a>朴素版</h4><p>时间复杂是O(n2+m)</p>
<p>，n表示点数，m表示边数</p>
<p>int g[N][N];  &#x2F;&#x2F; 存储每条边</p>
<p>int dist[N];  &#x2F;&#x2F; 存储1号点到每个点的最短距离</p>
<p>bool st[N];   &#x2F;&#x2F; 存储每个点的最短路是否已经确定</p>
<p>&#x2F;&#x2F; 求1号点到n号点的最短路，如果不存在则返回-1</p>
<p>int dijkstra()</p>
<p>{</p>
<pre><code>memset(dist, 0x3f, sizeof dist);

dist[1] = 0;



for (int i = 0; i &lt; n - 1; i ++ )

&#123;

    int t = -1;     // 在还未确定最短路的点中，寻找距离最小的点

    for (int j = 1; j &lt;= n; j ++ )

        if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))

            t = j;



    // 用t更新其他点的距离

    for (int j = 1; j &lt;= n; j ++ )

        dist[j] = min(dist[j], dist[t] + g[t][j]);



    st[t] = true;

&#125;



if (dist[n] == 0x3f3f3f3f) return -1;

return dist[n];
</code></pre>
<p>}</p>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>const int N &#x3D; 510, M &#x3D; 100010;</p>
<p>int h[N], e[M], ne[M], w[M], idx;&#x2F;&#x2F;邻接表存储图</p>
<p>int state[N];&#x2F;&#x2F;state 记录是否找到了源点到该节点的最短距离</p>
<p>int dist[N];&#x2F;&#x2F;dist 数组保存源点到其余各个节点的距离</p>
<p>int n, m;&#x2F;&#x2F;图的节点个数和边数</p>
<p>void add(int a, int b, int c)&#x2F;&#x2F;插入边</p>
<p>{</p>
<pre><code>e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
</code></pre>
<p>}</p>
<p>void Dijkstra()</p>
<p>{</p>
<pre><code>memset(dist, 0x3f, sizeof(dist));//dist 数组的各个元素为无穷大

dist[1] = 0;//源点到源点的距离为置为 0

for (int i = 0; i &lt; n; i++)

&#123;

    int t = -1;

    for (int j = 1; j &lt;= n; j++)//遍历 dist 数组，找到没有确定最短路径的节点中距离源点最近的点t

    &#123;

        if (!state[j] &amp;&amp; (t == -1 || dist[j] &lt; dist[t]))

            t = j;

    &#125;



    state[t] = 1;//state[i] 置为 1。



    for (int j = h[t]; j != -1; j = ne[j])//遍历 t 所有可以到达的节点 i

    &#123;

        int i = e[j];

        dist[i] = min(dist[i], dist[t] + w[j]);//更新 dist[j]

    &#125;





&#125;
</code></pre>
<p>}</p>
<p>int main()</p>
<p>{</p>
<pre><code>memset(h, -1, sizeof(h));//邻接表初始化



cin &gt;&gt; n &gt;&gt; m;

while (m--)//读入 m 条边

&#123;

    int a, b, w;

    cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;

    add(a, b, w);

&#125;



Dijkstra();

if (dist[n] != 0x3f3f3f3f)//如果dist[n]被更新了，则存在路径

    cout &lt;&lt; dist[n];

else

    cout &lt;&lt; &quot;-1&quot;;
</code></pre>
<p>}</p>
<h4 id="堆优化版"><a href="#堆优化版" class="headerlink" title="堆优化版"></a>堆优化版</h4><p>时间复杂度O(mlogn)</p>
<p>，n表示点数，m表示边数</p>
<p>typedef pair&lt;int, int&gt; PII;</p>
<p>int n;      &#x2F;&#x2F; 点的数量</p>
<p>int h[N], w[N], e[N], ne[N], idx;       &#x2F;&#x2F; 邻接表存储所有边</p>
<p>int dist[N];        &#x2F;&#x2F; 存储所有点到1号点的距离</p>
<p>bool st[N];     &#x2F;&#x2F; 存储每个点的最短距离是否已确定</p>
<p>&#x2F;&#x2F; 求1号点到n号点的最短距离，如果不存在，则返回-1</p>
<p>int dijkstra(){</p>
<pre><code>memset(dist,0x3f,sizeof dist);//距离初始化为无穷大

dist[1]=0;//1-&gt;1的节点距离为0

priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt; heap;//小根堆

heap.push(&#123;0,1&#125;);//插入距离和节点编号



while(heap.size())&#123;

    auto t=heap.top();//取距离源点最近的点

    heap.pop();



    int ver=t.second,distance=t.first;//ver：节点编号，distance源点距离ver

    if(st[ver])continue;//如果距离已经确定，则跳过该点

    st[ver]=true;

    for(int i=h[ver];i!=-1;i=ne[i])//更新ver所指向的节点距离

    &#123;

        int j=e[i];

        if(dist[j]&gt;dist[ver]+w[i])&#123;

            dist[j]=dist[ver]+w[i];

            heap.push(&#123;dist[j],j&#125;);//距离变小，则入堆

        &#125;

    &#125;

&#125;

if(dist[n]==0x3f3f3f3f)return -1;

return dist[n];
</code></pre>
<p>}</p>
<h4 id="关于Dijkstra的相关博客链接："><a href="#关于Dijkstra的相关博客链接：" class="headerlink" title="关于Dijkstra的相关博客链接："></a>关于Dijkstra的相关博客链接：</h4><p>[AcWing 849. Dijkstra求最短路 I：图解 详细代码（图解） - AcWing：<a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/38318/">https://www.acwing.com/solution/content/38318/</a></p>
<p>[AcWing 850. Dijkstra求最短路 II：详解+代码注释 - AcWing]：<a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/38323/">https://www.acwing.com/solution/content/38323/</a></p>
<h3 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman-Ford算法"></a>Bellman-Ford算法</h3><p>时间复杂度O(nm)，n表示点数，m表示边数</p>
<p>注意在模板题中需要对下面的模板稍作修改，加上备份数组，详情见模板题。</p>
<p>Bellman-ford算法动态规划图示.png</p>
<p>上图为Bellman-ford草稿图</p>
<p>int n, m;       &#x2F;&#x2F; n表示点数，m表示边数</p>
<p>int dist[N],backup[N];        &#x2F;&#x2F; dist[x]存储1到x的最短路距离</p>
<p>struct Edge     &#x2F;&#x2F; 边，a表示出点，b表示入点，w表示边的权重</p>
<p>{</p>
<pre><code>int a, b, w;
</code></pre>
<p>}edges[M];</p>
<p>&#x2F;&#x2F; 求1到n的最短路距离，如果无法从1走到n，则返回-1。</p>
<p>int bellman_ford()</p>
<p>{</p>
<pre><code>memset(dist, 0x3f, sizeof dist);

dist[1] = 0;



// 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。

for (int i = 0; i &lt; n; i ++ )

&#123;

    memcpy(back,dist,sizeof dist);

    for (int j = 0; j &lt; m; j ++ )

    &#123;

        int a = edges[j].a, b = edges[j].b, w = edges[j].w;

        if (dist[b] &gt; backup[a] + w)

            dist[b] = backup[a] + w;

    &#125;

&#125;



if (dist[n] &gt; 0x3f3f3f3f / 2) return -1;

return dist[n];
</code></pre>
<p>}</p>
<h4 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h4><p>int n,m,k;</p>
<p>const int N&#x3D;512,M&#x3D;10012;</p>
<p>struct Edge{</p>
<pre><code>int a,b,w;
</code></pre>
<p>}e[M];</p>
<p>int dist[N];</p>
<p>int back[N];</p>
<p>void bellman_ford(){</p>
<pre><code>memset(dist,0x3f,sizeof dist);

dist[1]=0;

for(int i=0;i&lt;k;i++)&#123;

    memcpy(back,dist,sizeof dist);

    for(int j=0;j&lt;m;j++)&#123;

        int a=e[j].a,b=e[j].b,c=e[j].w;

        dist[b]=min(dist[b],back[a]+c);

    &#125;

&#125;
</code></pre>
<p>}</p>
<p>int main(){</p>
<pre><code>scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k);

for(int i=0;i&lt;m;i++)&#123;

    int a,b,w;

    scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;w);

    e[i]=&#123;a,b,w&#125;;

&#125;

bellman_ford();

if(dist[n]&gt;0x3f3f3f3f/2)cout&lt;&lt;&quot;impossible&quot;&lt;&lt;endl;

else cout&lt;&lt;dist[n]&lt;&lt;endl;

return 0;
</code></pre>
<p>}</p>
<p>问题：为什么把每一条边用不等式刷k次就是k条件下的值？</p>
<p>你可以想象这个图是1-&gt;2-&gt;3-&gt;4….-&gt;n这样一条直线。比如说第一次迭代，为什么只有与原点相连的点才能被更新dist呢？因为原点的dist是0，其他点的dist是+∞，满足dist[2] &gt; dist[1]+c，而+∞并不&gt;+∞+c，所以第一次迭代结束就是不超过一条边走到i节点最短路的距离，依次类推，第二次迭代，只有3会被更新，因为只有1、2的dist不是+∞，第二次迭代就是不超过2条边走到i节点的最短距离。这就是为什么k次迭代最多是走了k条边，同时也是为什么一共只用迭代n-1次，因为n个点的有向图，如果能走到，原点到n号点的最短距离最多是n-1次，也就是1-&gt;2-&gt;…-&gt;n直线这种。</p>
<h3 id="SPFA算法（队列优化的Bellman-Ford算法）"><a href="#SPFA算法（队列优化的Bellman-Ford算法）" class="headerlink" title="SPFA算法（队列优化的Bellman-Ford算法）"></a>SPFA算法（队列优化的Bellman-Ford算法）</h3><p>时间复杂度平均情况下O(m)，最坏情况下O(nm)，n表示点数，m表示边数</p>
<p>模板</p>
<p>int n;      &#x2F;&#x2F; 总点数</p>
<p>int h[N], w[N], e[N], ne[N], idx;       &#x2F;&#x2F; 邻接表存储所有边</p>
<p>int dist[N];        &#x2F;&#x2F; 存储每个点到1号点的最短距离</p>
<p>bool st[N];     &#x2F;&#x2F; 存储每个点是否在队列中</p>
<p>&#x2F;&#x2F; 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1</p>
<p>int spfa()</p>
<p>{</p>
<pre><code>memset(dist, 0x3f, sizeof dist);

dist[1] = 0;



queue&lt;int&gt; q;

q.push(1);

st[1] = true;



while (q.size())

&#123;

    auto t = q.front();

    q.pop();



    st[t] = false;



    for (int i = h[t]; i != -1; i = ne[i])

    &#123;

        int j = e[i];

        if (dist[j] &gt; dist[t] + w[i])

        &#123;

            dist[j] = dist[t] + w[i];

            if (!st[j])     // 如果队列中已存在j，则不需要将j重复插入

            &#123;

                q.push(j);

                st[j] = true;

            &#125;

        &#125;

    &#125;

&#125;



if (dist[n] == 0x3f3f3f3f) return -1;

return dist[n];
</code></pre>
<p>}</p>
<h4 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h4><p>const int N &#x3D; 1e6 + 10;</p>
<p>int n, m;&#x2F;&#x2F;节点数量和边数</p>
<p>int h[N], w[N], e[N], ne[N], idx;&#x2F;&#x2F;邻接矩阵存储图</p>
<p>int dist[N];&#x2F;&#x2F;存储距离</p>
<p>bool st[N];&#x2F;&#x2F;存储状态</p>
<p>void add(int a, int b, int c)</p>
<p>{</p>
<pre><code>e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
</code></pre>
<p>}</p>
<p>int spfa()</p>
<p>{</p>
<pre><code>memset(dist, 0x3f, sizeof dist);//距离初始化为无穷大

dist[1] = 0;//初始化1到1的距离为0

queue&lt;int&gt; que;//队列

que.push(1);//1入队



while (que.size())//判断是否存在

&#123;

    int t=que.front();

    que.pop();//获取第一个并出队

    st[t]=false;//第一个取消占用

    for(int i=h[t];i!=-1;i=ne[i])&#123;//遍历第一个可以到达的结点

        int j=e[i];

        if(dist[j]&gt;dist[t]+w[i])&#123;//1号点可到达的节点距离是否大于上次的距离距离加上当前的距离

            dist[j]=dist[t]+w[i];//赋值给可到达的节点

            if(!st[j])&#123;//如果可到达的节点未被占用

                que.push(j);//则入队

                st[j]=true;//占用

            &#125;

        &#125;

    &#125;

&#125;



return dist[n];
</code></pre>
<p>}</p>
<p>int main()</p>
<p>{</p>
<pre><code>scanf(&quot;%d%d&quot;, &amp;n, &amp;m);



memset(h, -1, sizeof h);

while (m -- )

&#123;

    int a, b, c;

    scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);

    add(a, b, c);

&#125;



int t=spfa();

if(t==0x3f3f3f3f)cout&lt;&lt;&quot;impossible&quot;&lt;&lt;endl;

else printf(&quot;%d\n&quot;,t);



return 0;
</code></pre>
<p>}</p>
<h4 id="应用：spfa判断图中是否存在负权"><a href="#应用：spfa判断图中是否存在负权" class="headerlink" title="应用：spfa判断图中是否存在负权"></a>应用：spfa判断图中是否存在负权</h4><p>int n;      &#x2F;&#x2F; 总点数</p>
<p>int h[N], w[N], e[N], ne[N], idx;       &#x2F;&#x2F; 邻接表存储所有边</p>
<p>int dist[N], cnt[N];        &#x2F;&#x2F; dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数</p>
<p>bool st[N];     &#x2F;&#x2F; 存储每个点是否在队列中</p>
<p>&#x2F;&#x2F; 如果存在负环，则返回true，否则返回false。</p>
<p>bool spfa()</p>
<p>{</p>
<pre><code>// 不需要初始化dist数组

// 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。



queue&lt;int&gt; q;

for (int i = 1; i &lt;= n; i ++ )

&#123;

    q.push(i);

    st[i] = true;

&#125;



while (q.size())

&#123;

    auto t = q.front();

    q.pop();



    st[t] = false;



    for (int i = h[t]; i != -1; i = ne[i])

    &#123;

        int j = e[i];

        if (dist[j] &gt; dist[t] + w[i])

        &#123;

            dist[j] = dist[t] + w[i];

            cnt[j] = cnt[t] + 1;

            if (cnt[j] &gt;= n) return true;       // 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环

            if (!st[j])

            &#123;

                q.push(j);

                st[j] = true;

            &#125;

        &#125;

    &#125;

&#125;



return false;
</code></pre>
<p>}</p>
<h3 id="floyd算法"><a href="#floyd算法" class="headerlink" title="floyd算法"></a>floyd算法</h3><p>时间复杂度O(n3)，n表示点数</p>
<p>视频讲解：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV14R4y1x7GB/">https://www.bilibili.com/video/BV14R4y1x7GB/</a></p>
<p>模板</p>
<p>初始化：</p>
<pre><code>for (int i = 1; i &lt;= n; i ++ )

    for (int j = 1; j &lt;= n; j ++ )

        if (i == j) d[i][j] = 0;

        else d[i][j] = INF;
</code></pre>
<p>&#x2F;&#x2F; 算法结束后，d[a][b]表示a到b的最短距离</p>
<p>void floyd()</p>
<p>{</p>
<pre><code>for (int k = 1; k &lt;= n; k ++ )//k为中转节点

    for (int i = 1; i &lt;= n; i ++ )

        for (int j = 1; j &lt;= n; j ++ )

            d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
</code></pre>
<p>}</p>
<p>应用</p>
<p>using namespace std;</p>
<p>const int N &#x3D; 210, INF &#x3D; 1e9;</p>
<p>int n, m, Q;</p>
<p>int d[N][N];</p>
<p>void floyd()</p>
<p>{</p>
<pre><code>for (int k = 1; k &lt;= n; k ++ )//k为中转节点

    for (int i = 1; i &lt;= n; i ++ )

        for (int j = 1; j &lt;= n; j ++ )

            d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
</code></pre>
<p>}</p>
<p>int main()</p>
<p>{</p>
<pre><code>scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;Q);



for (int i = 1; i &lt;= n; i ++ )

    for (int j = 1; j &lt;= n; j ++ )

        if (i == j) d[i][j] = 0;

        else d[i][j] = INF;



while (m -- )

&#123;

    int a, b, c;

    scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);

    d[a][b] = min(d[a][b], c);

&#125;



floyd();



while (Q -- )

&#123;

    int a, b;

    scanf(&quot;%d%d&quot;, &amp;a, &amp;b);



    int t = d[a][b];

    if (t &gt; INF / 2) puts(&quot;impossible&quot;);

    else printf(&quot;%d\n&quot;, t);

&#125;



return 0;
</code></pre>
<p>}</p>
<h3 id="最短路算法总结"><a href="#最短路算法总结" class="headerlink" title="最短路算法总结"></a>最短路算法总结</h3><p>最短路</p>
<p>单源最短路：给定V中的一个顶点，称为源。要计算从源到其他所有各顶点的最短路径长度。这里的长度就是指路上各边权之和。这个问题通常称为单源最短路径 问题。</p>
<p>所有边权都是正数：</p>
<p>朴素Dijkstra算法 O(n^2) 适合稠密图，贪心思想</p>
<p>堆优化版的Dijkstra算法 O(mlogn)适合稀疏图，贪心思想</p>
<p>​ 存在负权边：</p>
<p>​ Bellman-ford O(nm)，动态规划思想</p>
<p>​ SPFA 一般：O(m)，最坏O(nm)</p>
<p>多源汇最短路：任意两点最短路径被称为多源最短路径，即给定任意两个点，一个出发点，一个到达点，求这两个点的之间的最短路径，就是任意两点最短路径问题</p>
<p>Floyd算法 O(n^3)</p>
<h3 id="prim算法"><a href="#prim算法" class="headerlink" title="prim算法"></a>prim算法</h3><p>时间复杂度是O(n2+m)，n表示点数，m表示边数</p>
<p>int n;      &#x2F;&#x2F; n表示点数</p>
<p>int g[N][N];        &#x2F;&#x2F; 邻接矩阵，存储所有边</p>
<p>int dist[N];        &#x2F;&#x2F; 存储其他点到当前最小生成树的距离</p>
<p>bool st[N];     &#x2F;&#x2F; 存储每个点是否已经在生成树中</p>
<p>&#x2F;&#x2F; 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和</p>
<p>int prim()</p>
<p>{</p>
<pre><code>memset(dist, 0x3f, sizeof dist);



int res = 0;

for (int i = 0; i &lt; n; i ++ )

&#123;

    int t = -1;

    for (int j = 1; j &lt;= n; j ++ )

        if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))

            t = j;



    if (i &amp;&amp; dist[t] == INF) return INF;



    if (i) res += dist[t];

    st[t] = true;



    for (int j = 1; j &lt;= n; j ++ ) dist[j] = min(dist[j], g[t][j]);

&#125;



return res;
</code></pre>
<p>}</p>
<p>应用</p>
<p>const int N &#x3D; 510, INF &#x3D; 0x3f3f3f3f;</p>
<p>int n, m;</p>
<p>int g[N][N];</p>
<p>int dist[N];</p>
<p>bool st[N];</p>
<p>int prim()</p>
<p>{</p>
<pre><code>memset(dist, 0x3f, sizeof dist);



int res = 0;

for (int i = 0; i &lt; n; i ++ )

&#123;

    int t = -1;

    for (int j = 1; j &lt;= n; j ++ )

        if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))

            t = j;



    if (i &amp;&amp; dist[t] == INF) return INF;



    if (i) res += dist[t];

    st[t] = true;



    for (int j = 1; j &lt;= n; j ++ ) dist[j] = min(dist[j], g[t][j]);

&#125;



return res;
</code></pre>
<p>}</p>
<p>int main()</p>
<p>{</p>
<pre><code>scanf(&quot;%d%d&quot;, &amp;n, &amp;m);



memset(g, 0x3f, sizeof g);



while (m -- )

&#123;

    int a, b, c;

    scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);

    g[a][b] = g[b][a] = min(g[a][b], c);

&#125;



int t = prim();



if (t == INF) puts(&quot;impossible&quot;);

else printf(&quot;%d\n&quot;, t);



return 0;
</code></pre>
<p>}</p>
<h3 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h3><p>时间复杂度O(mlogm)，n表示点数，m表示边数</p>
<p>int n, m;       &#x2F;&#x2F; n是点数，m是边数</p>
<p>int p[N];       &#x2F;&#x2F; 并查集的父节点数组</p>
<p>struct Edge     &#x2F;&#x2F; 存储边</p>
<p>{</p>
<pre><code>int a, b, w;

bool operator&lt; (const Edge &amp;W)const

&#123;

    return w &lt; W.w;

&#125;
</code></pre>
<p>}edges[M];</p>
<p>int find(int x)     &#x2F;&#x2F; 并查集核心操作</p>
<p>{</p>
<pre><code>if (p[x] != x) p[x] = find(p[x]);

return p[x];
</code></pre>
<p>}</p>
<p>int kruskal()</p>
<p>{</p>
<pre><code>sort(edges, edges + m);



for (int i = 1; i &lt;= n; i ++ ) p[i] = i;    // 初始化并查集



int res = 0, cnt = 0;

for (int i = 0; i &lt; m; i ++ )

&#123;

    int a = edges[i].a, b = edges[i].b, w = edges[i].w;



    a = find(a), b = find(b);

    if (a != b)     // 如果两个连通块不连通，则将这两个连通块合并

    &#123;

        p[a] = b;

        res += w;

        cnt ++ ;

    &#125;

&#125;

if (cnt &lt; n - 1) return INF;

return res;
</code></pre>
<p>}</p>
<p>应用</p>
<p>#include <cstring></p>
<p>#include <iostream></p>
<p>#include <algorithm></p>
<p>using namespace std;</p>
<p>const int N &#x3D; 100010, M &#x3D; 200010, INF &#x3D; 0x3f3f3f3f;</p>
<p>int n, m;</p>
<p>int p[N];</p>
<p>struct Edge</p>
<p>{</p>
<pre><code>int a, b, w;



bool operator&lt; (const Edge &amp;W)const

&#123;

    return w &lt; W.w;

&#125;
</code></pre>
<p>}edges[M];</p>
<p>int find(int x)</p>
<p>{</p>
<pre><code>if (p[x] != x) p[x] = find(p[x]);

return p[x];
</code></pre>
<p>}</p>
<p>int kruskal()</p>
<p>{</p>
<pre><code>sort(edges, edges + m);



for (int i = 1; i &lt;= n; i ++ ) p[i] = i;    // 初始化并查集



int res = 0, cnt = 0;

for (int i = 0; i &lt; m; i ++ )

&#123;

    int a = edges[i].a, b = edges[i].b, w = edges[i].w;



    a = find(a), b = find(b);

    if (a != b)

    &#123;

        p[a] = b;

        res += w;

        cnt ++ ;

    &#125;

&#125;



if (cnt &lt; n - 1) return INF;

return res;
</code></pre>
<p>}</p>
<p>int main()</p>
<p>{</p>
<pre><code>scanf(&quot;%d%d&quot;, &amp;n, &amp;m);



for (int i = 0; i &lt; m; i ++ )

&#123;

    int a, b, w;

    scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;w);

    edges[i] = &#123;a, b, w&#125;;

&#125;



int t = kruskal();



if (t == INF) puts(&quot;impossible&quot;);

else printf(&quot;%d\n&quot;, t);



return 0;
</code></pre>
<p>}</p>
<h3 id="染色法判别二分图"><a href="#染色法判别二分图" class="headerlink" title="染色法判别二分图"></a>染色法判别二分图</h3><p>什么叫二分图</p>
<p>有两顶点集且图中每条边的的两个顶点分别位于两个顶点集中，每个顶点集中没有边直接相连接！</p>
<p>说人话的定义：图中点通过移动能分成左右两部分，左侧的点只和右侧的点相连，右侧的点只和左侧的点相连。</p>
<p>下图就是个二分图：</p>
<p>时间复杂度是O(n+m)，n表示点数，m表示边数</p>
<p>int n;      &#x2F;&#x2F; n表示点数</p>
<p>int h[N], e[M], ne[M], idx;     &#x2F;&#x2F; 邻接表存储图</p>
<p>int color[N];       &#x2F;&#x2F; 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色</p>
<p>&#x2F;&#x2F; 参数：u表示当前节点，c表示当前点的颜色</p>
<p>bool dfs(int u, int c)</p>
<p>{</p>
<pre><code>color[u] = c;

for (int i = h[u]; i != -1; i = ne[i])

&#123;

    int j = e[i];

    if (color[j] == -1)

    &#123;

        if (!dfs(j, !c)) return false;

    &#125;

    else if (color[j] == c) return false;

&#125;



return true;
</code></pre>
<p>}</p>
<p>bool check()</p>
<p>{</p>
<pre><code>memset(color, -1, sizeof color);

bool flag = true;

for (int i = 1; i &lt;= n; i ++ )

    if (color[i] == -1)

        if (!dfs(i, 0))

        &#123;

            flag = false;

            break;

        &#125;

return flag;
</code></pre>
<p>}</p>
<h4 id="应用-3"><a href="#应用-3" class="headerlink" title="应用"></a>应用</h4><p>using namespace std;</p>
<p>const int N &#x3D; 100010, M &#x3D; 200010;&#x2F;&#x2F; 由于是无向图, 顶点数最大是N，那么边数M最大是顶点数的2倍</p>
<p>int n, m;</p>
<p>int h[N], e[M], ne[M], idx;</p>
<p>int color[N];</p>
<p>void add(int a, int b)</p>
<p>{</p>
<pre><code>e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
</code></pre>
<p>}</p>
<p>bool dfs(int u, int c)</p>
<p>{</p>
<pre><code>color[u] = c;



for (int i = h[u]; i != -1; i = ne[i])

&#123;

    int j = e[i];

    if (!color[j])

    &#123;

        if (!dfs(j, 3 - c)) return false;

    &#125;

    else if (color[j] == c) return false;

&#125;



return true;
</code></pre>
<p>}</p>
<p>int main()</p>
<p>{</p>
<pre><code>scanf(&quot;%d%d&quot;, &amp;n, &amp;m);



memset(h, -1, sizeof h);



while (m -- )

&#123;

    int a, b;

    scanf(&quot;%d%d&quot;, &amp;a, &amp;b);

    add(a, b), add(b, a);// 无向图，a-&gt;b, b-&gt;a

&#125;



bool flag = true;

for (int i = 1; i &lt;= n; i ++ )

    if (!color[i])

    &#123;

        if (!dfs(i, 1))

        &#123;

            flag = false;

            break;

        &#125;

    &#125;



if (flag) puts(&quot;Yes&quot;);

else puts(&quot;No&quot;);



return 0;
</code></pre>
<p>}</p>
<h3 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h3><p>要了解匈牙利算法必须先理解下面的概念：</p>
<p>匹配：在图论中，一个「匹配」是一个边的集合，其中任意两条边都没有公共顶点。</p>
<p>最大匹配：一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配。</p>
<p>下面是一些补充概念：</p>
<p>完美匹配：如果一个图的某个匹配中，所有的顶点都是匹配点，那么它就是一个完美匹配。</p>
<p>交替路：从一个未匹配点出发，依次经过非匹配边、匹配边、非匹配边…形成的路径叫交替路。</p>
<p>增广路：从一个未匹配点出发，走交替路，如果途径另一个未匹配点（出发的点不算），则这条交替 路称为增广路（agumenting path）。</p>
<p>时间复杂度O(nm)，n表示点数，m表示边数</p>
<p>&#x2F;&#x2F;遍历自己喜欢的女孩int n1, n2;     &#x2F;&#x2F; n1表示第一个集合中的点数，n2表示第二个集合中的点数</p>
<p>int h[N], e[M], ne[M], idx;     &#x2F;&#x2F; 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边</p>
<p>int match[N];       &#x2F;&#x2F; 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个</p>
<p>bool st[N];     &#x2F;&#x2F; 表示第二个集合中的每个点是否已经被遍历过</p>
<p>void add(int a, int b)</p>
<p>{</p>
<pre><code>e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
</code></pre>
<p>}</p>
<p>bool find(int x)</p>
<p>{</p>
<pre><code>//遍历自己喜欢的女孩

for (int i = h[x]; i != -1; i = ne[i])

&#123;

    int j = e[i];

    if (!st[j])//如果在这一轮模拟匹配中,这个女孩尚未被预定

    &#123;

        st[j] = true;//那x就预定这个女孩了

        //如果女孩j没有男朋友，或者她原来的男朋友能够预定其它喜欢的女孩。配对成功

        if (match[j] == 0 || find(match[j]))

        &#123;

            match[j] = x;

            return true;

        &#125;

    &#125;

&#125;

//自己中意的全部都被预定了。配对失败。

return false;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点</p>
<p>int res &#x3D; 0;</p>
<p>for (int i &#x3D; 1; i &lt;&#x3D; n1; i ++ )</p>
<p>{</p>
<pre><code>memset(st, false, sizeof st);

if (find(i)) res ++ ;
</code></pre>
<p>}</p>
<p>应用：二分图的最大匹配</p>
<p>匈牙利算法图示化</p>
<p>相关题解：[AcWing 861. 二分图的最大匹配—-图解 - AcWing]：<a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/179030/">https://www.acwing.com/solution/content/179030/</a></p>
<p>using namespace std;</p>
<p>const int N &#x3D; 510, M &#x3D; 100010;</p>
<p>int n1, n2, m;</p>
<p>int h[N], e[M], ne[M], idx;</p>
<p>int match[N];</p>
<p>bool st[N];</p>
<p>void add(int a, int b)</p>
<p>{</p>
<pre><code>e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
</code></pre>
<p>}</p>
<p>bool find(int x)</p>
<p>{</p>
<pre><code> // 和各个点尝试能否匹配

for (int i = h[x]; i != -1; i = ne[i])

&#123;

    int j = e[i];

    if (!st[j])//打标记

    &#123;

        st[j] = true;

        // 当前尝试点没有被匹配或者和当前尝试点匹配的那个点可以换另一个匹配

        if (match[j] == 0 || find(match[j]))

        &#123;

            // 和当前尝试点匹配在一起

            match[j] = x;

            return true;

        &#125;

    &#125;

&#125;

return false;
</code></pre>
<p>}</p>
<p>int main()</p>
<p>{</p>
<pre><code>scanf(&quot;%d%d%d&quot;, &amp;n1, &amp;n2, &amp;m);



memset(h, -1, sizeof h);

// 保存图，因为只从一遍找另一边，所以该无向图只需要存储一个方向

while (m -- )

&#123;

    int a, b;

    scanf(&quot;%d%d&quot;, &amp;a, &amp;b);

    add(a, b);

&#125;



int res = 0;

//为各个点找匹配

for (int i = 1; i &lt;= n1; i ++ )

&#123;

    memset(st, false, sizeof st);

    //找到匹配

    if (find(i)) res ++ ;

&#125;



printf(&quot;%d\n&quot;, res);



return 0;
</code></pre>
<p>}</p>
<h2 id="四、数学知识"><a href="#四、数学知识" class="headerlink" title="四、数学知识"></a>四、数学知识</h2><p>算法的数学知识定理证明可以在这里查阅：[数学部分简介 - OI Wiki (oi-wiki.org)]：<a target="_blank" rel="noopener" href="https://oi-wiki.org/math/">https://oi-wiki.org/math/</a></p>
<h3 id="试除法判定质数"><a href="#试除法判定质数" class="headerlink" title="试除法判定质数"></a>试除法判定质数</h3><p>bool is_prime(int x)</p>
<p>{</p>
<pre><code>if (x &lt; 2) return false;

for (int i = 2; i &lt;= x / i; i ++ )

    if (x % i == 0)

        return false;

return true;
</code></pre>
<p>}</p>
<h3 id="试除法分解质因数"><a href="#试除法分解质因数" class="headerlink" title="试除法分解质因数"></a>试除法分解质因数</h3><p>void divide(int x)</p>
<p>{</p>
<pre><code>for (int i = 2; i &lt;= x / i; i ++ )

    if (x % i == 0)//i 一定是质数

    &#123;

        int s = 0;

        while (x % i == 0) x /= i, s ++ ;

        cout &lt;&lt; i &lt;&lt; &#39; &#39; &lt;&lt; s &lt;&lt; endl;

    &#125;

if (x &gt; 1) cout &lt;&lt; x &lt;&lt; &#39; &#39; &lt;&lt; 1 &lt;&lt; endl;

cout &lt;&lt; endl;
</code></pre>
<p>}</p>
<h3 id="埃氏筛法求质数"><a href="#埃氏筛法求质数" class="headerlink" title="埃氏筛法求质数"></a>埃氏筛法求质数</h3><p>int primes[N], cnt;     &#x2F;&#x2F; primes[]存储所有素数</p>
<p>bool st[N];         &#x2F;&#x2F; st[x]存储x是否被筛掉</p>
<p>void get_primes(int n)</p>
<p>{</p>
<pre><code>for (int i = 2; i &lt;= n; i ++ )

&#123;

    if (st[i]) continue;

    primes[cnt ++ ] = i;

    for (int j = i + i; j &lt;= n; j += i)

        st[j] = true;

&#125;
</code></pre>
<p>}</p>
<h3 id="线性筛法求质数"><a href="#线性筛法求质数" class="headerlink" title="线性筛法求质数"></a>线性筛法求质数</h3><p>算法动画讲解：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1LR4y1Z7pm">https://www.bilibili.com/video/BV1LR4y1Z7pm</a></p>
<p>int primes[N], cnt;     &#x2F;&#x2F; primes[]存储所有素数</p>
<p>bool st[N];         &#x2F;&#x2F; st[x]存储x是否被筛掉</p>
<p>void get_primes(int n)</p>
<p>{</p>
<pre><code>for (int i = 2; i &lt;= n; i ++ )

&#123;

    if (!st[i]) primes[cnt ++ ] = i;

    for (int j = 0; primes[j] &lt;= n / i; j ++ )

    &#123;

        st[primes[j] * i] = true;

        if (i % primes[j] == 0) break;

    &#125;

&#125;
</code></pre>
<p>}</p>
<h3 id="试除法求所有约数"><a href="#试除法求所有约数" class="headerlink" title="试除法求所有约数"></a>试除法求所有约数</h3><p>vector<int> get_divisors(int x)</p>
<p>{</p>
<pre><code>vector&lt;int&gt; res;

for (int i = 1; i &lt;= x / i; i ++ )

    if (x % i == 0)

    &#123;

        res.push_back(i);

        if (i != x / i) res.push_back(x / i);

    &#125;

sort(res.begin(), res.end());

return res;
</code></pre>
<p>}</p>
<h3 id="约数个数"><a href="#约数个数" class="headerlink" title="约数个数"></a>约数个数</h3><p><strong>约数个数定理和约数和定理公式推导</strong>：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV13R4y1o777">https://www.bilibili.com/video/BV13R4y1o777</a></p>
<p><strong>约数个数定理推导</strong>：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1NY41187GM">https://www.bilibili.com/video/BV1NY41187GM</a></p>
<p>约数个数.png</p>
<p>using namespace std;</p>
<p>typedef long long LL;</p>
<p>const int N &#x3D; 110, mod &#x3D; 1e9 + 7;</p>
<p>int main()</p>
<p>{</p>
<pre><code>int n;

cin &gt;&gt; n;

unordered_map&lt;int, int&gt; primes;

while (n -- )

&#123;

    int x;

    cin &gt;&gt; x;

    for (int i = 2; i &lt;= x / i; i ++ )

        while (x % i == 0)

        &#123;

            x /= i;

            primes[i] ++ ;

        &#125;

    if (x &gt; 1) primes[x] ++ ;

&#125;

LL res = 1;

for (auto p : primes) res = res * (p.second + 1) % mod;

cout &lt;&lt; res &lt;&lt; endl;

return 0;
</code></pre>
<p>}</p>
<h3 id="约数之和"><a href="#约数之和" class="headerlink" title="约数之和"></a>约数之和</h3><p><strong>约数个数定理和约数和定理公式推导</strong>：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV13R4y1o777">https://www.bilibili.com/video/BV13R4y1o777</a></p>
<p>约数之和.png</p>
<p>using namespace std;</p>
<p>typedef long long LL;</p>
<p>const int N &#x3D; 110, mod &#x3D; 1e9 + 7;</p>
<p>int main()</p>
<p>{</p>
<pre><code>int n;

cin &gt;&gt; n;

unordered_map&lt;int, int&gt; primes;

while (n -- )

&#123;

    int x;

    cin &gt;&gt; x;

    for (int i = 2; i &lt;= x / i; i ++ )

        while (x % i == 0)

        &#123;

            x /= i;

            primes[i] ++ ;

        &#125;

    if (x &gt; 1) primes[x] ++ ;

&#125;

LL res = 1;

for (auto p : primes)

&#123;

    LL a = p.first, b = p.second;

    LL t = 1;

    while (b -- ) t = (t * a + 1) % mod;//遍历b次后得到t=p^b+p^(b-1)+...+p+1

    res = res * t % mod;

&#125;

cout &lt;&lt; res &lt;&lt; endl;

return 0;
</code></pre>
<p>}</p>
<p>代码第26行解释：</p>
<p>约数之和小公式推导.png</p>
<h3 id="欧几里得算法-求最大公约数"><a href="#欧几里得算法-求最大公约数" class="headerlink" title="欧几里得算法(求最大公约数)"></a>欧几里得算法(求最大公约数)</h3><p>int gcd(int a, int b)</p>
<p>{</p>
<pre><code>return b ? gcd(b, a % b) : a;
</code></pre>
<p>}</p>
<h3 id="最小公倍数"><a href="#最小公倍数" class="headerlink" title="最小公倍数"></a>最小公倍数</h3><p>int lcm(int a, int b)</p>
<p>{</p>
<pre><code>return abs(a * b) / gcd(a, b);
</code></pre>
<p>}</p>
<h3 id="求欧拉函数"><a href="#求欧拉函数" class="headerlink" title="求欧拉函数"></a>求欧拉函数</h3><p>前置知识</p>
<p>互质：互质是公约数只有1的两个整数，叫做互质整数。</p>
<p>欧拉函数定义</p>
<p>1∼N−1</p>
<p>中与N互质的数的个数被称为欧拉函数，记为ϕ(N)。</p>
<p>若在算数基本定理中，N&#x3D;pa11pa22…pamm，则：</p>
<p>ϕ(N)&#x3D;N⋅p1−1p1⋅p2−1p2⋅…⋅pm−1pm</p>
<p>欧拉函数推导</p>
<p>首先我们要知道1,2,3…N−1,N与N互质的个数是1∼N数列去除N的质因子的倍数。</p>
<p>例如N&#x3D;10,即1,2,3,4,5,6,7,8,9,10去除N的质因子的倍数,</p>
<p>则1,\bcancel2,3,\bcancel4,\bcancel5,\bcancel6,7,\bcancel8,9,\bcancel10.</p>
<p>显然，1,3,7,9与10互质。</p>
<p>由上方结论使用容斥原理进行数学推导如下：</p>
<h4 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h4><p>int phi(int x)</p>
<p>{</p>
<pre><code>int res = x;

for (int i = 2; i &lt;= x / i; i ++ )

    if (x % i == 0)

    &#123;

        res = res / i * (i - 1);

        while (x % i == 0) x /= i;

    &#125;

if (x &gt; 1) res = res / x * (x - 1);



return res;
</code></pre>
<p>}</p>
<h3 id="线性筛法求欧拉函数"><a href="#线性筛法求欧拉函数" class="headerlink" title="线性筛法求欧拉函数"></a>线性筛法求欧拉函数</h3><p>int primes[N], cnt;     &#x2F;&#x2F; primes[]存储所有素数</p>
<p>int euler[N];           &#x2F;&#x2F; 存储每个数的欧拉函数</p>
<p>bool st[N];         &#x2F;&#x2F; st[x]存储x是否被筛掉</p>
<p>void get_eulers(int n)  &#x2F;&#x2F; 线性筛法求1~n的欧拉函数</p>
<p>{</p>
<pre><code>euler[1] = 1;

for (int i = 2; i &lt;= n; i ++ )

&#123;

    if (!st[i])

    &#123;

        primes[cnt ++ ] = i;

        euler[i] = i - 1;

    &#125;

    for (int j = 0; primes[j] &lt;= n / i; j ++ )

    &#123;

        int t = primes[j] * i;

        st[t] = true;

        if (i % primes[j] == 0)

        &#123;

            euler[t] = euler[i] * primes[j];

            break;

        &#125;

        euler[t] = euler[i] * (primes[j] - 1);

    &#125;

&#125;
</code></pre>
<p>}</p>
<h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><p>快速幂公式证明：[快速幂 - OI Wiki (oi-wiki.org)]：<a target="_blank" rel="noopener" href="https://oi-wiki.org/math/binary-exponentiation/">https://oi-wiki.org/math/binary-exponentiation/</a></p>
<p>&#x2F;&#x2F; 求 m^k mod p，时间复杂度 O(logk)。</p>
<p>&#x2F;&#x2F; m为底数，k为幂</p>
<p>int qmi(int m, int k, int p)</p>
<p>{</p>
<pre><code>int res = 1 % p, t = m;

while (k)

&#123;

    if (k&amp;1) res = res * t % p;

    t = t * t % p;

    k &gt;&gt;= 1;

&#125;

return res;
</code></pre>
<p>}</p>
<h3 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h3><p><strong>扩展欧几里得算法讲解：</strong><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1KU4y1a7E2/">https://www.bilibili.com/video/BV1KU4y1a7E2/</a></p>
<p><strong>优秀题解：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/1393">https://www.acwing.com/solution/content/1393</a></p>
<p><strong>优秀博客：</strong><a target="_blank" rel="noopener" href="https://blog.csdn.net/mango114514/article/details/121048335">https://blog.csdn.net/mango114514/article/details/121048335</a></p>
<p>x的第一个正解就是(x%k+k)%k</p>
<p>其中，k&#x3D;b&#x2F;gcd(a,b)</p>
<p>&#x2F;&#x2F; 求x, y，使得ax + by &#x3D; gcd(a, b)</p>
<p>int exgcd(int a, int b, int &amp;x, int &amp;y)</p>
<p>{</p>
<pre><code>if (!b)

&#123;

    x = 1, y = 0;

    return a;

&#125;

int d = exgcd(b, a % b, y, x);

y -= (a/b) * x;

return d;
</code></pre>
<p>}</p>
<h3 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h3><p><strong>中国剩余定理讲解：</strong><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1AN4y1N7Su/">https://www.bilibili.com/video/BV1AN4y1N7Su/</a></p>
<p>中国剩余定理.png</p>
<p>LL exgcd(LL a,LL b,LL &amp;x,LL &amp;y){</p>
<pre><code>if(b==0)&#123;

    x=1,y=0; 

    return a;

&#125;

LL d=exgcd(b,a%b,y,x);

y -= (a/b) * x;

return d;
</code></pre>
<p>}</p>
<p>LL CRT(LL m[],LL r[]){</p>
<pre><code>LL m=1,ans=0;

for(int i=1;i&lt;=n;i++)M*=m[i];

for(int i=1;i&lt;=n;i++)&#123;

    LL c=M/m[i],x,y;

    exgcd(c,m[i],x,y);

    ans=(ans+r[i]*c*x%M)%M;

&#125;

return (ans%M+M)%M;
</code></pre>
<p>}</p>
<h3 id="扩展中国剩余定理"><a href="#扩展中国剩余定理" class="headerlink" title="扩展中国剩余定理"></a>扩展中国剩余定理</h3><p><strong>扩展中国剩余定理讲解：</strong><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Ut4y1F7HG/">https://www.bilibili.com/video/BV1Ut4y1F7HG/</a></p>
<p>扩展中国剩余定理.png</p>
<p>LL exgcd(LL a,LL b,LL &amp;x,LL &amp;y){</p>
<pre><code>if(b==0)&#123;

    x=1,y=0; 

    return a;

&#125;

LL d=exgcd(b,a%b,y,x);

y -= (a/b) * x;

return d;
</code></pre>
<p>}</p>
<p>LL EXCRT(LL m[],LL r[]){</p>
<pre><code>LL m1,m2,r1,r2,p,q;

m1=m[1],r1=r[1];

for(int i=2;i&lt;=n;i++)&#123;

    m2=m[i],r2=r[i];

    LL d = exgcd(m1,m2,p,q);

    if((r2-r1)%d)&#123;

        return -1;

    &#125;

    p=p*(r2-r1)/d;//特解

    p=(p%(m2/d)+m2/d)%(m2/d);

    r1=m1*p+r1;

    m1=m1*m2/d;

&#125;

return (r1%m1+m1)%m1;
</code></pre>
<p>}</p>
<h3 id="高斯消元法"><a href="#高斯消元法" class="headerlink" title="高斯消元法"></a>高斯消元法</h3><p>高斯消元 O(n3)</p>
<p>求解例如下面方程组</p>
<p>⎧⎩⎨⎪⎪⎪⎪⎪⎪a11x1+a12x2+…+a1nxn&#x3D;b1a21x1+a22x2+…+a2nxn&#x3D;b2⋮⋮⋮⋮an1x1+an2x2+…+annxn&#x3D;bn</p>
<p><strong>高斯消元讲解：</strong><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Kd4y127vZ/">https://www.bilibili.com/video/BV1Kd4y127vZ/</a></p>
<h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><p>&#x2F;&#x2F; a[N][N]是增广矩阵</p>
<p>int gauss()</p>
<p>{</p>
<pre><code>int c, r;

for (c = 0, r = 0; c &lt; n; c ++ )

&#123;

    int t = r;

    for (int i = r; i &lt; n; i ++ )   // 找到绝对值最大的行

        if (fabs(a[i][c]) &gt; fabs(a[t][c]))

            t = i;



    if (fabs(a[t][c]) &lt; eps) continue;



    for (int i = c; i &lt;= n; i ++ ) swap(a[t][i], a[r][i]);      // 将绝对值最大的行换到最顶端

    for (int i = n; i &gt;= c; i -- ) a[r][i] /= a[r][c];      // 将当前行的首位变成1

    for (int i = r + 1; i &lt; n; i ++ )       // 用当前行将下面所有的列消成0

        if (fabs(a[i][c]) &gt; eps)

            for (int j = n; j &gt;= c; j -- )

                a[i][j] -= a[r][j] * a[i][c];



    r ++ ;

&#125;



if (r &lt; n)

&#123;

    for (int i = r; i &lt; n; i ++ )

        if (fabs(a[i][n]) &gt; eps)

            return 2; // 无解

    return 1; // 有无穷多组解

&#125;



for (int i = n - 1; i &gt;= 0; i -- )

    for (int j = i + 1; j &lt; n; j ++ )

        a[i][n] -= a[i][j] * a[j][n];



return 0; // 有唯一解
</code></pre>
<p>}</p>
<h4 id="应用-4"><a href="#应用-4" class="headerlink" title="应用"></a>应用</h4><p>using namespace std;</p>
<p>const int N &#x3D; 110;</p>
<p>const double eps &#x3D; 1e-6;</p>
<p>int n;</p>
<p>double a[N][N];</p>
<p>int gauss()</p>
<p>{</p>
<pre><code>int c, r;// c 代表 列 col ， r 代表 行 row

for (c = 0, r = 0; c &lt; n; c ++ )

&#123;

    int t = r;// 先找到当前这一列，绝对值最大的一个数字所在的行号

    for (int i = r; i &lt; n; i ++ )

        if (fabs(a[i][c]) &gt; fabs(a[t][c]))

            t = i;



    if (fabs(a[t][c]) &lt; eps) continue;// 如果当前这一列的最大数都是 0 ，那么所有数都是 0，就没必要去算了，因为它的约束方程，可能在上面几行



    for (int i = c; i &lt; n + 1; i ++ ) swap(a[t][i], a[r][i]);//// 把当前这一行，换到最上面（不是第一行，是第 r 行）去

    for (int i = n; i &gt;= c; i -- ) a[r][i] /= a[r][c];// 把当前这一行的第一个数，变成 1， 方程两边同时除以 第一个数，必须要到着算，不然第一个数直接变1，系数就被篡改，后面的数字没法算

    for (int i = r + 1; i &lt; n; i ++ )// 把当前列下面的所有数，全部消成 0

        if (fabs(a[i][c]) &gt; eps)// 如果非0 再操作，已经是 0就没必要操作了

            for (int j = n; j &gt;= c; j -- )// 从后往前，当前行的每个数字，都减去对应列 * 行首非0的数字，这样就能保证第一个数字是 a[i][0] -= 1*a[i][0];

                a[i][j] -= a[r][j] * a[i][c];



    r ++ ;// 这一行的工作做完，换下一行

&#125;



if (r &lt; n)// 说明剩下方程的个数是小于 n 的，说明不是唯一解，判断是无解还是无穷多解

&#123;// 因为已经是阶梯型，所以 r ~ n-1 的值应该都为 0

    for (int i = r; i &lt; n; i ++ )// 

        if (fabs(a[i][n]) &gt; eps)// a[i][n] 代表 b_i ,即 左边=0，右边=b_i,0 != b_i, 所以无解。

            return 2;

    return 1;// 否则， 0 = 0，就是r ~ n-1的方程都是多余方程

&#125;

// 唯一解 ↓，从下往上回代，得到方程的解

for (int i = n - 1; i &gt;= 0; i -- )

    for (int j = i + 1; j &lt; n; j ++ )

        a[i][n] -= a[j][n] * a[i][j];//因为只要得到解，所以只用对 b_i 进行操作，中间的值，可以不用操作，因为不用输出



return 0;
</code></pre>
<p>}</p>
<p>int main()</p>
<p>{</p>
<pre><code>cin &gt;&gt; n;

for (int i = 0; i &lt; n; i ++ )

    for (int j = 0; j &lt; n + 1; j ++ )

        cin &gt;&gt; a[i][j];



int t = gauss();



if (t == 0)

&#123;

    for (int i = 0; i &lt; n; i ++ ) printf(&quot;%.2lf\n&quot;, a[i][n]);

&#125;

else if (t == 1) puts(&quot;Infinite group solutions&quot;);

else puts(&quot;No solution&quot;);

return 0;
</code></pre>
<p>}</p>
<h3 id="求组合数"><a href="#求组合数" class="headerlink" title="求组合数"></a>求组合数</h3><h4 id="递推法求组合数"><a href="#递推法求组合数" class="headerlink" title="递推法求组合数"></a>递推法求组合数</h4><p><strong>排列组合详细讲解：</strong><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1e7411J7SC/">https://www.bilibili.com/video/BV1e7411J7SC/</a></p>
<p>杨辉三角.png</p>
<p>杨辉三角组合数.png</p>
<p>&#x2F;&#x2F; c[a][b] 表示从a个苹果中选b个的方案数</p>
<p>int c[N][N];</p>
<p>for (int i &#x3D; 0; i &lt; N; i ++ )</p>
<pre><code>for (int j = 0; j &lt;= i; j ++ )

    if (!j) c[i][j] = 1;

    else c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;
</code></pre>
<p>&#x2F;&#x2F;本质上杨辉三角</p>
<h4 id="通过预处理逆元的方式求组合数"><a href="#通过预处理逆元的方式求组合数" class="headerlink" title="通过预处理逆元的方式求组合数"></a>通过预处理逆元的方式求组合数</h4><h4 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h4><p>&#x2F;&#x2F; 首先预处理出所有阶乘取模的余数fact[N]，以及所有阶乘取模的逆元infact[N]</p>
<p>&#x2F;&#x2F; 如果取模的数是质数，可以用费马小定理求逆元</p>
<p>int qmi(int a, int k, int p)    &#x2F;&#x2F; 快速幂模板</p>
<p>{</p>
<pre><code>int res = 1;

while (k)

&#123;

    if (k &amp; 1) res = (LL)res * a % p;

    a = (LL)a * a % p;

    k &gt;&gt;= 1;

&#125;

return res;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; 预处理阶乘的余数和阶乘逆元的余数</p>
<p>fact[0] &#x3D; infact[0] &#x3D; 1;</p>
<p>for (int i &#x3D; 1; i &lt; N; i ++ )</p>
<p>{</p>
<pre><code>fact[i] = (LL)fact[i - 1] * i % mod;

infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
</code></pre>
<p>}</p>
<h4 id="应用-5"><a href="#应用-5" class="headerlink" title="应用"></a>应用</h4><p>using namespace std;</p>
<p>typedef long long LL;</p>
<p>const int N &#x3D; 100010,mod&#x3D;1e9+7;&#x2F;&#x2F;1e9+7是质数所以与[1,1e9+7)中的数互质</p>
<p>int fact[N],infact[N];</p>
<p>int qmi(int a,int k,int p){</p>
<pre><code>int res=1;

while(k)&#123;

    if(k&amp;1)res=(LL)res*a%p;

    a=(LL)a*a%p;

    k&gt;&gt;=1;

&#125;

return res;
</code></pre>
<p>}</p>
<p>int main()</p>
<p>{</p>
<pre><code>fact[0]=infact[0]=1;

for (int i = 1; i &lt;= N; i ++ )&#123;

    fact[i]=(LL)fact[i-1]*i%mod;

    infact[i]=(LL)infact[i-1]*qmi(i,mod-2,mod)%mod;

&#125;



int n;

scanf(&quot;%d&quot;,&amp;n);

while (n -- )&#123;

    int a,b;

    scanf(&quot;%d%d&quot;, &amp;a, &amp;b);

    printf(&quot;%d\n&quot;,(LL)fact[a]*infact[b]%mod*infact[a-b]%mod);

&#125;

return 0;
</code></pre>
<p>}</p>
<h3 id="Lucas定理求组合数"><a href="#Lucas定理求组合数" class="headerlink" title="Lucas定理求组合数"></a>Lucas定理求组合数</h3><p><strong>Lucas定理证明：</strong><a target="_blank" rel="noopener" href="https://blog.csdn.net/Qiuker_jl/article/details/109528164">https://blog.csdn.net/Qiuker_jl/article/details/109528164</a></p>
<h4 id="模板-2"><a href="#模板-2" class="headerlink" title="模板"></a>模板</h4><p>&#x2F;&#x2F; 若p是质数，则对于任意整数 1 &lt;&#x3D; m &lt;&#x3D; n，有：</p>
<p>&#x2F;&#x2F; C(n, m) &#x3D; C(n % p, m % p) * C(n &#x2F; p, m &#x2F; p) (mod p)</p>
<p>int qmi(int a, int k, int p)  &#x2F;&#x2F; 快速幂模板</p>
<p>{</p>
<pre><code>int res = 1 % p;

while (k)

&#123;

    if (k &amp; 1) res = (LL)res * a % p;

    a = (LL)a * a % p;

    k &gt;&gt;= 1;

&#125;

return res;
</code></pre>
<p>}</p>
<p>int C(int a, int b, int p)  &#x2F;&#x2F; 通过定理求组合数C(a, b)</p>
<p>{</p>
<pre><code>if (a &lt; b) return 0;



LL x = 1, y = 1;  // x是分子，y是分母

for (int i = a, j = 1; j &lt;= b; i --, j ++ )

&#123;

    x = (LL)x * i % p;

    y = (LL) y * j % p;

&#125;



return x * (LL)qmi(y, p - 2, p) % p;
</code></pre>
<p>}</p>
<p>int lucas(LL a, LL b, int p)</p>
<p>{</p>
<pre><code>if (a &lt; p &amp;&amp; b &lt; p) return C(a, b, p);

return (LL)C(a % p, b % p, p) * lucas(a / p, b / p, p) % p;
</code></pre>
<p>}</p>
<h4 id="应用-6"><a href="#应用-6" class="headerlink" title="应用"></a>应用</h4><p>using namespace std;</p>
<p>typedef long long LL;</p>
<p>int qmi(int a,int k,int p)</p>
<p>{</p>
<pre><code>int res = 1;

while(k)

&#123;

    if(k&amp;1)res = (LL)res*a%p;

    a = (LL)a*a%p;

    k&gt;&gt;=1;

&#125;

return res;
</code></pre>
<p>}</p>
<p>int C(int a,int b,int p)&#x2F;&#x2F;自变量类型int</p>
<p>{</p>
<pre><code>if(b&gt;a)return 0;//漏了边界条件

int res = 1;

// a!/(b!(a-b)!) = (a-b+1)*...*a / b! 分子有b项

for(int i=1,j=a;i&lt;=b;i++,j--)//i&lt;=b而不是&lt;

&#123;

    res = (LL)res*j%p;

    res = (LL)res*qmi(i,p-2,p)%p;

&#125;

return res;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F;对公式敲</p>
<p>int lucas(LL a,LL b,int p)</p>
<p>{</p>
<pre><code>if(a&lt;p &amp;&amp; b&lt;p)return C(a,b,p);//lucas递归终点是C_&#123;bk&#125;^&#123;ak&#125;

return (LL)C(a%p,b%p,p)*lucas(a/p,b/p,p)%p;//a%p后肯定是&lt;p的,所以可以用C(),但a/p后不一定&lt;p 所以用lucas继续递归
</code></pre>
<p>}</p>
<p>int main()</p>
<p>{</p>
<pre><code>int n;

cin &gt;&gt; n;

while(n--)

&#123;

    LL a,b;

    int p;

    cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;

    cout &lt;&lt; lucas(a,b,p) &lt;&lt; endl;

&#125;

return 0;
</code></pre>
<p>}</p>
<h3 id="分解质因数法求组合数"><a href="#分解质因数法求组合数" class="headerlink" title="分解质因数法求组合数"></a>分解质因数法求组合数</h3><h4 id="模板-3"><a href="#模板-3" class="headerlink" title="模板"></a>模板</h4><p>当我们需要求出组合数的真实值，而非对某个数的余数时，分解质因数的方式比较好用：</p>
<pre><code>1. 筛法求出范围内的所有质数

2. 通过 C(a, b) = a! / b! / (a - b)! 这个公式求出每个质因子的次数。 n! 中p的次数是 n / p + n / p^2 + n / p^3 + ...

3. 用高精度乘法将所有质因子相乘
</code></pre>
<p>int primes[N], cnt;     &#x2F;&#x2F; 存储所有质数</p>
<p>int sum[N];     &#x2F;&#x2F; 存储每个质数的次数</p>
<p>bool st[N];     &#x2F;&#x2F; 存储每个数是否已被筛掉</p>
<p>void get_primes(int n)      &#x2F;&#x2F; 线性筛法求素数</p>
<p>{</p>
<pre><code>for (int i = 2; i &lt;= n; i ++ )

&#123;

    if (!st[i]) primes[cnt ++ ] = i;

    for (int j = 0; primes[j] &lt;= n / i; j ++ )

    &#123;

        st[primes[j] * i] = true;

        if (i % primes[j] == 0) break;

    &#125;

&#125;
</code></pre>
<p>}</p>
<p>int get(int n, int p)       &#x2F;&#x2F; 求n！中的次数</p>
<p>{</p>
<pre><code>int res = 0;

while (n)

&#123;

    res += n / p;

    n /= p;

&#125;

return res;
</code></pre>
<p>}</p>
<p>vector<int> mul(vector<int> a, int b)       &#x2F;&#x2F; 高精度乘低精度模板</p>
<p>{</p>
<pre><code>vector&lt;int&gt; c;

int t = 0;

for (int i = 0; i &lt; a.size(); i ++ )

&#123;

    t += a[i] * b;

    c.push_back(t % 10);

    t /= 10;

&#125;



while (t)

&#123;

    c.push_back(t % 10);

    t /= 10;

&#125;



return c;
</code></pre>
<p>}</p>
<p>get_primes(a);  &#x2F;&#x2F; 预处理范围内的所有质数</p>
<p>for (int i &#x3D; 0; i &lt; cnt; i ++ )     &#x2F;&#x2F; 求每个质因数的次数</p>
<p>{</p>
<pre><code>int p = primes[i];

sum[i] = get(a, p) - get(b, p) - get(a - b, p);
</code></pre>
<p>}</p>
<p>vector<int> res;</p>
<p>res.push_back(1);</p>
<p>for (int i &#x3D; 0; i &lt; cnt; i ++ )     &#x2F;&#x2F; 用高精度乘法将所有质因子相乘</p>
<pre><code>for (int j = 0; j &lt; sum[i]; j ++ )

    res = mul(res, primes[i]);
</code></pre>
<h4 id="应用-7"><a href="#应用-7" class="headerlink" title="应用"></a>应用</h4><p>using namespace std;</p>
<p>const int N &#x3D; 5010;</p>
<p>int primes[N],cnt&#x3D;0;</p>
<p>&#x2F;&#x2F; v[i] 记录数字 i 为素数还是合数，v[i]&#x3D;true时 i 为合数，否则 i 为素数</p>
<p>bool v[N];</p>
<p>&#x2F;&#x2F; sum[i]&#x3D;c 表示质数 i 的个数为 c</p>
<p>int sum[N];</p>
<p>&#x2F;&#x2F; 线性筛法</p>
<p>void get_primes(int n)</p>
<p>{</p>
<pre><code>for(int i=2;i&lt;=n;++i)

&#123;

    // i为质数，则存在primes中

    if(!v[i])primes[cnt++]=i;

    // 给当前数i乘上一个质因子pj

    for(int j=0;primes[j]&lt;=n/i;++j)

    &#123;

        v[primes[j]*i]=true;

        if(i%primes[j]==0)break;

    &#125;

&#125;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; 计算 n 里面含有质数 p 的个数，这里的计算是不重不漏的。</p>
<p>&#x2F;&#x2F; p^k的倍数会被计算k次：第一次算p的倍数时，被加一次；第二次算p^2的倍数时，被加一次；第三次算p^3的倍数时，被加一次…第k次算p^k的倍数时，被加一次。总共被加了k次，是不重不漏的。</p>
<p>int get(int n,int p)</p>
<p>{</p>
<pre><code>int res=0;

while(n)

&#123;

    res+=n/p;

    n/=p;

&#125;

return res;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; A * b：把 b 看成一个整体，然后与 A 中每一位相乘，A中的数字采用小端存储，即低位数字存储在数组的前面，高位数字存储在数组的后面</p>
<p>vector<int> mul(const vector<int>&amp; A,const int b)</p>
<p>{</p>
<pre><code>if(b==0)return &#123;0&#125;;

vector&lt;int&gt; res;

// t 表示乘法进位，这里的进位不限于0 1，可以为任意数字

for(int i=0,t=0,n=A.size();i&lt;n||t&gt;0;++i)

&#123;

    // 获得当前位的乘积和

    if(i&lt;n)t+=A[i]*b;

    // 添加个位数字

    res.push_back(t%10);

    // 保留进位

    t/=10;

&#125;



 // 如 1234 * 0 = 0000，需要删除前导0

while(res.size()&gt;1&amp;&amp;res.back()==0)res.pop_back();

return res;
</code></pre>
<p>}</p>
<p>int main()</p>
<p>{</p>
<pre><code>int a,b;cin&gt;&gt;a&gt;&gt;b;



// 将 a 分解质因数

get_primes(a);



for(int i=0;i&lt;cnt;++i)

&#123;

    // 当前的质数为 p

    int p=primes[i];

    // 用分子里面 p 的个数减去分母里面 p 的个数。这里的计算组合数的公式为a!/(b!*(a-b)!)，因此用 a 里面 p 的个数减去 b 里面 p 的个数和 (a-b) 里面 p 的个数。

    sum[i]=get(a,p)-get(b,p)-get(a-b,p);

&#125;



// 使用高精度乘法把所有质因子乘到一块去就好了

vector&lt;int&gt; res=&#123;1&#125;;

for(int i=0;i&lt;cnt;++i)

    // res*p^k，这里是k个p相乘，不是k*p，所以需要使用一个循环

    for(int j=0;j&lt;sum[i];++j)

        res=mul(res,primes[i]);



// 倒序打印 res 即可，由于采用小端存储，所以高位在后，从后往前打印即可

for(int i=res.size()-1;i&gt;=0;i--)printf(&quot;%d&quot;,res[i]);

return 0;
</code></pre>
<p>}</p>
<h3 id="容斥原理应用"><a href="#容斥原理应用" class="headerlink" title="容斥原理应用"></a>容斥原理应用</h3><p>经典例题：[890. 能被整除的数 - AcWing题库]：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/892/">https://www.acwing.com/problem/content/892/</a></p>
<p>AC代码：</p>
<p> using namespace std;</p>
<p> typedef long long LL;</p>
<p> const int N &#x3D; 20;</p>
<p> int p[N], n, m;</p>
<p> int main() {</p>
<p> cin &gt;&gt; n &gt;&gt; m;</p>
<p> for(int i &#x3D; 0; i &lt; m; i++) cin &gt;&gt; p[i];</p>
<p> int res &#x3D; 0;</p>
<p> &#x2F;&#x2F;枚举从1 到 1111…(m个1)的每一个集合状态, (至少选中一个集合)</p>
<p> for(int i &#x3D; 1; i &lt; 1 &lt;&lt; m; i++) {</p>
<p>   int t &#x3D; 1;             &#x2F;&#x2F;选中集合对应质数的乘积</p>
<p>   int s &#x3D; 0;             &#x2F;&#x2F;选中的集合数量</p>
<p>   &#x2F;&#x2F;枚举当前状态的每一位</p>
<p>   for(int j &#x3D; 0; j &lt; m; j++){</p>
<pre><code>   //选中一个集合

   if(i &gt;&gt; j &amp; 1)&#123;

       //乘积大于n, 则n/t = 0, 跳出这轮循环

       if((LL)t * p[j] &gt; n)&#123;    

           t = -1;

           break;

       &#125;

       s++;                  //有一个1，集合数量+1

       t *= p[j];

   &#125;
</code></pre>
<p>   }</p>
<p>   if(t &#x3D;&#x3D; -1) continue;  </p>
<p>   if(s &amp; 1) res +&#x3D; n &#x2F; t;              &#x2F;&#x2F;选中奇数个集合, 则系数应该是1, n&#x2F;t为当前这种状态的集合数量</p>
<p>   else res -&#x3D; n &#x2F; t;                      &#x2F;&#x2F;反之则为 -1</p>
<p> }</p>
<p> cout &lt;&lt; res &lt;&lt; endl;</p>
<p> return 0;</p>
<p> }</p>
<p>详细题解：[AcWing 890. 能被整除的数 - AcWing]：<a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/29702/">https://www.acwing.com/solution/content/29702/</a></p>
<h3 id="博弈论"><a href="#博弈论" class="headerlink" title="博弈论"></a>博弈论</h3><h4 id="NIM游戏"><a href="#NIM游戏" class="headerlink" title="NIM游戏"></a>NIM游戏</h4><p>定理1：必胜态的后继状态至少存在一个必败态</p>
<p>定理2：必败态的后继状态均为必胜态</p>
<p><strong>NIM游戏科普：</strong>[尼姆游戏（学霸就是这样欺负人的）_哔哩哔哩_bilibili]：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1ek4y1q7JD/">https://www.bilibili.com/video/BV1ek4y1q7JD/</a></p>
<p>[再看nim游戏_哔哩哔哩_bilibili]：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1nt4y1C7Sk/">https://www.bilibili.com/video/BV1nt4y1C7Sk/</a></p>
<p>经典例题：[P2197 【模板】nim 游戏 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)]：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2197">https://www.luogu.com.cn/problem/P2197</a></p>
<p>AC代码：</p>
<p> using namespace std;</p>
<p> int T;</p>
<p> int main() {</p>
<pre><code> cin &gt;&gt; T;

 while (T--) &#123;

     int n;

     scanf(&quot;%d&quot;, &amp;n);

     int ans = 0;

     for (int i = 0; i &lt; n; i++) &#123;

         int k;

         scanf(&quot;%d&quot;, &amp;k);

         ans ^= k;

     &#125;

     if (ans)

         puts(&quot;Yes&quot;);

     else

         puts(&quot;No&quot;);

 &#125;

 return 0;
</code></pre>
<p> }</p>
<p>结论：</p>
<p>若初态为必胜态(a1⊕a2⊕…⊕an≠0</p>
<p>).则先手必胜</p>
<p>若初态为必败态(a1⊕a2⊕…⊕an&#x3D;0</p>
<p>).则先手必败</p>
<p>视频讲解：[581 尼姆（Nim）游戏【博弈论】_哔哩哔哩_bilibili]：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1ns4y1D7dg/">https://www.bilibili.com/video/BV1ns4y1D7dg/</a></p>
<p>台阶型NIM游戏</p>
<p>经典例题：[892. 台阶-Nim游戏 - AcWing题库]：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/894/">https://www.acwing.com/problem/content/894/</a></p>
<p>AC代码：</p>
<p> using namespace std;</p>
<p> const int N &#x3D; 100010;</p>
<p> int main()</p>
<p> {</p>
<pre><code>  int n;

  scanf(&quot;%d&quot;, &amp;n);
</code></pre>
<p>   int res &#x3D; 0;</p>
<pre><code>  for (int i = 1; i &lt;= n; i ++ )

  &#123;

      int x;

      scanf(&quot;%d&quot;, &amp;x);

      if (i &amp; 1) res ^= x;

  &#125;

  if (res) puts(&quot;Yes&quot;);
</code></pre>
<p>   else puts(“No”);</p>
<pre><code>  return 0;
</code></pre>
<p> }</p>
<p>结论：若奇数台阶上的a1⊕a3⊕a5⊕…≠0，则先手必胜，反之先手必败。</p>
<p>视频讲解：[582 台阶型 Nim游戏【博弈论】_哔哩哔哩_bilibili]：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV18M411M7TC/">https://www.bilibili.com/video/BV18M411M7TC/</a></p>
<p>集合型NIM游戏</p>
<p>经典例题：[893. 集合-Nim游戏 - AcWing题库]：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/895/">https://www.acwing.com/problem/content/895/</a></p>
<p>AC代码：</p>
<p> using namespace std;</p>
<p> const int N&#x3D;110,M&#x3D;10010;</p>
<p> int n,m;</p>
<p> int f[M],s[N];&#x2F;&#x2F;s存储的是可供选择的集合,f存储的是所有可能出现过的情况的sg值</p>
<p> int sg(int x)</p>
<p> {</p>
<pre><code>  if(f[x]!=-1) return f[x];

  //因为取石子数目的集合是已经确定了的,所以每个数的sg值也都是确定的,如果存储过了,直接返回即可

  unordered_set&lt;int&gt; S;

  //set代表的是有序集合(注:因为在函数内部定义,所以下一次递归中的S不与本次相同)

  for(int i=0;i&lt;m;i++)

  &#123;

      int sum=s[i];

      if(x&gt;=sum) S.insert(sg(x-sum));

      //先延伸到终点的sg值后,再从后往前排查出所有数的sg值

  &#125;

  for(int i=0;;i++)

  //循环完之后可以进行选出最小的没有出现的自然数的操作

   if(!S.count(i))

    return f[x]=i;
</code></pre>
<p> }</p>
<p> int main()</p>
<p> {</p>
<pre><code>  cin&gt;&gt;m;

  for(int i=0;i&lt;m;i++)

  cin&gt;&gt;s[i];



  cin&gt;&gt;n;

  memset(f,-1,sizeof(f));//初始化f均为-1,方便在sg函数中查看x是否被记录过



  int res=0;

  for(int i=0;i&lt;n;i++)

  &#123;

      int x;

      cin&gt;&gt;x;

      res^=sg(x);

      //观察异或值的变化,基本原理与Nim游戏相同

  &#125;



  if(res) printf(&quot;Yes&quot;);

  else printf(&quot;No&quot;);



  return 0;
</code></pre>
<p> }</p>
<p>思路：转换成有向图游戏</p>
<p>视频讲解：[583 有向图游戏 SG函数【博弈论】_哔哩哔哩_bilibili]：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1eT411B7A8/">https://www.bilibili.com/video/BV1eT411B7A8/</a></p>
<h2 id="五、动态规划"><a href="#五、动态规划" class="headerlink" title="五、动态规划"></a>五、动态规划</h2><p>动态规划三大特征：最优子结构、无后效性、重复子问题</p>
<p>闫式dp分析法.jpg</p>
<h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><p>01背包每件物品只能装一次</p>
<p>完全背包每件物品可以装无限次</p>
<p>多重背包每件物品只能装有限次（多次）</p>
<p>分组背包每组只能选择一件物品装入（01背包升级）</p>
<p>相关链接：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/166439661">https://zhuanlan.zhihu.com/p/166439661</a></p>
<p>01背包问题</p>
<p>01背包每件物品只能装一次</p>
<p>视频讲解：[408 背包DP【模板】01背包_哔哩哔哩_bilibili]：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1kp4y1e794/">https://www.bilibili.com/video/BV1kp4y1e794/</a></p>
<p>01背包DP分析.png</p>
<p>01背包.png</p>
<p>using namespace std;</p>
<p>const int N&#x3D;1010;</p>
<p>int n,m;</p>
<p>int v[N],w[N];&#x2F;&#x2F;v代表体积，w代表价值</p>
<p>int f[N][N];</p>
<p>int main(){</p>
<pre><code>cin&gt;&gt;n&gt;&gt;m;

for(int i=1;i&lt;=n;i++)cin&gt;&gt;v[i]&gt;&gt;w[i];

for(int i=1;i&lt;=n;i++)//i代表这n件物品

&#123;

    for(int j=1;j&lt;=m;j++)&#123;//j代表背包容量

        if(v[i]&gt;j)//如果v[i]的容量大于当前的背包容量则不装进行下一个

            f[i][j]=f[i-1][j];

        else f[i][j]=max(f[i-1][j],f[i-1][j-v[i]]+w[i]);//如果v[i]的容量小于当前背包容量则可以选择装与不装得到最大值 

    &#125;

&#125;



cout&lt;&lt;f[n][m]&lt;&lt;endl;//输出最后的一个一定是最大的

return 0;
</code></pre>
<p>}</p>
<p>01背包，使用滚动数组，倒序遍历</p>
<p>using namespace std;</p>
<p>const int N&#x3D;1010;</p>
<p>int n,m;</p>
<p>int v[N],w[N];&#x2F;&#x2F;v代表体积，w代表价值</p>
<p>int dp[N];</p>
<p>int main(){</p>
<pre><code>cin&gt;&gt;n&gt;&gt;m;

for(int i=1;i&lt;=n;i++)//i代表这n件物品

&#123;

    cin&gt;&gt;v[i]&gt;&gt;w[i];//在线算法

    for(int j=m;j&gt;=v[i];j--)&#123;//j代表背包容量，滚动数组必须倒序遍历

        dp[j]=max(dp[j],dp[j-v[i]]+w[i]);//滚动数组

    &#125;

&#125;

cout&lt;&lt;dp[m]&lt;&lt;endl;//输出最后的一个一定是最大的

return 0;
</code></pre>
<p>}</p>
<p>状态转移方程：dp[j]&#x3D;max(dp[j],dp[j-v[i]]+w[i]);</p>
<h4 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h4><p>完全背包每件物品可以装无限次</p>
<p>视频讲解：[409 背包DP 完全背包【动态规划】_哔哩哔哩_bilibili]：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV15v411y7Qz/">https://www.bilibili.com/video/BV15v411y7Qz/</a></p>
<p>using namespace std;</p>
<p>int v[N],w[N];</p>
<p>int dp[N];</p>
<p>int main(){</p>
<pre><code>int n,m;

cin&gt;&gt;n&gt;&gt;m;

for(int i=1;i&lt;=n;i++)&#123;//遍历物品

    cin&gt;&gt;v[i]&gt;&gt;w[i];//在线算法

    for(int j=v[i];j&lt;=m;j++)&#123;//正序遍历背包容量

        dp[j]=max(dp[j],dp[j-v[i]]+w[i]);//滚动数组

    &#125;

&#125;

cout&lt;&lt;dp[m]&lt;&lt;endl;//输出答案

return 0;
</code></pre>
<p>}</p>
<p>完全背包问题和01背包优化版的区别在于第二重循环的v[i]和m做交换</p>
<p>状态转移方程：dp[j]&#x3D;max(dp[j],dp[j-v[i]]+w[i]);</p>
<h4 id="多重背包问题1"><a href="#多重背包问题1" class="headerlink" title="多重背包问题1"></a>多重背包问题1</h4><p>多重背包每件物品只能装有限次（多次）</p>
<p>using namespace std;</p>
<p>int n,m;</p>
<p>int v[N],w[N],s[N];</p>
<p>int dp[N][N];</p>
<p>int main(){</p>
<pre><code>cin&gt;&gt;n&gt;&gt;m;

for(int i=1;i&lt;=n;i++)cin&gt;&gt;v[i]&gt;&gt;w[i]&gt;&gt;s[i];

for(int i=1;i&lt;=n;i++)//物品

    for(int j=0;j&lt;=m;j++)//背包容量

        for(int k=0;k&lt;=s[i]&amp;&amp;k*v[i]&lt;=j;k++)

            dp[i][j]=max(dp[i][j],dp[i-1][j-v[i]*k]+w[i]*k);

cout&lt;&lt;dp[n][m]&lt;&lt;endl;

return 0;
</code></pre>
<p>}</p>
<p>状态转移方程：dp[i][j]&#x3D;max(dp[i][j],dp[i-1][j-v[i]*k]+w[i]*k);k为第i个物品的个数</p>
<h4 id="多重背包问题2-二进制优化"><a href="#多重背包问题2-二进制优化" class="headerlink" title="多重背包问题2(二进制优化)"></a>多重背包问题2(二进制优化)</h4><p>思路：转换成2进制，再用01背包求解</p>
<p>视频讲解：[410 背包DP 多重背包 二进制优化【动态规划】_哔哩哔哩_bilibili]：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1MA41177cg/">https://www.bilibili.com/video/BV1MA41177cg/</a></p>
<p>using namespace std;</p>
<p>const int N &#x3D; 12010, M &#x3D; 2010;</p>
<p>int n, m;</p>
<p>int v[N], w[N];</p>
<p>int f[M];</p>
<p>int main()</p>
<p>{</p>
<pre><code>cin &gt;&gt; n &gt;&gt; m;



int cnt = 0;

for (int i = 1; i &lt;= n; i ++ )

&#123;

    int a, b, s;

    cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;

    int k = 1;

    while (k &lt;= s)

    &#123;

        cnt ++ ;

        v[cnt] = a * k;

        w[cnt] = b * k;

        s -= k;

        k *= 2;

    &#125;

    if (s &gt; 0)

    &#123;

        cnt ++ ;

        v[cnt] = a * s;

        w[cnt] = b * s;

    &#125;

&#125;//二进制优化操作



n = cnt;



for (int i = 1; i &lt;= n; i ++ )

    for (int j = m; j &gt;= v[i]; j -- )

        f[j] = max(f[j], f[j - v[i]] + w[i]);



cout &lt;&lt; f[m] &lt;&lt; endl;



return 0;
</code></pre>
<p>}</p>
<h4 id="分组背包问题"><a href="#分组背包问题" class="headerlink" title="分组背包问题"></a>分组背包问题</h4><p>分组背包每组只能选择一件物品装入</p>
<p>视频讲解：[416 背包DP 分组背包【动态规划】_哔哩哔哩_bilibili]：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV16a411w77X/">https://www.bilibili.com/video/BV16a411w77X/</a></p>
<p>using namespace std;</p>
<p>const int N&#x3D;110;</p>
<p>int f[N];</p>
<p>int v[N][N],w[N][N],s[N];</p>
<p>int n,m,k;</p>
<p>int main(){</p>
<pre><code>cin&gt;&gt;n&gt;&gt;m;

for(int i=0;i&lt;n;i++)&#123;

    cin&gt;&gt;s[i];

    for(int j=0;j&lt;s[i];j++)&#123;

        cin&gt;&gt;v[i][j]&gt;&gt;w[i][j];

    &#125;

&#125;



for(int i=0;i&lt;n;i++)&#123;

    for(int j=m;j&gt;=0;j--)&#123;

        for(int k=0;k&lt;s[i];k++)&#123;    //for(int k=s[i];k&gt;=1;k--)也可以

            if(j&gt;=v[i][k])

                f[j]=max(f[j],f[j-v[i][k]]+w[i][k]);  

        &#125;

    &#125;

&#125;

cout&lt;&lt;f[m]&lt;&lt;endl;
</code></pre>
<p>}</p>
<p>状态转移方程：f[j]&#x3D;max(f[j],f[j-v[i][k]]+w[i][k]);</p>
<p>线性DP</p>
<p>数字三角形</p>
<p>视频讲解：[402 线性DP 数字三角形【动态规划】_哔哩哔哩_bilibili]：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Rk4y1173p/">https://www.bilibili.com/video/BV1Rk4y1173p/</a></p>
<p>数字三角形DP分析.png</p>
<p>using namespace std;</p>
<p>const int N&#x3D;510,INF&#x3D;1e9;</p>
<p>int n;</p>
<p>int a[N][N];</p>
<p>int f[N][N];</p>
<p>int main(){</p>
<pre><code>scanf(&quot;%d&quot;,&amp;n);

for(int i=1;i&lt;=n;i++)&#123;

    for(int j=1;j&lt;=i;j++)&#123;

        scanf(&quot;%d&quot;,&amp;a[i][j]);

    &#125;

&#125;

for(int i=0;i&lt;=n;i++)&#123;

    for(int j=0;j&lt;=i+1;j++)&#123;

        f[i][j]=-INF;

    &#125;

&#125;

f[1][1]=a[1][1];

for(int i=2;i&lt;=n;i++)

    for(int j=1;j&lt;=i;j++)

        f[i][j]=max(f[i-1][j-1]+a[i][j],f[i-1][j]+a[i][j]);//状态转移方程

int res=-INF;

for(int i=1;i&lt;=n;i++)res=max(res,f[n][i]);

printf(&quot;%d&quot;,res);

return 0;
</code></pre>
<p>}</p>
<p>状态转移方程：f[i][j]&#x3D;max(f[i-1][j-1]+a[i][j],f[i-1][j]+a[i][j]);</p>
<h3 id="最长上升子序列1"><a href="#最长上升子序列1" class="headerlink" title="最长上升子序列1"></a>最长上升子序列1</h3><p>视频讲解：[403 线性DP 最长上升子序列【动态规划】_哔哩哔哩_bilibili]：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1KK4y1e7t7/">https://www.bilibili.com/video/BV1KK4y1e7t7/</a></p>
<p>using namespace std;</p>
<p>const int N &#x3D; 1010;</p>
<p>int n;</p>
<p>int a[N],f[N];</p>
<p>int main()</p>
<p>{</p>
<pre><code>scanf(&quot;%d&quot;, &amp;n);

for (int i = 1; i &lt;= n; i ++ )scanf(&quot;%d&quot;,&amp;a[i]);

for (int i = 1; i &lt;= n; i ++ )&#123;

    f[i]=1;//只有a[i]一个数

    for (int j = 1; j &lt;= i; j ++ )

        if(a[j]&lt;a[i])

            f[i]=max(f[i],f[j]+1);

&#125;

int res=0;

for (int i = 1; i &lt;= n; i ++ )res=max(res,f[i]);

printf(&quot;%d\n&quot;,res);

return 0;
</code></pre>
<p>}</p>
<p>状态转移方程：if(a[j]&lt;a[i])f[i]&#x3D;max(f[i],f[j]+1);</p>
<h4 id="最长上升子序列2-二分优化"><a href="#最长上升子序列2-二分优化" class="headerlink" title="最长上升子序列2(二分优化)"></a>最长上升子序列2(二分优化)</h4><p>视频讲解：[404 线性DP 最长上升子序列 二分优化_哔哩哔哩_bilibili]：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Kp4y1e77H/">https://www.bilibili.com/video/BV1Kp4y1e77H/</a></p>
<p>using namespace std;</p>
<p>const int N &#x3D; 100010;</p>
<p>int n;</p>
<p>int a[N];</p>
<p>int q[N];</p>
<p>int main()</p>
<p>{</p>
<pre><code>scanf(&quot;%d&quot;, &amp;n);

for (int i = 0; i &lt; n; i ++ ) scanf(&quot;%d&quot;, &amp;a[i]);



int len = 0;

for (int i = 0; i &lt; n; i ++ )

&#123;

    int l = 0, r = len;

    while (l &lt; r)

    &#123;

        int mid = l + r + 1 &gt;&gt; 1;

        if (q[mid] &lt; a[i]) l = mid;

        else r = mid - 1;

    &#125;

    len = max(len, r + 1);

    q[r + 1] = a[i];//替换或添加

&#125;



printf(&quot;%d\n&quot;, len);



return 0;
</code></pre>
<p>}</p>
<h4 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h4><p>视频讲解：[405 线性DP 最长公共子序列【动态规划】_哔哩哔哩_bilibili]：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1EK411K7Eb/">https://www.bilibili.com/video/BV1EK411K7Eb/</a></p>
<p>using namespace std;</p>
<p>const int N&#x3D;1010;</p>
<p>int n,m;</p>
<p>char a[N],b[N];</p>
<p>int f[N][N];</p>
<p>int main()</p>
<p>{</p>
<pre><code>cin&gt;&gt;n&gt;&gt;m&gt;&gt;a+1&gt;&gt;b+1;

for (int i = 1; i &lt;= n; i ++ )&#123;

    for (int j = 1; j &lt;= m; j ++ )&#123;

        f[i][j]=max(f[i-1][j],f[i][j-1]);

        if(a[i]==b[j])f[i][j]=max(f[i][j],f[i-1][j-1]+1);

    &#125;

&#125;

cout&lt;&lt;f[n][m]&lt;&lt;endl;

return 0;
</code></pre>
<p>}</p>
<p>状态转移方程：</p>
<p>f[i][j]&#x3D;max(f[i-1][j],f[i][j-1]);</p>
<p>if(a[i]&#x3D;&#x3D;b[j])f[i][j]&#x3D;max(f[i][j],f[i-1][j-1]+1);</p>
<h4 id="最短编辑距离"><a href="#最短编辑距离" class="headerlink" title="最短编辑距离"></a>最短编辑距离</h4><p>给定两个字符串 A和 B，现在要将 A 经过若干操作变为 B，可进行的操作有：</p>
<p>删除–将字符串 A中的某个字符删除。</p>
<p>插入–在字符串 A 的某个位置插入某个字符。</p>
<p>替换–将字符串 A中的某个字符替换为另一个字符。</p>
<p>现在请你求出，将 A变为 B 至少需要进行多少次操作。</p>
<p>视频讲解：[407 线性DP 编辑距离【动态规划】_哔哩哔哩_bilibili]：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1gk4y1177j/">https://www.bilibili.com/video/BV1gk4y1177j/</a></p>
<p>闫氏DP分析法【最短编辑距离】.png</p>
<p>using namespace std;</p>
<p>const int N &#x3D; 1010;</p>
<p>int n,m;</p>
<p>char a[N],b[N];</p>
<p>int f[N][N];</p>
<p>int main()</p>
<p>{</p>
<pre><code>scanf(&quot;%d%s&quot;, &amp;n, a+1);

scanf(&quot;%d%s&quot;, &amp;m, b+1);



for (int i = 0; i &lt;= m; i ++ )f[0][i]=i;

for (int i = 0; i &lt;= n; i ++ )f[i][0]=i;//初始化字符串的编辑操作

for (int i = 1; i &lt;= n; i ++ )&#123;

    for (int j = 1; j &lt;= m; j ++ )&#123;

        f[i][j]=min(f[i-1][j]+1,f[i][j-1]+1);

        if(a[i]==b[j])f[i][j]=min(f[i][j],f[i-1][j-1]);

        else f[i][j]=min(f[i][j],f[i-1][j-1]+1);//状态转移方程

    &#125;

&#125;

printf(&quot;%d\n&quot;,f[n][m]);

return 0;
</code></pre>
<p>}</p>
<p>状态转移方程:</p>
<p>f[i][j]&#x3D;min(f[i-1][j]+1,f[i][j-1]+1);</p>
<p>if(a[i]&#x3D;&#x3D;b[j])f[i][j]&#x3D;min(f[i][j],f[i-1][j-1]);</p>
<p>else f[i][j]&#x3D;min(f[i][j],f[i-1][j-1]+1);&#x2F;&#x2F;状态转移方程</p>
<h3 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h3><h4 id="石子合并"><a href="#石子合并" class="headerlink" title="石子合并"></a>石子合并</h4><p>每堆石子有一定的质量，可以用一个整数来描述，现在要将这 N堆石子合并成为一堆。</p>
<p>每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同。</p>
<p>视频讲解：[428 区间DP【模板】石子合并_哔哩哔哩_bilibili]：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1gz4y1y7Rv/">https://www.bilibili.com/video/BV1gz4y1y7Rv/</a></p>
<p>闫氏DP分析法</p>
<p>using namespace std;</p>
<p>const int N &#x3D; 310;</p>
<p>int n;</p>
<p>int s[N];</p>
<p>int f[N][N];&#x2F;&#x2F;状态表示：集合f[l][r]为[l,r]区间；属性：所堆成的最小值</p>
<p>int main()</p>
<p>{</p>
<pre><code>scanf(&quot;%d&quot;, &amp;n);

for (int i = 1; i &lt;= n; i ++ )scanf(&quot;%d&quot;,&amp;s[i]);

for (int i = 1; i &lt;= n; i ++ )s[i]+=s[i-1];//前缀和用来求一段区间的和



for (int len = 2; len &lt;= n; len ++ )//区间长度为len//枚举长度

    for (int i = 1; i+len-1 &lt;= n; i ++ )&#123;//意思就是i在区间[1,n-len+1]中去//枚举区间

        int l=i,r=i+len-1;//区间在[i,i+len-1]中间长度为len//设置l和r的区间

        f[l][r]=1e9;//初始化最大值

        for (int k = l; k &lt; r; k ++ )//枚举分界点//不取r

            f[l][r]=min(f[l][r],f[l][k]+f[k+1][r]+s[r]-s[l-1]);//找到最小值状态转移方程为f[l][k]+f[k+1][r]+s[r]-s[l-1];

    &#125;

printf(&quot;%d\n&quot;,f[1][n]);//输出区间[1,n]的最小值

return 0;
</code></pre>
<p>}</p>
<p>状态转移方程找到最小值状态转移方程为f[l][r]&#x3D;min(f[l][r],f[l][k]+f[k+1][r]+s[r]-s[l-1])</p>
<h3 id="计数类DP"><a href="#计数类DP" class="headerlink" title="计数类DP"></a>计数类DP</h3><h4 id="整数划分"><a href="#整数划分" class="headerlink" title="整数划分"></a>整数划分</h4><p>一个正整数 n 可以表示成若干个正整数之和，我们将这样的一种表示称为正整数 n 的一种划分。</p>
<p>现在给定一个正整数 n，请你求出 n共有多少种不同的划分方法。</p>
<p>完全背包写法</p>
<p>&#x2F;&#x2F;完全背包的写法</p>
<p>using namespace std;</p>
<p>const int M&#x3D;1e9+7;</p>
<p>int f[1010],n;</p>
<p>int main()</p>
<p>{</p>
<pre><code>cin&gt;&gt;n;

f[0]=1;

for (int i = 1; i &lt;= n; i ++ )

    for (int j = i; j &lt;= n; j ++ )&#123;

        f[j]=(f[j-i]+f[j])%M;

    &#125;

cout&lt;&lt;f[n]&lt;&lt;endl;

return 0;
</code></pre>
<p>}</p>
<p>状态转移方程：f[j]&#x3D;(f[j-i]+f[j])</p>
<h3 id="数位统计DP"><a href="#数位统计DP" class="headerlink" title="数位统计DP"></a>数位统计DP</h3><h4 id="计数问题"><a href="#计数问题" class="headerlink" title="计数问题"></a>计数问题</h4><p>题目链接：[338. 计数问题 - AcWing题库]：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/340/">https://www.acwing.com/problem/content/340/</a></p>
<p>计数问题分类讨论.png</p>
<p>using namespace std;</p>
<p>&#x2F;&#x2F;因为我们举的分类中，有需要求一串数字中某个区间的数字，例如abcdefg有一个分类需要求出efg+1</p>
<p>int get(vector<int> num,int l,int r){</p>
<pre><code>int res=0;

for(int i=l;i&gt;=r;i--)res=res*10+num[i];//这里从小到大枚举的是因为下面count的时候读入数据是从最低为读到最高位，那么此时在num里，最高位存的就是数字的最低位，那么假如我们要求efg，那就是从2算到0

return res;
</code></pre>
<p>}</p>
<p>int power10(int i)&#x2F;&#x2F;这里有power10是因为有一个分类需要求得十次方得值</p>
<p>{</p>
<pre><code>int res=1;

while(i--)res*=10;

return res;
</code></pre>
<p>}</p>
<p>int count(int n,int x){</p>
<pre><code>if(!n)return 0;//n=0则返回0

vector&lt;int&gt; num;//num用来存储数中的每一位数字

while(n)&#123;

    num.push_back(n%10);

    n/=10;

&#125;

n=num.size();//得出它的长度

int res=0;

for (int i = n-1-!x; i &gt;=0; i -- )

//这里需要注意，我们的长度需要减一，是因为num是从0开始存储，而长度是元素的个数，因此需要减1才能读到正确的数值，而!x出现的原因是因为我们不能让前导零出现，如果此时需要我们列举的是0得出现的次数，那么我们自然不能让他们出现第一位，而是从第二位开始枚举

&#123;

    if(i&lt;n-1)//其实这里可以不同if判断，因为for循环里面实际上就已经达成了if得判断，但为了方便理解还是加上if来理解，这里i要小于n-1的原因是因为我们不能越界只有7位数就最高从七位数开始读起

    &#123;

        res+=get(num,n-1,i+1)*power10(i);//这里就是第一个分类，000~abc-1，那么此时情况个数就会是abc*103,这里的3取决于后面的efg的长度，假如他是efgh，那么就是4

        //这里的n-1,i+1,自己将数组列出然后根据分类标准就可以得出为什么l是n-1,r=i+1

        if(!x)res-=power10(i);//假如此时我们要列举的是0出现的次数，因为不能出现前导零，这样是不合法也不符合我们的分类情况，例如abcdefg我们列举d，那么他就得从001~abc-1，这样就不会直接到efg，而是会到0efg，因为前面不是前导零，自然就可以列举这个时候0出现的次数，所以要减掉1个power10

    &#125;

    if(num[i]==x)res+=get(num,i-1,0)+1;

    else if(num[i]&gt;x)res+=power10(i);

&#125;

return res;//返回res，即出现次数
</code></pre>
<p>}</p>
<p>int main()</p>
<p>{</p>
<pre><code>int a,b;

while(cin&gt;&gt;a&gt;&gt;b,a||b)&#123;

    if(a&gt;b)swap(a,b);//a大于b则交换a，b使得变成合法参数

    for(int i=0;i&lt;10;i++)

        cout&lt;&lt;count(b,i)-count(a-1,i)&lt;&lt;&#39; &#39;;//使用前缀和思想解决[a,b]的i出现的次数

    cout&lt;&lt;endl;

&#125;

return 0;
</code></pre>
<p>}</p>
<h3 id="状态压缩DP"><a href="#状态压缩DP" class="headerlink" title="状态压缩DP"></a>状态压缩DP</h3><h4 id="蒙德里安的梦想"><a href="#蒙德里安的梦想" class="headerlink" title="蒙德里安的梦想"></a>蒙德里安的梦想</h4><p>题目链接：[U204941 蒙德里安的梦想 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)]：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/U204941">https://www.luogu.com.cn/problem/U204941</a></p>
<p>视频讲解：[431 状态压缩DP 蒙德里安的梦想【动态规划】_哔哩哔哩_bilibili]：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1cv411b7EG/">https://www.bilibili.com/video/BV1cv411b7EG/</a></p>
<p>using namespace std;</p>
<p>const int N &#x3D; 12,M&#x3D;1&lt;&lt;N;</p>
<p>int n,m;</p>
<p>long long f[N][M];</p>
<p>bool st[M];</p>
<p>int main()</p>
<p>{</p>
<pre><code>int n,m;

while(cin&gt;&gt;n&gt;&gt;m,n||m)&#123;

    memset(f, 0, sizeof f);

    //预处理：判断合并列的状态i是否合法

    //如果合并列的某行是1表示横放，是0表示竖放

    //如果合并列不存在连续的奇数个0，即为合法状态

    for (int i = 0; i &lt; 1&lt;&lt;n; i ++ )&#123;

        st[i]=true;

        int cnt=0;//记录合并列中连续0的个数

        for (int j = 0; j &lt; n; j ++ )&#123;

            if(i&gt;&gt;j&amp;1)&#123;//如果是1

                if(cnt&amp;1)&#123;//如果连续0的个数是奇数

                    st[i]=false;//记录i不合法

                    break;

                &#125;

            &#125;else cnt++;//如果是0，记录0的个数

        &#125;

        if(cnt&amp;1)st[i]=false;//处理高位0的个数

    &#125;

    //状态计算

    f[0][0]=1;//第0列不横放是一种合法的方案

    for (int i = 1; i &lt;= m; i ++ )//阶段：枚举列

        for (int j = 0; j &lt; 1&lt;&lt;n; j ++ )//状态：枚举i列的状态

            for (int k = 0; k &lt; 1&lt;&lt;n; k ++ )//状态：枚举i-1列的状态

                //两列状态兼容：不出现重叠的1，不出现连续奇数个0

                if((j&amp;k)==0&amp;&amp;st[j|k])

                    f[i][j]+=f[i-1][k];

    cout&lt;&lt;f[m][0]&lt;&lt;endl;//第m列不横放，既答案

&#125;

return 0;
</code></pre>
<p>}</p>
<p>状态转移方程：</p>
<p>if((j&amp;k)&#x3D;&#x3D;0&amp;&amp;st[j|k])</p>
<p> f[i][j]+&#x3D;f[i-1][k];</p>
<h4 id="最短Hamilton路径"><a href="#最短Hamilton路径" class="headerlink" title="最短Hamilton路径"></a>最短Hamilton路径</h4><p>题目链接：[U122241 最短Hamilton路径 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)]：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/U122241">https://www.luogu.com.cn/problem/U122241</a></p>
<p>using namespace std;</p>
<p>const int N &#x3D; 20,M &#x3D; 1 &lt;&lt; N;</p>
<p>int n;</p>
<p>int w[N][N];</p>
<p>int f[M][N];&#x2F;&#x2F;第一维表示是否访问到该点的压缩状态，第二维是走到点j</p>
<pre><code>        //f[i][j]表示状态为i并且到j的最短路径
</code></pre>
<p>int main(){</p>
<pre><code>cin&gt;&gt;n;

for (int i = 0; i &lt; n; i ++ )

    for (int j = 0; j &lt; n; j ++ )//读入i到j的距离

        cin&gt;&gt;w[i][j];

memset(f, 0x3f, sizeof f);

f[1][0]=0;

for (int i = 0; i &lt; 1 &lt;&lt; n; i ++ )//枚举压缩的状态

    for (int j = 0; j &lt; n; j ++ )//枚举到0~j的点

        if(i &gt;&gt; j &amp; 1)//该状态存在j点

            for (int k = 0; k &lt; n; k ++ )//枚举从j倒数第二个点k

                if(i &gt;&gt; k &amp; 1)//倒数点k存在

                    f[i][j]=min(f[i][j],f[i-(1&lt;&lt;j)][k]+w[k][j]);//状态转移方程，在f[i][j]和状态去掉j的点f[i-(i&lt;&lt;j)][k]+w[k][j]取最小值

cout&lt;&lt;f[(1&lt;&lt;n)-1][n-1]&lt;&lt;endl;//输出状态全满也就是所有点都经过且到最后一个点的最短距离

return 0;
</code></pre>
<p>}</p>
<p>状态转移方程：</p>
<p>f[i][j]&#x3D;min(f[i][j],f[i-(1&lt;&lt;j)][k]+w[k][j]);</p>
<h3 id="树形DP"><a href="#树形DP" class="headerlink" title="树形DP"></a>树形DP</h3><h4 id="没有上司的舞会"><a href="#没有上司的舞会" class="headerlink" title="没有上司的舞会"></a>没有上司的舞会</h4><p>题目：[P1352 没有上司的舞会 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)]：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1352">https://www.luogu.com.cn/problem/P1352</a></p>
<p>视频讲解：[417 树形DP 没有上司的舞会【动态规划】_哔哩哔哩_bilibili]：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1eK411N7Ly/">https://www.bilibili.com/video/BV1eK411N7Ly/</a></p>
<p>using namespace std;</p>
<p>const int N &#x3D; 6010;</p>
<p>int n;</p>
<p>int w[N];&#x2F;&#x2F;每个节点的高兴度</p>
<p>int h[N], e[N], ne[N], idx;&#x2F;&#x2F;邻接表存储树</p>
<p>bool st[N];&#x2F;&#x2F;判断是否有父节点</p>
<p>int f[N][2];</p>
<p>void add(int a, int b)  &#x2F;&#x2F; 添加一条边a-&gt;b</p>
<p>{</p>
<pre><code>e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
</code></pre>
<p>}</p>
<p>void dfs(int u){</p>
<pre><code>f[u][0]=0;

f[u][1]=w[u];//初始化f[u][1]，当第二维是0则不选该点即高兴度为0，同理f[u][1]=w[u];

for (int i = h[u]; i!=-1 ; i =ne[i] )&#123;//遍历u的子节点进行深度优先遍历

    int j=e[i];

    dfs(j);

    //状态转移方程

    f[u][0]+=max(f[j][0],f[j][1]);//f[u][0]表示不选择父节点u，所以在f[j][0]和f[j][1]取最大值

    f[u][1]+=f[j][0];//f[u][1]表示选择根节点u，所以累加不选择子节点的f[j][0]

&#125;
</code></pre>
<p>}</p>
<p>int main()</p>
<p>{</p>
<pre><code>cin&gt;&gt;n;

for (int i = 1; i &lt;= n; i ++ )cin&gt;&gt;w[i];

memset(h, -1, sizeof h);

for (int i = 0; i &lt; n-1; i ++ )&#123;

    int a,b;

    cin&gt;&gt;a&gt;&gt;b;

    add(b,a);

    st[a]=true;//存储是否存在父节点

&#125;

int root=1;

while(st[root])root++;//判断是否是根节点

dfs(root);//dfs对f[i][j]进行状态转移计算

cout&lt;&lt;max(f[root][0],f[root][1])&lt;&lt;endl;//取选与不选根节点的最大值

return 0;
</code></pre>
<p>}</p>
<p>状态转移方程：</p>
<p>f[u][0]+&#x3D;max(f[j][0],f[j][1]);</p>
<p>f[u][1]+&#x3D;f[j][0];</p>
<h3 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h3><h4 id="滑雪"><a href="#滑雪" class="headerlink" title="滑雪"></a>滑雪</h4><p>题目链接：[P1434 [SHOI2002] 滑雪 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)]：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1434">https://www.luogu.com.cn/problem/P1434</a></p>
<p>using namespace std;</p>
<p>const int N &#x3D; 310;</p>
<p>int n,m;</p>
<p>int h[N][N];</p>
<p>int f[N][N];</p>
<p>int dx[4]&#x3D;{-1,0,1,0},dy[4]&#x3D;{0,1,0,-1};</p>
<p>int dp(int x,int y){</p>
<pre><code>int &amp;v=f[x][y];

if(v!=-1)return v;//记忆化搜索核心

v=1;

for (int i = 0; i &lt; 4; i ++ )&#123;

    int a=x+dx[i],b=y+dy[i];

    if(a&gt;=1&amp;&amp;a&lt;=n&amp;&amp;b&gt;=1&amp;&amp;b&lt;=m&amp;&amp;h[a][b]&lt;h[x][y])//判断是否越界且上一个经过的点的高度是否大于当前高度

        v=max(v,dp(a,b)+1);

&#125;

return v;
</code></pre>
<p>}</p>
<p>int main()</p>
<p>{</p>
<pre><code>scanf(&quot;%d%d&quot;, &amp;n, &amp;m);

for (int i = 1; i &lt;= n; i ++ )

    for (int j = 1; j &lt;= m; j ++ )

        scanf(&quot;%d&quot;, &amp;h[i][j]);

memset(f, -1, sizeof f);

int res=0;

for (int i = 1; i &lt;= n; i ++ )

    for (int j = 1; j &lt;= m; j ++ )

        res=max(res,dp(i,j));

printf(&quot;%d\n&quot;,res);

return 0;
</code></pre>
<p>}</p>
<p>状态转移方程：v&#x3D;max(v,dp(a,b)+1);</p>
<h2 id="六、贪心"><a href="#六、贪心" class="headerlink" title="六、贪心"></a>六、贪心</h2><p>一个贪心算法总是做出当前最好的选择，也就是说，它期望通过局部最优选择从而得到全局最优的解决方案。—《算法导论》</p>
<h3 id="区间问题"><a href="#区间问题" class="headerlink" title="区间问题"></a>区间问题</h3><h4 id="区间选点"><a href="#区间选点" class="headerlink" title="区间选点"></a>区间选点</h4><p>给定 N个闭区间[ai,bi]，请你在数轴上选择尽量少的点，使得每个区间内至少包含一个选出的点</p>
<p>输出选择的点的最小数量。</p>
<p>using namespace std;</p>
<p>const int N &#x3D; 100010;</p>
<p>int n;</p>
<p>struct Range{</p>
<pre><code>int l,r;

bool operator &lt;(const Range&amp; W)const&#123;

    return r&lt;W.r;

&#125;//重载小于号
</code></pre>
<p>}range[N];</p>
<p>int main()</p>
<p>{</p>
<pre><code>scanf(&quot;%d&quot;, &amp;n);

for (int i = 0; i &lt; n; i ++ )&#123;

    int l,r;

    scanf(&quot;%d%d&quot;, &amp;l, &amp;r);

    range[i]=&#123;l,r&#125;;//读入l,r

&#125;

sort(range,range+n);//按右端点进行排序

int res=0,ed=-2e9;//ed代表上一个点的右端点

for (int i = 0; i &lt; n; i ++ )&#123;

    if(range[i].l&gt;ed)&#123;

        res++;//点的数量加一

        ed=range[i].r;

    &#125;

&#125;

printf(&quot;%d\n&quot;,res);

return 0;
</code></pre>
<p>}</p>
<h4 id="最大不相交区间数量"><a href="#最大不相交区间数量" class="headerlink" title="最大不相交区间数量"></a>最大不相交区间数量</h4><p>给定 N个闭区间 [ai,bi]，请你在数轴上选择若干区间，使得选中的区间之间互不相交（包括端点）。</p>
<p>输出可选取区间的最大数量。</p>
<p>结论：最大不相交区间数量&#x3D;最少覆盖区间点数</p>
<p>为什么最大不相交区间数&#x3D;最少覆盖区间点数呢？</p>
<p>因为如果几个区间能被同一个点覆盖</p>
<p>说明他们相交了，所以有几个点就是有几个不相交区间</p>
<p>using namespace std;</p>
<p>const int N &#x3D; 100010;</p>
<p>int n;</p>
<p>struct Range{</p>
<pre><code>int l,r;

bool operator &lt;(const Range&amp; W)const&#123;

    return r&lt;W.r;

&#125;
</code></pre>
<p>}range[N];</p>
<p>int main()</p>
<p>{</p>
<pre><code>scanf(&quot;%d&quot;, &amp;n);

for (int i = 0; i &lt; n; i ++ )&#123;

    int l,r;

    scanf(&quot;%d%d&quot;, &amp;l, &amp;r);

    range[i]=&#123;l,r&#125;;

&#125;

sort(range,range+n);

int res=0,ed=-2e9;

for (int i = 0; i &lt; n; i ++ )&#123;

    if(range[i].l&gt;ed)&#123;

        res++;

        ed=range[i].r;

    &#125;

&#125;

printf(&quot;%d\n&quot;,res);

return 0;
</code></pre>
<p>}</p>
<h3 id="区间分组"><a href="#区间分组" class="headerlink" title="区间分组"></a>区间分组</h3><p>区间分组.png</p>
<p>using namespace std;</p>
<p>const int N &#x3D; 1e5+10;</p>
<p>int n;</p>
<p>struct Range{</p>
<pre><code>int l,r;

bool operator&lt;(const Range &amp;W)const&#123;

    return l&lt;W.l;

&#125;//按左端点排序
</code></pre>
<p>}range[N];</p>
<p>int main()</p>
<p>{</p>
<pre><code>scanf(&quot;%d&quot;, &amp;n);

for (int i = 0; i &lt; n; i ++ )&#123;

    int l,r;

    scanf(&quot;%d%d&quot;, &amp;l, &amp;r);

    range[i]=&#123;l,r&#125;;

&#125;

sort(range,range+n);//sort排序

priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; heap;//小根堆维护所有组的右端点最小值

for (int i = 0; i &lt; n; i ++ )&#123;//从左往右枚举

    auto r=range[i];//选择当前区间

    if(heap.empty()||heap.top()&gt;=r.l)heap.push(r.r);

    else&#123;

        heap.pop();

        heap.push(r.r);

    &#125;

&#125;

printf(&quot;%d\n&quot;,heap.size());

return 0;
</code></pre>
<p>}</p>
<h3 id="排序不等式"><a href="#排序不等式" class="headerlink" title="排序不等式"></a>排序不等式</h3><h4 id="排队打水"><a href="#排队打水" class="headerlink" title="排队打水"></a>排队打水</h4><p>有 n个人排队到 1 个水龙头处打水，第 i 个人装满水桶所需的时间是 ti，请问如何安排他们的打水顺序才能使所有人的等待时间之和最小？</p>
<p>t[i]从小到大排序：</p>
<p>计算公式：t[0]×(n−1)+t[1]×(n−2)+t[2]×(n−3)…+t[n]×0</p>
<p>using namespace std;</p>
<p>typedef long long LL;</p>
<p>const int N &#x3D; 1e5 + 10;</p>
<p>int t[N];</p>
<p>int main() {</p>
<pre><code>int n;

scanf(&quot;%d&quot;, &amp;n);

for (int i = 0; i &lt; n; i++)

    scanf(&quot;%d&quot;, &amp;t[i]);

sort(t, t + n);//排序

LL  ans = 0;

for (int i = 0; i &lt; n; i++) &#123;

    ans += t[i] * (n - i - 1);//计算

&#125;

printf(&quot;%lld&quot;, ans);

return 0;
</code></pre>
<p>}</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-06-06T03:16:00.000Z" title="2024/6/6 11:16:00">2024-06-06</time>发表</span><span class="level-item"><time dateTime="2024-06-06T03:20:26.923Z" title="2024/6/6 11:20:26">2024-06-06</time>更新</span><span class="level-item">6 分钟读完 (大约877个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/06/06/KMP%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/">KMP字符串匹配</a></p><div class="content"><h1 id="KMP匹配算法实现"><a href="#KMP匹配算法实现" class="headerlink" title="KMP匹配算法实现"></a>KMP匹配算法实现</h1><p>KMP（Knuth-Morris-Pratt）算法是一种用于在文本中查找模式的高效字符串匹配算法。本文将介绍如何使用C++实现KMP算法。</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定一个文本字符串和一个模式字符串，找出模式字符串在文本字符串中的所有出现位置。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>以下是一个实现KMP匹配算法的完整C++代码示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> p[N], s[M];</span><br><span class="line"><span class="type">int</span> ne[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; p + <span class="number">1</span> &gt;&gt; m &gt;&gt; s + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 求 next 数组的过程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">        <span class="keyword">if</span>(p[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line">        ne[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// KMP 匹配算法</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">        <span class="keyword">if</span>(s[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line">        <span class="keyword">if</span>(j == n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i - n);</span><br><span class="line">            j = ne[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="示例输入输出"><a href="#示例输入输出" class="headerlink" title="示例输入输出"></a>示例输入输出</h2><p>以下是一些示例输入和对应的输出，帮助理解代码的工作原理。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h3><p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5 ababa 9 abababababa</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 2 4</span><br></pre></td></tr></table></figure>

<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h3><p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 abc 10 abcabcabcabc</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 3 6 9</span><br></pre></td></tr></table></figure>

<h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h3><p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 aa 6 aaaaaa</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4</span><br></pre></td></tr></table></figure>

<h2 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h2><h3 id="计算-next-数组："><a href="#计算-next-数组：" class="headerlink" title="计算 next 数组："></a>计算 next 数组：</h3><ul>
<li>通过遍历模式字符串 <code>p</code>，计算每个位置的最长公共前缀和后缀的长度，存储在数组 <code>ne</code> 中。</li>
</ul>
<h3 id="KMP-匹配算法："><a href="#KMP-匹配算法：" class="headerlink" title="KMP 匹配算法："></a>KMP 匹配算法：</h3><ul>
<li>遍历文本字符串 <code>s</code>，使用 <code>ne</code> 数组进行模式匹配，找到所有出现位置并输出。</li>
</ul>
<h3 id="主函数逻辑："><a href="#主函数逻辑：" class="headerlink" title="主函数逻辑："></a>主函数逻辑：</h3><ul>
<li>读取输入数据，计算 <code>ne</code> 数组，并使用 KMP 算法进行字符串匹配，输出所有匹配位置。</li>
</ul>
<p>我们用一个具体的例子来解释KMP算法的实现过程，并展示详细的计算过程。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><ul>
<li>模式串：<code>ABCDABD</code></li>
<li>文本串：<code>ABC ABCDAB ABCDABCDABDE</code></li>
</ul>
<p>我们需要找到模式串在文本串中的所有出现位置。</p>
<h3 id="计算过程"><a href="#计算过程" class="headerlink" title="计算过程"></a>计算过程</h3><h4 id="1-计算-next-数组"><a href="#1-计算-next-数组" class="headerlink" title="1. 计算 next 数组"></a>1. 计算 <code>next</code> 数组</h4><p>模式串：<code>ABCDABD</code><br>长度：<code>n = 7</code></p>
<p>初始化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ne[<span class="number">1</span>] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>计算<code>next</code>数组：</p>
<ul>
<li>i &#x3D; 2, j &#x3D; 0:<ul>
<li><code>p[2] != p[1]</code>，保持 <code>j = 0</code></li>
<li><code>ne[2] = j = 0</code></li>
</ul>
</li>
<li>i &#x3D; 3, j &#x3D; 0:<ul>
<li><code>p[3] != p[1]</code>，保持 <code>j = 0</code></li>
<li><code>ne[3] = j = 0</code></li>
</ul>
</li>
<li>i &#x3D; 4, j &#x3D; 0:<ul>
<li><code>p[4] != p[1]</code>，保持 <code>j = 0</code></li>
<li><code>ne[4] = j = 0</code></li>
</ul>
</li>
<li>i &#x3D; 5, j &#x3D; 0:<ul>
<li><code>p[5] == p[1]</code>，增加 <code>j++</code></li>
<li><code>ne[5] = j = 1</code></li>
</ul>
</li>
<li>i &#x3D; 6, j &#x3D; 1:<ul>
<li><code>p[6] != p[2]</code>，回退 <code>j = ne[1] = 0</code></li>
<li><code>p[6] != p[1]</code>，保持 <code>j = 0</code></li>
<li><code>ne[6] = j = 0</code></li>
</ul>
</li>
<li>i &#x3D; 7, j &#x3D; 0:<ul>
<li><code>p[7] == p[1]</code>，增加 <code>j++</code></li>
<li><code>ne[7] = j = 1</code></li>
</ul>
</li>
</ul>
<p>最终的 <code>next</code> 数组：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ne = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h4 id="2-KMP匹配过程"><a href="#2-KMP匹配过程" class="headerlink" title="2. KMP匹配过程"></a>2. KMP匹配过程</h4><p>文本串：<code>ABC ABCDAB ABCDABCDABDE</code><br>长度：<code>m = 23</code></p>
<p>初始化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">j = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>进行匹配：</p>
<ul>
<li>i &#x3D; 1, j &#x3D; 0:<ul>
<li><code>s[1] == p[1]</code>，增加 <code>j++</code></li>
<li>j &#x3D; 1</li>
</ul>
</li>
<li>i &#x3D; 2, j &#x3D; 1:<ul>
<li><code>s[2] == p[2]</code>，增加 <code>j++</code></li>
<li>j &#x3D; 2</li>
</ul>
</li>
<li>i &#x3D; 3, j &#x3D; 2:<ul>
<li><code>s[3] == p[3]</code>，增加 <code>j++</code></li>
<li>j &#x3D; 3</li>
</ul>
</li>
<li>i &#x3D; 4, j &#x3D; 3:<ul>
<li><code>s[4] == p[4]</code>，增加 <code>j++</code></li>
<li>j &#x3D; 4</li>
</ul>
</li>
<li>i &#x3D; 5, j &#x3D; 4:<ul>
<li><code>s[5] != p[5]</code>，回退 <code>j = ne[4] = 0</code></li>
<li><code>s[5] == p[1]</code>，增加 <code>j++</code></li>
<li>j &#x3D; 1</li>
</ul>
</li>
<li>i &#x3D; 6, j &#x3D; 1:<ul>
<li><code>s[6] == p[2]</code>，增加 <code>j++</code></li>
<li>j &#x3D; 2</li>
</ul>
</li>
<li>i &#x3D; 7, j &#x3D; 2:<ul>
<li><code>s[7] == p[3]</code>，增加 <code>j++</code></li>
<li>j &#x3D; 3</li>
</ul>
</li>
<li>i &#x3D; 8, j &#x3D; 3:<ul>
<li><code>s[8] == p[4]</code>，增加 <code>j++</code></li>
<li>j &#x3D; 4</li>
</ul>
</li>
<li>i &#x3D; 9, j &#x3D; 4:<ul>
<li><code>s[9] == p[5]</code>，增加 <code>j++</code></li>
<li>j &#x3D; 5</li>
</ul>
</li>
<li>i &#x3D; 10, j &#x3D; 5:<ul>
<li><code>s[10] == p[6]</code>，增加 <code>j++</code></li>
<li>j &#x3D; 6</li>
</ul>
</li>
<li>i &#x3D; 11, j &#x3D; 6:<ul>
<li><code>s[11] != p[7]</code>，回退 <code>j = ne[6] = 1</code></li>
<li><code>s[11] != p[2]</code>，回退 <code>j = ne[1] = 0</code></li>
</ul>
</li>
<li>i &#x3D; 12, j &#x3D; 0:<ul>
<li><code>s[12] == p[1]</code>，增加 <code>j++</code></li>
<li>j &#x3D; 1</li>
</ul>
</li>
<li>i &#x3D; 13, j &#x3D; 1:<ul>
<li><code>s[13] == p[2]</code>，增加 <code>j++</code></li>
<li>j &#x3D; 2</li>
</ul>
</li>
<li>i &#x3D; 14, j &#x3D; 2:<ul>
<li><code>s[14] == p[3]</code>，增加 <code>j++</code></li>
<li>j &#x3D; 3</li>
</ul>
</li>
<li>i &#x3D; 15, j &#x3D; 3:<ul>
<li><code>s[15] == p[4]</code>，增加 <code>j++</code></li>
<li>j &#x3D; 4</li>
</ul>
</li>
<li>i &#x3D; 16, j &#x3D; 4:<ul>
<li><code>s[16] == p[5]</code>，增加 <code>j++</code></li>
<li>j &#x3D; 5</li>
</ul>
</li>
<li>i &#x3D; 17, j &#x3D; 5:<ul>
<li><code>s[17] == p[6]</code>，增加 <code>j++</code></li>
<li>j &#x3D; 6</li>
</ul>
</li>
<li>i &#x3D; 18, j &#x3D; 6:<ul>
<li><code>s[18] == p[7]</code>，增加 <code>j++</code></li>
<li>j &#x3D; 7</li>
</ul>
</li>
</ul>
<p>匹配成功，输出 <code>i - n = 18 - 7 = 11</code>。回退 <code>j = ne[7] = 1</code>。</p>
<ul>
<li>i &#x3D; 19, j &#x3D; 1:<ul>
<li><code>s[19] == p[2]</code>，增加 <code>j++</code></li>
<li>j &#x3D; 2</li>
</ul>
</li>
<li>i &#x3D; 20, j &#x3D; 2:<ul>
<li><code>s[20] == p[3]</code>，增加 <code>j++</code></li>
<li>j &#x3D; 3</li>
</ul>
</li>
<li>i &#x3D; 21, j &#x3D; 3:<ul>
<li><code>s[21] == p[4]</code>，增加 <code>j++</code></li>
<li>j &#x3D; 4</li>
</ul>
</li>
<li>i &#x3D; 22, j &#x3D; 4:<ul>
<li><code>s[22] == p[5]</code>，增加 <code>j++</code></li>
<li>j &#x3D; 5</li>
</ul>
</li>
<li>i &#x3D; 23, j &#x3D; 5:<ul>
<li><code>s[23] == p[6]</code>，增加 <code>j++</code></li>
<li>j &#x3D; 6</li>
</ul>
</li>
</ul>
<p>匹配失败，结束匹配。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>最终匹配输出位置为 <code>11</code>。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-06-05T23:52:19.000Z" title="2024/6/6 07:52:19">2024-06-06</time>发表</span><span class="level-item"><time dateTime="2024-06-05T23:52:29.181Z" title="2024/6/6 07:52:29">2024-06-06</time>更新</span><span class="level-item">几秒读完 (大约0个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/06/06/%E9%98%9F%E5%88%97/">队列</a></p><div class="content"></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-06-05T23:49:01.000Z" title="2024/6/6 07:49:01">2024-06-06</time>发表</span><span class="level-item"><time dateTime="2024-06-05T23:49:10.026Z" title="2024/6/6 07:49:10">2024-06-06</time>更新</span><span class="level-item">3 分钟读完 (大约449个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/06/06/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/">滑动窗口</a></p><div class="content"><h1 id="滑动窗口实现"><a href="#滑动窗口实现" class="headerlink" title="滑动窗口实现"></a>滑动窗口实现</h1><p>滑动窗口是一种常用的算法技巧，用于在数组或列表上进行高效的区间操作。本文将介绍如何使用C++实现滑动窗口。</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定一个长度为 <code>n</code> 的数组和一个整数 <code>k</code>，找出每个长度为 <code>k</code> 的子数组的最小值和最大值。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>以下是一个实现滑动窗口的完整C++代码示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="type">int</span> a[N], q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 判断队头是否已经滑出窗口</span></span><br><span class="line">        <span class="keyword">if</span>(hh &lt;= tt &amp;&amp; i - k + <span class="number">1</span> &gt; q[hh]) hh++;</span><br><span class="line">        <span class="keyword">while</span>(hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt--;</span><br><span class="line">        q[++tt] = i;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[q[hh]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 判断队头是否已经滑出窗口</span></span><br><span class="line">        <span class="keyword">if</span>(hh &lt;= tt &amp;&amp; i - k + <span class="number">1</span> &gt; q[hh]) hh++;</span><br><span class="line">        <span class="keyword">while</span>(hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i]) tt--;</span><br><span class="line">        q[++tt] = i;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[q[hh]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="示例输入输出"><a href="#示例输入输出" class="headerlink" title="示例输入输出"></a>示例输入输出</h2><p>以下是一些示例输入和对应的输出，帮助理解代码的工作原理。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h3><p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8 3</span><br><span class="line">1 3 -1 -3 5 3 6 7</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-1 -3 -3 -3 3 3</span><br><span class="line">3 3 5 5 6 7</span><br></pre></td></tr></table></figure>

<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h3><p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5 2</span><br><span class="line">2 1 2 4 3</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 1 2 3</span><br><span class="line">2 2 4 4</span><br></pre></td></tr></table></figure>

<h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h3><p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6 4</span><br><span class="line">9 3 5 1 6 7</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 1 1</span><br><span class="line">9 6 6</span><br></pre></td></tr></table></figure>

<h2 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h2><h3 id="初始化滑动窗口："><a href="#初始化滑动窗口：" class="headerlink" title="初始化滑动窗口："></a>初始化滑动窗口：</h3><ul>
<li>定义数组 <code>a</code> 存储输入的数组，<code>q</code> 用作滑动窗口的队列。</li>
<li>读取数组长度 <code>n</code> 和窗口大小 <code>k</code>。</li>
</ul>
<h3 id="处理输入数据："><a href="#处理输入数据：" class="headerlink" title="处理输入数据："></a>处理输入数据：</h3><ul>
<li>读取输入的数组元素，维护两个滑动窗口，分别用于求最小值和最大值。</li>
</ul>
<h3 id="主函数逻辑："><a href="#主函数逻辑：" class="headerlink" title="主函数逻辑："></a>主函数逻辑：</h3><ul>
<li>初始化队列，处理输入数据，并按照滑动窗口的规则输出每个子数组的最小值和最大值。</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-06-05T13:28:21.000Z" title="2024/6/5 21:28:21">2024-06-05</time>发表</span><span class="level-item"><time dateTime="2024-06-05T23:29:35.603Z" title="2024/6/6 07:29:35">2024-06-06</time>更新</span><span class="level-item">2 分钟读完 (大约352个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/06/05/%E5%8D%95%E8%B0%83%E6%A0%88/">单调栈</a></p><div class="content"><h1 id="单调栈实现"><a href="#单调栈实现" class="headerlink" title="单调栈实现"></a>单调栈实现</h1><p>单调栈是一种常用的数据结构，用于解决一类特殊的栈问题。本文将介绍如何使用C++实现单调栈。</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定一个长度为 <code>n</code> 的数组，找出每个元素左边第一个比它小的数。如果不存在这样的元素，则输出 <code>-1</code>。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>以下是一个实现单调栈的完整C++代码示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N  = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> st[N], tt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="keyword">while</span>(tt &amp;&amp; st[tt] &gt;= x) tt--;</span><br><span class="line">        <span class="keyword">if</span>(tt) cout &lt;&lt; st[tt] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        st[++tt] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="示例输入输出"><a href="#示例输入输出" class="headerlink" title="示例输入输出"></a>示例输入输出</h2><p>以下是一些示例输入和对应的输出，帮助理解代码的工作原理。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h3><p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">2 4 3 1 5</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1 2 2 -1 1</span><br></pre></td></tr></table></figure>

<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h3><p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">1 2 3 4 5 6</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1 1 2 3 4 5</span><br></pre></td></tr></table></figure>

<h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h3><p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">6 5 4 3 2 1</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1 -1 -1 -1 -1 -1</span><br></pre></td></tr></table></figure>

<h2 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h2><h3 id="初始化单调栈："><a href="#初始化单调栈：" class="headerlink" title="初始化单调栈："></a>初始化单调栈：</h3><ul>
<li>定义数组 <code>st</code> 存储栈中的元素，<code>tt</code> 为栈顶指针。</li>
</ul>
<h3 id="处理输入数据："><a href="#处理输入数据：" class="headerlink" title="处理输入数据："></a>处理输入数据：</h3><ul>
<li>读取输入的整数 <code>n</code>，表示数组的长度。</li>
<li>遍历输入的每个元素 <code>x</code>，维护一个单调递增的栈，输出每个元素左边第一个小于它的元素。</li>
</ul>
<h3 id="主函数逻辑："><a href="#主函数逻辑：" class="headerlink" title="主函数逻辑："></a>主函数逻辑：</h3><ul>
<li>初始化栈，读取输入数据，并按照单调栈的规则处理和输出结果。</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-06-04T14:21:35.000Z" title="2024/6/4 22:21:35">2024-06-04</time>发表</span><span class="level-item"><time dateTime="2024-06-04T14:21:35.570Z" title="2024/6/4 22:21:35">2024-06-04</time>更新</span><span class="level-item">几秒读完 (大约0个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/06/04/%E6%A0%88/">栈</a></p><div class="content"></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-06-04T14:08:49.000Z" title="2024/6/4 22:08:49">2024-06-04</time>发表</span><span class="level-item"><time dateTime="2024-06-05T13:32:43.584Z" title="2024/6/5 21:32:43">2024-06-05</time>更新</span><span class="level-item">8 分钟读完 (大约1172个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/06/04/%E5%8D%95%E9%93%BE%E8%A1%A8/">单链表</a></p><div class="content"><h2 id="题目：单链表的基本操作"><a href="#题目：单链表的基本操作" class="headerlink" title="题目：单链表的基本操作"></a>题目：单链表的基本操作</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>实现一个单链表，并支持以下三种操作：</p>
<ol>
<li>将一个元素插入到链表的头部。</li>
<li>将一个元素插入到链表中指定元素的后面。</li>
<li>删除链表中指定元素的后一个元素。</li>
</ol>
<p>链表初始为空。每个操作保证合法，且不会删除链表中不存在的元素。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含一个整数 <code>m</code>，表示操作的次数。</p>
<p>接下来 <code>m</code> 行，每行包含一个操作指令，具体形式如下：</p>
<ul>
<li><code>H x</code>：将整数 <code>x</code> 插入到链表的头部。</li>
<li><code>D k</code>：删除链表中第 <code>k</code> 个元素的后一个元素（<code>k</code> 从 1 开始）。</li>
<li><code>I k x</code>：将整数 <code>x</code> 插入到链表中第 <code>k</code> 个元素的后面（<code>k</code> 从 1 开始）。</li>
</ul>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一行，表示最终链表中的所有元素，按顺序用空格隔开。</p>
<h3 id="输入输出示例"><a href="#输入输出示例" class="headerlink" title="输入输出示例"></a>输入输出示例</h3><h4 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h4><p><strong>输入</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">H 1</span><br><span class="line">H 2</span><br><span class="line">I 2 3</span><br><span class="line">D 1</span><br><span class="line">I 1 4</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 4 3</span><br></pre></td></tr></table></figure>

<h4 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h4><p><strong>输入</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">H 10</span><br><span class="line">H 20</span><br><span class="line">I 1 30</span><br><span class="line">D 2</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20 10</span><br></pre></td></tr></table></figure>

<h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>我们使用一个数组 <code>e</code> 存储链表的元素，数组 <code>ne</code> 存储每个节点的下一个节点的下标。<code>head</code> 存储链表头部节点的下标，<code>idx</code> 表示当前插入元素的下标。具体实现包括初始化链表、在头部插入元素、在指定位置插入元素，以及删除指定位置后的元素。</p>
<p>通过解析输入的操作指令，我们对链表进行相应的操作，最终输出链表中的所有元素。<br>这段代码实现了一个简单的单链表操作，包括在头部插入节点、在某个节点后插入节点、删除某个节点后的节点以及遍历链表。</p>
<h3 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h3><ol>
<li><p><strong>定义常量和变量</strong>：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> head, e[N], ne[N], idx;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>N</code> 是数组的最大大小。</li>
<li><code>head</code> 是链表的头指针。</li>
<li><code>e</code> 数组存储节点的值。</li>
<li><code>ne</code> 数组存储每个节点的下一个节点的索引。</li>
<li><code>idx</code> 是当前节点的索引。</li>
</ul>
</li>
<li><p><strong>初始化函数</strong>：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 初始化链表，将 <code>head</code> 设为 <code>-1</code> 表示链表为空，<code>idx</code> 设为 <code>0</code>。</p>
</li>
<li><p><strong>在头部插入节点</strong>：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_to_head</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = head;</span><br><span class="line">    head = idx;</span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 将值 <code>x</code> 插入到头部节点，更新头指针和 <code>idx</code>。</p>
</li>
<li><p><strong>在节点 <code>k</code> 后插入节点</strong>：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = ne[k];</span><br><span class="line">    ne[k] = idx;</span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 在节点 <code>k</code> 后插入值 <code>x</code> 的新节点。</p>
</li>
<li><p><strong>删除节点 <code>k</code> 后的节点</strong>：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    ne[k] = ne[ne[k]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 删除节点 <code>k</code> 后的节点。</p>
</li>
<li><p><strong>主函数</strong>：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="type">int</span> k, x;</span><br><span class="line">        <span class="type">char</span> op;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&#x27;H&#x27;</span>) &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add_to_head</span>(x);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;D&#x27;</span>) &#123;</span><br><span class="line">            cin &gt;&gt; k;</span><br><span class="line">            <span class="keyword">if</span> (!k) head = ne[head];</span><br><span class="line">            <span class="built_in">remove</span>(k - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add</span>(k - <span class="number">1</span>, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head; i != <span class="number">-1</span>; i = ne[i]) cout &lt;&lt; e[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>读取操作数量 <code>m</code>。</li>
<li>初始化链表。</li>
<li>循环处理每个操作，根据操作类型执行相应的链表操作。</li>
<li>最后遍历并输出链表中的所有节点值。</li>
</ul>
</li>
</ol>
<h3 id="处理流程示例"><a href="#处理流程示例" class="headerlink" title="处理流程示例"></a>处理流程示例</h3><p>假设输入如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">H 3</span><br><span class="line">H 2</span><br><span class="line">I 1 4</span><br><span class="line">D 2</span><br><span class="line">H 1</span><br></pre></td></tr></table></figure>

<h4 id="输入解释"><a href="#输入解释" class="headerlink" title="输入解释"></a>输入解释</h4><ul>
<li>第1行：<code>5</code> 表示有5个操作。</li>
<li>第2行：<code>H 3</code> 在头部插入值为3的节点。</li>
<li>第3行：<code>H 2</code> 在头部插入值为2的节点。</li>
<li>第4行：<code>I 1 4</code> 在第1个节点后插入值为4的节点。</li>
<li>第5行：<code>D 2</code> 删除第2个节点后的节点。</li>
<li>第6行：<code>H 1</code> 在头部插入值为1的节点。</li>
</ul>
<h4 id="按照代码处理流程"><a href="#按照代码处理流程" class="headerlink" title="按照代码处理流程"></a>按照代码处理流程</h4><ol>
<li><p><strong>初始化链表</strong>：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">head = <span class="number">-1</span>;</span><br><span class="line">idx = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>执行操作</strong>：</p>
<ul>
<li><p>操作 <code>H 3</code>：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">add_to_head</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>  更新后 <code>e = [3]</code>，<code>ne = [-1]</code>，<code>head = 0</code>，<code>idx = 1</code>。</p>
</li>
<li><p>操作 <code>H 2</code>：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">add_to_head</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>  更新后 <code>e = [3, 2]</code>，<code>ne = [-1, 0]</code>，<code>head = 1</code>，<code>idx = 2</code>。</p>
</li>
<li><p>操作 <code>I 1 4</code>：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">add</span>(<span class="number">0</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<p>  更新后 <code>e = [3, 2, 4]</code>，<code>ne = [2, 0, -1]</code>，<code>head = 1</code>，<code>idx = 3</code>。</p>
</li>
<li><p>操作 <code>D 2</code>：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">remove</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>  更新后 <code>ne = [2, -1, -1]</code>。</p>
</li>
<li><p>操作 <code>H 1</code>：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">add_to_head</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>  更新后 <code>e = [3, 2, 4, 1]</code>，<code>ne = [2, -1, -1, 1]</code>，<code>head = 3</code>，<code>idx = 4</code>。</p>
</li>
</ul>
</li>
<li><p><strong>遍历并输出链表</strong>：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = head; i != <span class="number">-1</span>; i = ne[i]) cout &lt;&lt; e[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br></pre></td></tr></table></figure>
<p> 从头指针 <code>head = 3</code> 开始遍历，输出结果为：</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过这个例子，可以看到如何按照输入操作动态地更新链表，并最终输出链表的内容。每个操作都按照代码中的逻辑逐步进行，链表结构在每一步都进行了相应的更新和调整。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-06-02T01:52:25.000Z" title="2024/6/2 09:52:25">2024-06-02</time>发表</span><span class="level-item"><time dateTime="2024-06-02T03:03:49.160Z" title="2024/6/2 11:03:49">2024-06-02</time>更新</span><span class="level-item">10 分钟读完 (大约1509个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/06/02/%E5%89%8D%E7%BC%80%E5%92%8C-1/">高级前缀和</a></p><div class="content"><h1 id="高级前缀和实现"><a href="#高级前缀和实现" class="headerlink" title="高级前缀和实现"></a>高级前缀和实现</h1><p>在处理大范围坐标的区间求和时，可以使用离散化技术和前缀和结合来提高效率。本文将介绍如何使用C++实现这一方法。</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>假定有一个无限长的数轴，数轴上每个坐标都是0。<br>现在，我们首先进行n次操作，每次操作将某一位置x上的数加c。<br>接下来，进行m次询问，每个询问包含两个整数l和r，你需要求出在区间[l,r]之间所有数的和。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含两个整数n、m。<br>接下来n行，每行包括两个整数x和c。<br>再接下来里m行，每行包括两个整数l和r。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>共m行，每行输入一个询问中所求得区间内数字和。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>以下是一个实现高级前缀和的完整C++代码示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII; </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">300010</span>;</span><br><span class="line"><span class="type">int</span> a[N]; <span class="comment">// 离散化后的数组，用于存储离散化坐标对应的值</span></span><br><span class="line"><span class="type">int</span> s[N]; <span class="comment">// 前缀和数组，用于快速查询区间和</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; alls; <span class="comment">// 用于存储所有需要离散化的坐标</span></span><br><span class="line">vector&lt;PII&gt; add, question; <span class="comment">// add存储添加操作，question存储查询操作</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">// 二分查找函数，找到x在alls中的位置（离散化后的坐标）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>, r=alls.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(alls[mid] &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r + <span class="number">1</span>; <span class="comment">// 返回离散化后的坐标索引</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    ios; <span class="comment">// 优化输入输出</span></span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n; <span class="comment">// 读取操作的数量，m是添加操作的数量，n是查询操作的数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取添加操作</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> b, c;</span><br><span class="line">        cin &gt;&gt; b &gt;&gt; c; <span class="comment">// 读取添加操作的坐标和值</span></span><br><span class="line">        alls.<span class="built_in">push_back</span>(b); <span class="comment">// 将坐标存入alls中</span></span><br><span class="line">        add.<span class="built_in">push_back</span>(&#123;b, c&#125;); <span class="comment">// 将操作存入add中</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取查询操作</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> b, c;</span><br><span class="line">        cin &gt;&gt; b &gt;&gt; c; <span class="comment">// 读取查询操作的区间起点和终点</span></span><br><span class="line">        alls.<span class="built_in">push_back</span>(b); <span class="comment">// 将查询区间的两个坐标都存入alls中</span></span><br><span class="line">        alls.<span class="built_in">push_back</span>(c);</span><br><span class="line">        question.<span class="built_in">push_back</span>(&#123;b, c&#125;); <span class="comment">// 将查询操作存入question中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 离散化：对所有的坐标进行排序，并去重</span></span><br><span class="line">    <span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>());</span><br><span class="line">    alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 离散化并执行添加操作</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x : add)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> h = <span class="built_in">find</span>(x.first); <span class="comment">// 找到离散化后的坐标索引</span></span><br><span class="line">        a[h] += x.second; <span class="comment">// 在离散化后的数组中进行添加操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造前缀和数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= alls.<span class="built_in">size</span>(); i++) </span><br><span class="line">        s[i] = s[i - <span class="number">1</span>] + a[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理查询操作</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x : question)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> h = <span class="built_in">find</span>(x.first); <span class="comment">// 找到查询区间起点的离散化坐标</span></span><br><span class="line">        <span class="type">int</span> t = <span class="built_in">find</span>(x.second); <span class="comment">// 找到查询区间终点的离散化坐标</span></span><br><span class="line">        cout &lt;&lt; s[t] - s[h - <span class="number">1</span>] &lt;&lt; <span class="string">&quot;&quot;</span>; <span class="comment">// 输出查询结果，即区间和</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="示例输入输出"><a href="#示例输入输出" class="headerlink" title="示例输入输出"></a>示例输入输出</h2><p>以下是一些示例输入和对应的输出，帮助理解代码的工作原理。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h3><p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3 2</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">4 5</span><br><span class="line">1 2</span><br><span class="line">2 4</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">8</span><br></pre></td></tr></table></figure>

<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h3><p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">4 3</span><br><span class="line">1 1</span><br><span class="line">2 2</span><br><span class="line">3 3</span><br><span class="line">4 4</span><br><span class="line">1 3</span><br><span class="line">2 4</span><br><span class="line">1 4</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td></tr></table></figure>

<h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h3><p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2 2</span><br><span class="line">100 1</span><br><span class="line">200 2</span><br><span class="line">100 200</span><br><span class="line">150 250</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<h2 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h2><h3 id="输入处理："><a href="#输入处理：" class="headerlink" title="输入处理："></a>输入处理：</h3><ul>
<li>使用 <code>cin</code> 函数读取操作数 <code>m</code> 和查询数 <code>n</code>。</li>
<li>读取操作和查询的坐标，存储在对应的向量中，并记录所有需要的坐标。</li>
</ul>
<h3 id="离散化和前缀和实现："><a href="#离散化和前缀和实现：" class="headerlink" title="离散化和前缀和实现："></a>离散化和前缀和实现：</h3><ul>
<li>通过排序和去重对坐标进行离散化。</li>
<li>使用离散化后的坐标构造前缀和数组。</li>
</ul>
<h3 id="主函数逻辑："><a href="#主函数逻辑：" class="headerlink" title="主函数逻辑："></a>主函数逻辑：</h3><ul>
<li>读取输入数据并进行离散化处理。</li>
<li>构造前缀和数组，并处理每个查询，输出对应的区间和。</li>
</ul>
<p>当然可以。下面是一个具体的例子以及按照代码处理流程的解释：</p>
<h3 id="输入示例"><a href="#输入示例" class="headerlink" title="输入示例"></a>输入示例</h3><p>假设输入如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3 2</span><br><span class="line">1 5</span><br><span class="line">2 6</span><br><span class="line">3 7</span><br><span class="line">1 3</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure>

<h3 id="输入解释"><a href="#输入解释" class="headerlink" title="输入解释"></a>输入解释</h3><ul>
<li>第1行：<code>3 2</code> 表示有3个添加操作和2个查询操作。</li>
<li>第2-4行：<code>1 5</code>，<code>2 6</code>，<code>3 7</code> 是3个添加操作，表示在坐标1加上5，在坐标2加上6，在坐标3加上7。</li>
<li>第5-6行：<code>1 3</code>，<code>2 3</code> 是2个查询操作，分别查询区间 <code>[1, 3]</code> 和 <code>[2, 3]</code> 的和。</li>
</ul>
<h3 id="按照代码处理流程"><a href="#按照代码处理流程" class="headerlink" title="按照代码处理流程"></a>按照代码处理流程</h3><ol>
<li><p><strong>读取输入并存储操作</strong>：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> m, n;</span><br><span class="line">cin &gt;&gt; m &gt;&gt; n;</span><br></pre></td></tr></table></figure>
<p> <code>m = 3</code>，<code>n = 2</code>。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="type">int</span> b, c;</span><br><span class="line">    cin &gt;&gt; b &gt;&gt; c;</span><br><span class="line">    alls.<span class="built_in">push_back</span>(b);</span><br><span class="line">    add.<span class="built_in">push_back</span>(&#123;b, c&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 处理添加操作，将坐标 <code>b</code> 存入 <code>alls</code>，并将操作 <code>(b, c)</code> 存入 <code>add</code>。</p>
<p> <code>alls = [1, 2, 3]</code>，<br> <code>add = [(1, 5), (2, 6), (3, 7)]</code>。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> b, c;</span><br><span class="line">    cin &gt;&gt; b &gt;&gt; c;</span><br><span class="line">    alls.<span class="built_in">push_back</span>(b);</span><br><span class="line">    alls.<span class="built_in">push_back</span>(c);</span><br><span class="line">    question.<span class="built_in">push_back</span>(&#123;b, c&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 处理查询操作，将区间起点和终点 <code>b, c</code> 存入 <code>alls</code>，并将操作 <code>(b, c)</code> 存入 <code>question</code>。</p>
<p> <code>alls = [1, 2, 3, 1, 3, 2, 3]</code>，<br> <code>question = [(1, 3), (2, 3)]</code>。</p>
</li>
<li><p><strong>离散化处理</strong>：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>());</span><br><span class="line">alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>
<p> 对 <code>alls</code> 进行排序和去重。</p>
<p> <code>alls = [1, 2, 3]</code>。</p>
</li>
<li><p><strong>执行添加操作</strong>：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x : add) &#123;</span><br><span class="line">    <span class="type">int</span> h = <span class="built_in">find</span>(x.first);</span><br><span class="line">    a[h] += x.second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 将添加操作应用到离散化后的数组 <code>a</code> 中。</p>
<p> <code>find(1) = 1</code>，<code>find(2) = 2</code>，<code>find(3) = 3</code>。</p>
<p> 更新后 <code>a</code> 数组的变化：<br> <code>a = [0, 5, 6, 7]</code>。</p>
</li>
<li><p><strong>构建前缀和数组</strong>：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= alls.<span class="built_in">size</span>(); i++)</span><br><span class="line">    s[i] = s[i - <span class="number">1</span>] + a[i];</span><br></pre></td></tr></table></figure>
<p> 构建前缀和数组 <code>s</code>。</p>
<p> 前缀和数组 <code>s</code>：<br> <code>s = [0, 5, 11, 18]</code>。</p>
</li>
<li><p><strong>处理查询操作并输出结果</strong>：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x : question) &#123;</span><br><span class="line">    <span class="type">int</span> h = <span class="built_in">find</span>(x.first);</span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">find</span>(x.second);</span><br><span class="line">    cout &lt;&lt; s[t] - s[h - <span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 处理查询操作并输出结果。</p>
<ul>
<li>查询区间 <code>[1, 3]</code>：<br>  <code>find(1) = 1</code>，<code>find(3) = 3</code>，<br>  结果：<code>s[3] - s[0] = 18 - 0 = 18</code>。</li>
<li>查询区间 <code>[2, 3]</code>：<br>  <code>find(2) = 2</code>，<code>find(3) = 3</code>，<br>  结果：<code>s[3] - s[1] = 18 - 5 = 13</code>。</li>
</ul>
</li>
</ol>
<h3 id="最终输出"><a href="#最终输出" class="headerlink" title="最终输出"></a>最终输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">18 13</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过这个例子，我们可以看到代码是如何处理添加和查询操作的。代码通过离散化技术将原始坐标映射到较小的连续整数范围，从而在固定大小的数组上执行操作，这显著提高了处理效率。</p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/page/0/">上一页</a></div><div class="pagination-next"><a href="/page/2/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li><li><a class="pagination-link" href="/page/3/">3</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/icon.jpg" alt="Xiongyuqi"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Xiongyuqi</p><p class="is-size-6 is-block">Edward</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Dalian</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">22</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">7</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/Mr-xiongyq" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/Mr-xiongyq"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:xiongxixi666@gmail.com"><i class="fas fa-envelope"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-06-27T07:03:20.000Z">2024-06-27</time></p><p class="title"><a href="/2024/06/27/%E9%9D%A2%E7%BB%8F2-attention-%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/">面经2-attention(注意力机制)</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-06-27T06:53:24.000Z">2024-06-27</time></p><p class="title"><a href="/2024/06/27/%E9%9D%A2%E7%BB%8F/">面经</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-06-13T12:15:51.000Z">2024-06-13</time></p><p class="title"><a href="/2024/06/13/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/">算法总结</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-06-06T03:16:00.000Z">2024-06-06</time></p><p class="title"><a href="/2024/06/06/KMP%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/">KMP字符串匹配</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-06-05T23:52:19.000Z">2024-06-06</time></p><p class="title"><a href="/2024/06/06/%E9%98%9F%E5%88%97/">队列</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/06/"><span class="level-start"><span class="level-item">六月 2024</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/05/"><span class="level-start"><span class="level-item">五月 2024</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/03/"><span class="level-start"><span class="level-item">三月 2024</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Computer/"><span class="tag">Computer</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"><span class="tag">字符串</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="tag">数据结构</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%97%A5%E5%B8%B8/"><span class="tag">日常</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag">13</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%9D%A2%E7%BB%8F1-swimtransformer/"><span class="tag">面经1-swimtransformer</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%9D%A2%E7%BB%8F2-attention-%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/"><span class="tag">面经2-attention(注意力机制)</span><span class="tag">1</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Blogs" height="28"></a><p class="is-size-7"><span>&copy; 2024 Xiongyuqi</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="GitHub上下载" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://npm.elemecdn.com/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://npm.elemecdn.com/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://npm.elemecdn.com/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://npm.elemecdn.com/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://npm.elemecdn.com/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://npm.elemecdn.com/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/javascript" id="MathJax-script" async>MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      },
      svg: {
        fontCache: 'global'
      },
      chtml: {
        matchFontHeight: false
      }
    };</script><script src="https://npm.elemecdn.com/mathjax@3.2.2/es5/tex-mml-chtml.js"></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>