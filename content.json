{"posts":[{"title":"First_blog","text":"你好，这是我的第一条博客","link":"/2024/03/17/First-blog/"},{"title":"KMP字符串匹配","text":"KMP匹配算法实现KMP（Knuth-Morris-Pratt）算法是一种用于在文本中查找模式的高效字符串匹配算法。本文将介绍如何使用C++实现KMP算法。 问题描述给定一个文本字符串和一个模式字符串，找出模式字符串在文本字符串中的所有出现位置。 代码实现以下是一个实现KMP匹配算法的完整C++代码示例： 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;const int N = 100010, M = 100010;int n, m;char p[N], s[M];int ne[N];int main(){ cin &gt;&gt; n &gt;&gt; p + 1 &gt;&gt; m &gt;&gt; s + 1; // 求 next 数组的过程 for(int i = 2, j = 0; i &lt;= n; i++){ while(j &amp;&amp; p[i] != p[j + 1]) j = ne[j]; if(p[i] == p[j + 1]) j++; ne[i] = j; } // KMP 匹配算法 for(int i = 1, j = 0; i &lt;= m; i++) { while(j &amp;&amp; s[i] != p[j + 1]) j = ne[j]; if(s[i] == p[j + 1]) j++; if(j == n) { printf(&quot;%d &quot;, i - n); j = ne[j]; } } return 0;} 示例输入输出以下是一些示例输入和对应的输出，帮助理解代码的工作原理。 示例 1输入： 15 ababa 9 abababababa 输出： 10 2 4 示例 2输入： 13 abc 10 abcabcabcabc 输出： 10 3 6 9 示例 3输入： 12 aa 6 aaaaaa 输出： 10 1 2 3 4 代码说明计算 next 数组： 通过遍历模式字符串 p，计算每个位置的最长公共前缀和后缀的长度，存储在数组 ne 中。 KMP 匹配算法： 遍历文本字符串 s，使用 ne 数组进行模式匹配，找到所有出现位置并输出。 主函数逻辑： 读取输入数据，计算 ne 数组，并使用 KMP 算法进行字符串匹配，输出所有匹配位置。 我们用一个具体的例子来解释KMP算法的实现过程，并展示详细的计算过程。 例子输入 模式串：ABCDABD 文本串：ABC ABCDAB ABCDABCDABDE 我们需要找到模式串在文本串中的所有出现位置。 计算过程1. 计算 next 数组模式串：ABCDABD长度：n = 7 初始化： 1ne[1] = 0; 计算next数组： i = 2, j = 0: p[2] != p[1]，保持 j = 0 ne[2] = j = 0 i = 3, j = 0: p[3] != p[1]，保持 j = 0 ne[3] = j = 0 i = 4, j = 0: p[4] != p[1]，保持 j = 0 ne[4] = j = 0 i = 5, j = 0: p[5] == p[1]，增加 j++ ne[5] = j = 1 i = 6, j = 1: p[6] != p[2]，回退 j = ne[1] = 0 p[6] != p[1]，保持 j = 0 ne[6] = j = 0 i = 7, j = 0: p[7] == p[1]，增加 j++ ne[7] = j = 1 最终的 next 数组： 1ne = [0, 0, 0, 0, 1, 0, 1] 2. KMP匹配过程文本串：ABC ABCDAB ABCDABCDABDE长度：m = 23 初始化： 1j = 0; 进行匹配： i = 1, j = 0: s[1] == p[1]，增加 j++ j = 1 i = 2, j = 1: s[2] == p[2]，增加 j++ j = 2 i = 3, j = 2: s[3] == p[3]，增加 j++ j = 3 i = 4, j = 3: s[4] == p[4]，增加 j++ j = 4 i = 5, j = 4: s[5] != p[5]，回退 j = ne[4] = 0 s[5] == p[1]，增加 j++ j = 1 i = 6, j = 1: s[6] == p[2]，增加 j++ j = 2 i = 7, j = 2: s[7] == p[3]，增加 j++ j = 3 i = 8, j = 3: s[8] == p[4]，增加 j++ j = 4 i = 9, j = 4: s[9] == p[5]，增加 j++ j = 5 i = 10, j = 5: s[10] == p[6]，增加 j++ j = 6 i = 11, j = 6: s[11] != p[7]，回退 j = ne[6] = 1 s[11] != p[2]，回退 j = ne[1] = 0 i = 12, j = 0: s[12] == p[1]，增加 j++ j = 1 i = 13, j = 1: s[13] == p[2]，增加 j++ j = 2 i = 14, j = 2: s[14] == p[3]，增加 j++ j = 3 i = 15, j = 3: s[15] == p[4]，增加 j++ j = 4 i = 16, j = 4: s[16] == p[5]，增加 j++ j = 5 i = 17, j = 5: s[17] == p[6]，增加 j++ j = 6 i = 18, j = 6: s[18] == p[7]，增加 j++ j = 7 匹配成功，输出 i - n = 18 - 7 = 11。回退 j = ne[7] = 1。 i = 19, j = 1: s[19] == p[2]，增加 j++ j = 2 i = 20, j = 2: s[20] == p[3]，增加 j++ j = 3 i = 21, j = 3: s[21] == p[4]，增加 j++ j = 4 i = 22, j = 4: s[22] == p[5]，增加 j++ j = 5 i = 23, j = 5: s[23] == p[6]，增加 j++ j = 6 匹配失败，结束匹配。 总结最终匹配输出位置为 11。","link":"/2024/06/06/KMP%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"},{"title":"快速排序(quick_sort)","text":"题目描述给定你一个长度为 n 的整数数列。请你使用快速排序对这个数列按照从小到大进行排序，并将排好序的数列按顺序输出。 输入格式输入共两行，第一行包含整数 n。第二行包含 n 个整数（所有整数均在 1∼109 范围内），表示整个数列。 输出格式输出共一行，包含 n 个整数，表示排好序的数列。 数据范围1 ≤ n ≤ 100000 样例输入样例：1253 1 2 4 5 输出样例：11 2 3 4 5 C++ 代码算法1：使用手写快速排序123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;#define N 100005int q[N], n;void quick_sort(int l, int r) { if(l &gt;= r) return ; int i = l - 1, j = r + 1; int x = q[l + r &gt;&gt; 1]; while(i &lt; j) { do ++i; while(q[i] &lt; x); do --j; while(q[j] &gt; x); if(i &lt; j) swap(q[i], q[j]); } quick_sort(l, j); quick_sort(j + 1, r);}int main() { scanf(&quot;%d&quot;,&amp;n); for(int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;,q+i); quick_sort(1, n); for(int i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;,q[i]); return 0;} 算法2：(c++STL) O(nlogn) 用algorithm库的sort函数1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;#define N 100005int q[N], n;int main() { scanf(&quot;%d&quot;,&amp;n); for(int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;,q+i); sort(q + 1, q + 1 + n); // STL yyds!!! for(int i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;,q[i]); return 0;}","link":"/2024/05/27/quick-sort/"},{"title":"高级前缀和","text":"高级前缀和实现在处理大范围坐标的区间求和时，可以使用离散化技术和前缀和结合来提高效率。本文将介绍如何使用C++实现这一方法。 题目假定有一个无限长的数轴，数轴上每个坐标都是0。现在，我们首先进行n次操作，每次操作将某一位置x上的数加c。接下来，进行m次询问，每个询问包含两个整数l和r，你需要求出在区间[l,r]之间所有数的和。 输入格式第一行包含两个整数n、m。接下来n行，每行包括两个整数x和c。再接下来里m行，每行包括两个整数l和r。 输出格式共m行，每行输入一个询问中所求得区间内数字和。 代码实现以下是一个实现高级前缀和的完整C++代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;iostream&gt;using namespace std;#define ios ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)#include&lt;vector&gt;#include&lt;algorithm&gt;typedef pair&lt;int,int&gt; PII; const int N=300010;int a[N]; // 离散化后的数组，用于存储离散化坐标对应的值int s[N]; // 前缀和数组，用于快速查询区间和vector&lt;int&gt; alls; // 用于存储所有需要离散化的坐标vector&lt;PII&gt; add, question; // add存储添加操作，question存储查询操作int find(int x) // 二分查找函数，找到x在alls中的位置（离散化后的坐标）{ int l=0, r=alls.size()-1; while(l &lt; r) { int mid = (l + r) &gt;&gt; 1; if(alls[mid] &gt;= x) r = mid; else l = mid + 1; } return r + 1; // 返回离散化后的坐标索引}int main(){ ios; // 优化输入输出 int m, n; cin &gt;&gt; m &gt;&gt; n; // 读取操作的数量，m是添加操作的数量，n是查询操作的数量 // 读取添加操作 for(int i = 0; i &lt; m; i++) { int b, c; cin &gt;&gt; b &gt;&gt; c; // 读取添加操作的坐标和值 alls.push_back(b); // 将坐标存入alls中 add.push_back({b, c}); // 将操作存入add中 } // 读取查询操作 for(int i = 0; i &lt; n; i++) { int b, c; cin &gt;&gt; b &gt;&gt; c; // 读取查询操作的区间起点和终点 alls.push_back(b); // 将查询区间的两个坐标都存入alls中 alls.push_back(c); question.push_back({b, c}); // 将查询操作存入question中 } // 离散化：对所有的坐标进行排序，并去重 sort(alls.begin(), alls.end()); alls.erase(unique(alls.begin(), alls.end()), alls.end()); // 离散化并执行添加操作 for(auto x : add) { int h = find(x.first); // 找到离散化后的坐标索引 a[h] += x.second; // 在离散化后的数组中进行添加操作 } // 构造前缀和数组 for(int i = 1; i &lt;= alls.size(); i++) s[i] = s[i - 1] + a[i]; // 处理查询操作 for(auto x : question) { int h = find(x.first); // 找到查询区间起点的离散化坐标 int t = find(x.second); // 找到查询区间终点的离散化坐标 cout &lt;&lt; s[t] - s[h - 1] &lt;&lt; &quot;&quot;; // 输出查询结果，即区间和 } return 0;} 示例输入输出以下是一些示例输入和对应的输出，帮助理解代码的工作原理。 示例 1输入： 1234563 21 22 34 51 22 4 输出： 1258 示例 2输入： 123456784 31 12 23 34 41 32 41 4 输出： 1236910 示例 3输入： 123452 2100 1200 2100 200150 250 输出： 1232 代码说明输入处理： 使用 cin 函数读取操作数 m 和查询数 n。 读取操作和查询的坐标，存储在对应的向量中，并记录所有需要的坐标。 离散化和前缀和实现： 通过排序和去重对坐标进行离散化。 使用离散化后的坐标构造前缀和数组。 主函数逻辑： 读取输入数据并进行离散化处理。 构造前缀和数组，并处理每个查询，输出对应的区间和。 当然可以。下面是一个具体的例子以及按照代码处理流程的解释： 输入示例假设输入如下： 1234563 21 52 63 71 32 3 输入解释 第1行：3 2 表示有3个添加操作和2个查询操作。 第2-4行：1 5，2 6，3 7 是3个添加操作，表示在坐标1加上5，在坐标2加上6，在坐标3加上7。 第5-6行：1 3，2 3 是2个查询操作，分别查询区间 [1, 3] 和 [2, 3] 的和。 按照代码处理流程 读取输入并存储操作： 12int m, n;cin &gt;&gt; m &gt;&gt; n; m = 3，n = 2。 123456for (int i = 0; i &lt; m; i++) { int b, c; cin &gt;&gt; b &gt;&gt; c; alls.push_back(b); add.push_back({b, c});} 处理添加操作，将坐标 b 存入 alls，并将操作 (b, c) 存入 add。 alls = [1, 2, 3]， add = [(1, 5), (2, 6), (3, 7)]。 1234567for (int i = 0; i &lt; n; i++) { int b, c; cin &gt;&gt; b &gt;&gt; c; alls.push_back(b); alls.push_back(c); question.push_back({b, c});} 处理查询操作，将区间起点和终点 b, c 存入 alls，并将操作 (b, c) 存入 question。 alls = [1, 2, 3, 1, 3, 2, 3]， question = [(1, 3), (2, 3)]。 离散化处理： 12sort(alls.begin(), alls.end());alls.erase(unique(alls.begin(), alls.end()), alls.end()); 对 alls 进行排序和去重。 alls = [1, 2, 3]。 执行添加操作： 1234for (auto x : add) { int h = find(x.first); a[h] += x.second;} 将添加操作应用到离散化后的数组 a 中。 find(1) = 1，find(2) = 2，find(3) = 3。 更新后 a 数组的变化： a = [0, 5, 6, 7]。 构建前缀和数组： 12for (int i = 1; i &lt;= alls.size(); i++) s[i] = s[i - 1] + a[i]; 构建前缀和数组 s。 前缀和数组 s： s = [0, 5, 11, 18]。 处理查询操作并输出结果： 12345for (auto x : question) { int h = find(x.first); int t = find(x.second); cout &lt;&lt; s[t] - s[h - 1] &lt;&lt; &quot; &quot;;} 处理查询操作并输出结果。 查询区间 [1, 3]： find(1) = 1，find(3) = 3， 结果：s[3] - s[0] = 18 - 0 = 18。 查询区间 [2, 3]： find(2) = 2，find(3) = 3， 结果：s[3] - s[1] = 18 - 5 = 13。 最终输出118 13 总结通过这个例子，我们可以看到代码是如何处理添加和查询操作的。代码通过离散化技术将原始坐标映射到较小的连续整数范围，从而在固定大小的数组上执行操作，这显著提高了处理效率。","link":"/2024/06/02/%E5%89%8D%E7%BC%80%E5%92%8C-1/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2024/03/17/hello-world/"},{"title":"双指针基础-字符串处理实现","text":"字符串处理实现在处理字符串时，可以使用C++中的字符串操作库进行各种处理。本文将介绍如何使用C++实现简单的字符串处理。 代码实现以下是一个实现字符串处理的完整C++代码示例： 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;cstring&gt; // 包含c字符串操作库using namespace std;int main(){ char str[1000]; cin.getline(str, 1000); // 使用cin.getline替代gets int n = strlen(str); for (int i = 0; i &lt; n; i++) { int j = i; while (j &lt; n &amp;&amp; str[j] != ' ') j++; for (int k = i; k &lt; j; k++) cout &lt;&lt; str[k]; cout &lt;&lt; endl; i = j; } return 0;} 示例输入输出以下是一些示例输入和对应的输出，帮助理解代码的工作原理。 示例 1输入： 1hello world 输出： 12helloworld 示例 2输入： 1this is a test 输出： 1234thisisatest 示例 3输入： 1C++ string processing example 输出： 1234C++stringprocessingexample 代码说明输入处理： 使用 cin.getline 函数读取整行输入字符串，避免使用不安全的 gets 函数。 使用 strlen 函数获取字符串长度。 字符串处理实现： 遍历输入字符串，找到每个单词，并逐个输出。 主函数逻辑： 读取输入字符串并获取其长度。 遍历字符串，通过空格分隔单词，并逐行输出每个单词。","link":"/2024/06/01/%E5%8F%8C%E6%8C%87%E9%92%88%E5%9F%BA%E7%A1%80/"},{"title":"单调栈","text":"单调栈实现单调栈是一种常用的数据结构，用于解决一类特殊的栈问题。本文将介绍如何使用C++实现单调栈。 问题描述给定一个长度为 n 的数组，找出每个元素左边第一个比它小的数。如果不存在这样的元素，则输出 -1。 代码实现以下是一个实现单调栈的完整C++代码示例： 123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;const int N = 100010;int st[N], tt;int main(){ int n; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) { int x; cin &gt;&gt; x; while(tt &amp;&amp; st[tt] &gt;= x) tt--; if(tt) cout &lt;&lt; st[tt] &lt;&lt; &quot; &quot;; else cout &lt;&lt; -1 &lt;&lt; &quot; &quot;; st[++tt] = x; } return 0;} 示例输入输出以下是一些示例输入和对应的输出，帮助理解代码的工作原理。 示例 1输入： 1252 4 3 1 5 输出： 1-1 2 2 -1 1 示例 2输入： 1261 2 3 4 5 6 输出： 1-1 1 2 3 4 5 示例 3输入： 1266 5 4 3 2 1 输出： 1-1 -1 -1 -1 -1 -1 代码说明初始化单调栈： 定义数组 st 存储栈中的元素，tt 为栈顶指针。 处理输入数据： 读取输入的整数 n，表示数组的长度。 遍历输入的每个元素 x，维护一个单调递增的栈，输出每个元素左边第一个小于它的元素。 主函数逻辑： 初始化栈，读取输入数据，并按照单调栈的规则处理和输出结果。","link":"/2024/06/05/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"title":"单链表","text":"题目：单链表的基本操作题目描述实现一个单链表，并支持以下三种操作： 将一个元素插入到链表的头部。 将一个元素插入到链表中指定元素的后面。 删除链表中指定元素的后一个元素。 链表初始为空。每个操作保证合法，且不会删除链表中不存在的元素。 输入格式第一行包含一个整数 m，表示操作的次数。 接下来 m 行，每行包含一个操作指令，具体形式如下： H x：将整数 x 插入到链表的头部。 D k：删除链表中第 k 个元素的后一个元素（k 从 1 开始）。 I k x：将整数 x 插入到链表中第 k 个元素的后面（k 从 1 开始）。 输出格式输出一行，表示最终链表中的所有元素，按顺序用空格隔开。 输入输出示例示例1输入 1234565H 1H 2I 2 3D 1I 1 4 输出 12 4 3 示例2输入 123454H 10H 20I 1 30D 2 输出 120 10 题目分析我们使用一个数组 e 存储链表的元素，数组 ne 存储每个节点的下一个节点的下标。head 存储链表头部节点的下标，idx 表示当前插入元素的下标。具体实现包括初始化链表、在头部插入元素、在指定位置插入元素，以及删除指定位置后的元素。 通过解析输入的操作指令，我们对链表进行相应的操作，最终输出链表中的所有元素。这段代码实现了一个简单的单链表操作，包括在头部插入节点、在某个节点后插入节点、删除某个节点后的节点以及遍历链表。 代码解释 定义常量和变量： 12const int N = 100010;int head, e[N], ne[N], idx; N 是数组的最大大小。 head 是链表的头指针。 e 数组存储节点的值。 ne 数组存储每个节点的下一个节点的索引。 idx 是当前节点的索引。 初始化函数： 1234void init() { head = -1; idx = 0;} 初始化链表，将 head 设为 -1 表示链表为空，idx 设为 0。 在头部插入节点： 123456void add_to_head(int x) { e[idx] = x; ne[idx] = head; head = idx; idx++;} 将值 x 插入到头部节点，更新头指针和 idx。 在节点 k 后插入节点： 123456void add(int k, int x) { e[idx] = x; ne[idx] = ne[k]; ne[k] = idx; idx++;} 在节点 k 后插入值 x 的新节点。 删除节点 k 后的节点： 123void remove(int k) { ne[k] = ne[ne[k]];} 删除节点 k 后的节点。 主函数： 123456789101112131415161718192021222324int main() { int m; cin &gt;&gt; m; init(); while (m--) { int k, x; char op; cin &gt;&gt; op; if (op == 'H') { cin &gt;&gt; x; add_to_head(x); } else if (op == 'D') { cin &gt;&gt; k; if (!k) head = ne[head]; remove(k - 1); } else { cin &gt;&gt; k &gt;&gt; x; add(k - 1, x); } } for (int i = head; i != -1; i = ne[i]) cout &lt;&lt; e[i] &lt;&lt; ' '; cout &lt;&lt; endl; return 0;} 读取操作数量 m。 初始化链表。 循环处理每个操作，根据操作类型执行相应的链表操作。 最后遍历并输出链表中的所有节点值。 处理流程示例假设输入如下： 1234565H 3H 2I 1 4D 2H 1 输入解释 第1行：5 表示有5个操作。 第2行：H 3 在头部插入值为3的节点。 第3行：H 2 在头部插入值为2的节点。 第4行：I 1 4 在第1个节点后插入值为4的节点。 第5行：D 2 删除第2个节点后的节点。 第6行：H 1 在头部插入值为1的节点。 按照代码处理流程 初始化链表： 12head = -1;idx = 0; 执行操作： 操作 H 3： 1add_to_head(3); 更新后 e = [3]，ne = [-1]，head = 0，idx = 1。 操作 H 2： 1add_to_head(2); 更新后 e = [3, 2]，ne = [-1, 0]，head = 1，idx = 2。 操作 I 1 4： 1add(0, 4); 更新后 e = [3, 2, 4]，ne = [2, 0, -1]，head = 1，idx = 3。 操作 D 2： 1remove(1); 更新后 ne = [2, -1, -1]。 操作 H 1： 1add_to_head(1); 更新后 e = [3, 2, 4, 1]，ne = [2, -1, -1, 1]，head = 3，idx = 4。 遍历并输出链表： 1for (int i = head; i != -1; i = ne[i]) cout &lt;&lt; e[i] &lt;&lt; ' '; 从头指针 head = 3 开始遍历，输出结果为： 11 2 总结通过这个例子，可以看到如何按照输入操作动态地更新链表，并最终输出链表的内容。每个操作都按照代码中的逻辑逐步进行，链表结构在每一步都进行了相应的更新和调整。","link":"/2024/06/04/%E5%8D%95%E9%93%BE%E8%A1%A8/"},{"title":"归并排序(merge_sort)","text":"题目描述给定你一个长度为 n 的整数数列。请你使用归并排序对这个数列按照从小到大进行排序，并将排好序的数列按顺序输出。 输入格式输入共两行，第一行包含整数 n。第二行包含 n 个整数（所有整数均在 1∼109 范围内），表示整个数列。 输出格式输出共一行，包含 n 个整数，表示排好序的数列。 数据范围1 ≤ n ≤ 100000 样例输入样例：1253 1 2 4 5 输出样例：11 2 3 4 5 算法1 (排序) O(nlogn)归并排序板子，先分组，再组合（merge） C++ 代码1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;#define N 100005int n, q[N];void merge_sort(int q[], int l, int r) { if (l &gt;= r) return; int mid = (l + r) &gt;&gt; 1; merge_sort(q, l, mid); merge_sort(q, mid + 1, r); int temp[N]; int k = 0; int x = l, y = mid + 1; while (x &lt;= mid &amp;&amp; y &lt;= r) { if (q[x] &lt;= q[y]) temp[++k] = q[x++]; else temp[++k] = q[y++]; } while (x &lt;= mid) temp[++k] = q[x++]; while (y &lt;= r) temp[++k] = q[y++]; for (int i = 1, j = l; j &lt;= r; ++i, ++j) q[j] = temp[i];}int main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, q + i); merge_sort(q, 1, n); for (int i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;, q[i]); return 0;}","link":"/2024/05/27/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-merge-sort/"},{"title":"前缀和","text":"前缀和实现在处理数组区间求和时，可以使用前缀和技术来提高效率。本文将介绍如何使用C++实现前缀和。 代码实现以下是一个实现前缀和的完整C++代码示例： 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;#define N 100010long long f[N];int n, m, t, x, y;int main() { scanf(&quot;%d %d&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= n; ++i) { scanf(&quot;%d&quot;, &amp;t); f[i] = f[i - 1] + t; } while(m--) { scanf(&quot;%d %d&quot;, &amp;x, &amp;y); printf(&quot;%lld&quot;, f[y] - f[x - 1]); } return 0;} 示例输入输出以下是一些示例输入和对应的输出，帮助理解代码的工作原理。 示例 1输入： 123455 31 2 3 4 51 32 41 5 输出： 1236915 示例 2输入： 12346 21 1 1 1 1 11 63 5 输出： 1263 示例 3输入： 1234 110 20 30 402 3 输出： 150 代码说明输入处理： 使用 scanf 函数读取数组长度 n 和查询次数 m。 读取数组元素，并计算前缀和存储在数组 f 中。 前缀和实现： 通过累加前缀和数组 f，使 f[i] 表示前 i 个元素的和。 对于每个查询，计算并输出区间和 f[y] - f[x - 1]。 主函数逻辑： 读取输入数据并计算前缀和数组。 处理每个查询，输出对应的区间和。","link":"/2024/06/01/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"title":"整数二分(besearch)","text":"题目描述给定一个按照升序排列的长度为 n 的整数数组，以及 q 个查询。对于每个查询，返回一个元素 k 的起始位置和终止位置（位置从 0 开始计数）。如果数组中不存在该元素，则返回 -1 -1。 输入格式 第一行包含整数 n 和 q，表示数组长度和询问个数。 第二行包含 n 个整数（均在 1∼10000 范围内），表示完整数组。 接下来 q 行，每行包含一个整数 k，表示一个询问元素。 输出格式共 q 行，每行包含两个整数，表示所求元素的起始位置和终止位置。如果数组中不存在该元素，则返回 -1 -1。 数据范围 1≤n≤100000 1≤q≤10000 1≤k≤10000 样例输入样例：123456 31 2 2 3 3 4345 输出样例：1233 45 5-1 -1 算法1(二分) O(nlogn)枚举左端点和右端点 C++ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;using namespace std;#define N 1000010int n, k, q, a[N];// 查找元素q在数组a中的首次和最后一次出现的位置void bearch(int q) { // leftans和rightans用于存储结果，初始化为最大值和最小值 int leftans = INT_MAX, rightans = INT_MIN; int l = 0, r = n - 1; // 找到元素q的首次出现位置 while (l &lt; r) { int mid = (l + r) &gt;&gt; 1; // 等价于 (l + r) / 2 if (a[mid] &gt;= q) r = mid; else l = mid + 1; } // 如果在数组a中没有找到元素q，输出-1 -1 if (a[l] != q) { printf(&quot;-1 -1\\n&quot;); return; } // 输出元素q的首次出现位置 printf(&quot;%d &quot;, l); // 重置左右边界，准备查找最后一次出现位置 l = 0, r = n - 1; // 找到元素q的最后一次出现位置 while (l &lt; r) { int mid = (l + r + 1) &gt;&gt; 1; // 等价于 (l + r + 1) / 2 if (a[mid] &lt;= q) l = mid; else r = mid - 1; } // 输出元素q的最后一次出现位置 printf(&quot;%d\\n&quot;, l); return;}int main() { // 输入数组长度n和查询次数k scanf(&quot;%d %d&quot;, &amp;n, &amp;k); // 输入数组元素 for (int i = 0; i &lt; n; ++i) scanf(&quot;%d&quot;, a + i); // 对每个查询执行bearch函数 while (k--) { scanf(&quot;%d&quot;, &amp;q); bearch(q); } return 0;} 算法2(upperbound 和 lowerbound) O(nlogn)STL 大法好！！！ 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;#define N 1000010int n, k, q, a[N];int main() { scanf(&quot;%d %d&quot;, &amp;n, &amp;k); for (int i = 0; i &lt; n; ++i) scanf(&quot;%d&quot;,a + i); while (k--) { scanf(&quot;%d&quot;, &amp;q); int t = lower_bound(a, a + n, q) - a; if (t == n || a[t] != q) { puts(&quot;-1 -1&quot;); continue; } printf(&quot;%d &quot;, t); t = upper_bound(a, a + n, q) - a; printf(&quot;%d\\n&quot;, t - 1); } return 0;}","link":"/2024/05/28/%E6%95%B4%E6%95%B0%E4%BA%8C%E5%88%86/"},{"title":"数的三次方根","text":"题目描述给定一个浮点数 n，求它的三次方根。 输入格式共一行，包含一个浮点数 n。 输出格式共一行，包含一个浮点数，表示问题的解。 注意，结果保留 6 位小数。 数据范围 −10000≤n≤10000 样例输入样例：11000.00 输出样例：110.000000 算法1(二分) O(logn)小数二分 C++ 代码123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;double x;double bsearch(double x) { double l = -1e3, r = 1e3; while(r - l &gt; 1e-8) { //取保留位数多2位,如:保留一位小数,写1e-3 double mid = (l + r) / 2; if(mid * mid * mid &gt;= x) r = mid; else l = mid; } return l;}int main() { cin &gt;&gt; x; printf(&quot;%.6lf&quot;,bsearch(x)); return 0;}","link":"/2024/05/28/%E6%95%B0%E7%9A%84%E4%B8%89%E6%AC%A1%E6%96%B9%E6%A0%B9/"},{"title":"栈","text":"","link":"/2024/06/04/%E6%A0%88/"},{"title":"滑动窗口","text":"滑动窗口实现滑动窗口是一种常用的算法技巧，用于在数组或列表上进行高效的区间操作。本文将介绍如何使用C++实现滑动窗口。 问题描述给定一个长度为 n 的数组和一个整数 k，找出每个长度为 k 的子数组的最小值和最大值。 代码实现以下是一个实现滑动窗口的完整C++代码示例： 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;const int N = 100010;int n, k;int a[N], q[N];int main(){ scanf(&quot;%d%d&quot;, &amp;n, &amp;k); for(int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;a[i]); int hh = 0, tt = -1; for(int i = 0; i &lt; n; i++) { // 判断队头是否已经滑出窗口 if(hh &lt;= tt &amp;&amp; i - k + 1 &gt; q[hh]) hh++; while(hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt--; q[++tt] = i; if(i &gt;= k - 1) printf(&quot;%d &quot;, a[q[hh]]); } puts(&quot;&quot;); hh = 0, tt = -1; for(int i = 0; i &lt; n; i++) { // 判断队头是否已经滑出窗口 if(hh &lt;= tt &amp;&amp; i - k + 1 &gt; q[hh]) hh++; while(hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i]) tt--; q[++tt] = i; if(i &gt;= k - 1) printf(&quot;%d &quot;, a[q[hh]]); } puts(&quot;&quot;); return 0;} 示例输入输出以下是一些示例输入和对应的输出，帮助理解代码的工作原理。 示例 1输入： 128 31 3 -1 -3 5 3 6 7 输出： 12-1 -3 -3 -3 3 33 3 5 5 6 7 示例 2输入： 125 22 1 2 4 3 输出： 121 1 2 32 2 4 4 示例 3输入： 126 49 3 5 1 6 7 输出： 121 1 19 6 6 代码说明初始化滑动窗口： 定义数组 a 存储输入的数组，q 用作滑动窗口的队列。 读取数组长度 n 和窗口大小 k。 处理输入数据： 读取输入的数组元素，维护两个滑动窗口，分别用于求最小值和最大值。 主函数逻辑： 初始化队列，处理输入数据，并按照滑动窗口的规则输出每个子数组的最小值和最大值。","link":"/2024/06/06/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"title":"队列","text":"","link":"/2024/06/06/%E9%98%9F%E5%88%97/"},{"title":"面经","text":"1. Transformer模型的结构Transformer模型是由Vaswani等人在2017年提出的一种深度学习模型，主要用于自然语言处理任务，如翻译、文本生成等。Transformer模型的核心架构由编码器（Encoder）和解码器（Decoder）组成。以下是Transformer模型的详细结构： 1. 编码器（Encoder）编码器部分由N个相同的编码器层（Encoder Layer）堆叠而成。每个编码器层包括两个子层： a. 多头自注意力机制（Multi-Head Self-Attention Mechanism） 输入：一组向量表示（如单词的词嵌入）。 输出：对输入向量进行加权求和，以捕捉全局依赖关系。 多头机制：通过多个注意力头（Attention Heads）来捕捉不同子空间的特征。 b. 前馈神经网络（Feed-Forward Neural Network） 包含两个线性变换层和一个激活函数（通常是ReLU）。 输入：经过多头自注意力机制后的输出。 输出：经过非线性变换后的表示。 每个子层后都有一个残差连接（Residual Connection）和层归一化（Layer Normalization）。 2. 解码器（Decoder）解码器部分也由N个相同的解码器层（Decoder Layer）堆叠而成。每个解码器层包括三个子层： a. 多头自注意力机制（Masked Multi-Head Self-Attention Mechanism） 类似于编码器中的多头自注意力机制，但这里的自注意力是被掩盖的，以确保解码过程中当前词只能关注到之前的词。 b. 编码器-解码器注意力机制（Encoder-Decoder Attention Mechanism） 输入：编码器的输出和解码器自注意力的输出。 输出：结合编码器信息和当前解码步骤信息的表示。 c. 前馈神经网络（Feed-Forward Neural Network） 与编码器中的前馈神经网络类似。 每个子层后也有残差连接和层归一化。 3. 位置编码（Positional Encoding）由于Transformer没有卷积和循环结构，它使用位置编码来注入关于序列顺序的信息。这些位置编码是添加到输入向量中的。 4. 全局架构 编码器：将输入序列编码为一组隐层表示。 解码器：基于编码器的表示和之前生成的词，生成输出序列。 注意力机制（Attention Mechanism）Transformer的核心是注意力机制，特别是自注意力机制。以下是其关键步骤： 计算注意力分数（Scores）： 其中，( Q ) 是查询矩阵，( K ) 是键矩阵，( V ) 是值矩阵，( d_k ) 是键向量的维度。 多头注意力（Multi-Head Attention）：通过并行的多个注意力头来学习不同的特征表示：每个头的计算方法类似，但使用不同的参数。 总结Transformer模型通过并行化的多头自注意力机制和前馈神经网络，极大地提高了序列到序列任务的效率和性能。它在许多自然语言处理任务中都取得了显著的成功，并成为了现代自然语言处理的基石。 2. 为什么要用 SwimTransformer 而不用cnnSwin Transformer 和 CNN（卷积神经网络）在架构和处理图像的方式上有显著的区别。以下是对这两者的详细比较以及Swin Transformer的优势： 1. 架构区别CNN（卷积神经网络） 基本单元：卷积层（Convolutional Layer），通过卷积核（filter）提取局部特征。 特征提取方式：局部感受野（Local Receptive Field），在输入图像的局部区域内滑动卷积核进行特征提取。 池化层（Pooling Layer）：用于下采样，减小特征图尺寸，通常使用最大池化（Max Pooling）或平均池化（Average Pooling）。 层次结构：通常由多个卷积层、池化层和全连接层（Fully Connected Layer）堆叠而成。 Swin Transformer（滑动窗口Transformer） 基本单元：Transformer编码器层（Transformer Encoder Layer），采用自注意力机制（Self-Attention Mechanism）。 特征提取方式：通过滑动窗口（Sliding Window）进行局部注意力计算，划分图像为不重叠的窗口，在每个窗口内计算自注意力。 分层结构：包括多层Swin Transformer块，每个块包含局部注意力机制、跨窗口连接和前馈网络。 多尺度表示：通过分层设计实现多尺度特征提取，类似于CNN中的层次结构，但更灵活。 2. 优势比较CNN 的优势 计算效率高：卷积操作在计算和内存上都非常高效，特别适合在图像处理中应用。 局部特征提取：擅长提取局部特征，如边缘、纹理等，适用于大多数图像识别任务。 结构简单：卷积层和池化层的设计简单明了，易于理解和实现。 Swin Transformer 的优势 全局建模能力：通过自注意力机制，能够在整个图像范围内建立全局上下文关系，而不仅仅局限于局部区域。 灵活的窗口设计：滑动窗口机制结合了局部和全局特征提取的优势，通过窗口内和跨窗口的注意力计算，能够更好地捕捉多尺度信息。 适应性强：可以通过改变窗口大小和层数，灵活调整模型以适应不同规模和复杂度的任务。 统一架构：Transformer架构在自然语言处理和计算机视觉任务中的成功应用，表明其在处理不同类型数据上的强大适应性。 为什么使用 Swin Transformer 而不是 CNN 全局特征提取：Swin Transformer的自注意力机制可以在整个图像上建模长距离依赖关系，适合处理需要全局上下文信息的任务，如目标检测和语义分割。 多尺度特征：通过滑动窗口和分层设计，Swin Transformer能够更好地捕捉不同尺度的特征，这在多尺度特征非常重要的任务中表现出色。 灵活性和扩展性：Swin Transformer具有很强的灵活性，可以方便地扩展和调整以适应不同的任务和数据规模。而CNN的结构较为固定，适应性相对较差。 一致性和统一性：Transformer在不同任务中的成功应用，使其成为一种通用的架构，便于在不同任务之间共享和转移学习，而不需要设计不同的模型。 总结虽然CNN在计算效率和局部特征提取方面具有优势，但Swin Transformer通过结合自注意力机制和滑动窗口设计，实现了更强的全局建模能力和多尺度特征提取能力，适应性更强，尤其在处理复杂图像任务时表现出色。因此，在需要全局上下文信息和多尺度特征的任务中，使用Swin Transformer往往能够获得更好的效果。 3.为什么transformer 需要mask（掩码）Transformer中的mask（掩码）在不同的阶段和子模块中有不同的用途，主要是为了控制注意力机制的范围和确保模型生成输出时的正确性。以下是Transformer中不同类型mask的详细说明及其原因： 1. 自注意力中的Mask（Self-Attention Mask）a. Padding Mask（填充掩码） 用途：用于忽略填充部分的影响。 位置：在输入序列中。 原因：在处理变长序列时，输入序列通常被填充到相同长度。填充部分（通常是零）不应该影响注意力机制的计算，因此使用填充掩码来忽略这些位置。 实现：将填充位置的注意力分数设为负无穷大，以确保softmax后的注意力权重为零。 b. Look-Ahead Mask（前瞻掩码，也称为Causal Mask/未来掩码） 用途：确保在解码阶段，每个位置只能看到当前及之前的位置，不能看到未来的位置。 位置：在解码器中的自注意力层。 原因：在序列生成任务中（如语言模型或翻译），当前步骤的输出不能依赖未来的输入，因此需要前瞻掩码来阻止模型在当前时间步关注到未来时间步的信息。 实现：通过一个上三角矩阵来掩盖未来位置，将未来位置的注意力分数设为负无穷大。 2. 编码器-解码器注意力中的Maska. Padding Mask 用途：在编码器-解码器注意力中，解码器需要关注编码器的输出，因此也需要忽略填充部分的影响。 位置：在解码器的编码器-解码器注意力层。 原因：类似于自注意力中的填充掩码，确保解码器不会在注意力计算中考虑编码器输出中的填充位置。 实现：与自注意力中的填充掩码相同，将填充位置的注意力分数设为负无穷大。 3. 总结为什么需要Mask？ 处理变长输入：保证填充部分不会影响注意力机制的计算，确保模型只关注实际输入部分。 保证因果性：在序列生成任务中，保证生成的每一步只依赖于当前及之前的信息，而不泄露未来的信息。 提高模型性能：通过适当的掩码操作，可以提高模型训练的有效性和稳定性，避免无意义的注意力计算。 实际例子自注意力中的Look-Ahead Mask假设我们有一个输入序列[A, B, C, D]，在生成时，模型不应该在生成B时看到C和D。 生成Look-Ahead Mask的矩阵如下： 123456[ [0, -inf, -inf, -inf], [0, 0, -inf, -inf], [0, 0, 0, -inf], [0, 0, 0, 0]] 在这个矩阵中，0表示可以关注，-inf表示掩盖。 Padding Mask假设输入序列[A, B, PAD, PAD]，PAD表示填充位置。 生成的Padding Mask如下： 123[ [1, 1, 0, 0]] 在这个向量中，1表示实际输入位置，0表示填充位置。 结论Mask在Transformer中起到了重要的作用，通过控制注意力机制的范围，确保模型在训练和推理过程中关注正确的信息，提高模型的性能和稳定性。","link":"/2024/06/27/%E9%9D%A2%E7%BB%8F/"},{"title":"高精度乘法","text":"高精度乘法实现在处理大整数运算时，直接使用内置的数据类型可能会导致溢出，因此需要使用字符串或数组来存储大整数，并逐位进行运算。本文将介绍如何使用C++实现高精度乘法。 代码实现以下是一个实现高精度乘法的完整C++代码示例： 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; mul(vector&lt;int&gt; a, int b) { vector&lt;int&gt; c; int t = 0; for (int i = 0; i &lt; a.size(); i++) { t += a[i] * b; c.push_back(t % 10); t = t / 10; } while (t) { c.push_back(t % 10); t = t / 10; } return c;}int main() { string a; int b; cin &gt;&gt; a &gt;&gt; b; vector&lt;int&gt; A; for (int i = a.size() - 1; i &gt;= 0; i--) { A.push_back(a[i] - '0'); } auto C = mul(A, b); for (int i = C.size() - 1; i &gt;= 0; i--) { printf(&quot;%d&quot;, C[i]); } return 0;} 示例输入输出以下是一些示例输入和对应的输出，帮助理解代码的工作原理。 示例 1输入： 12123456789012345678909 输出： 1111111110111111110010 示例 2输入： 12987654321098765432108 输出： 1790123456879012345680 示例 3输入： 12999999999999999999995 输出： 1499999999999999999995 代码说明输入处理： 使用字符串 a 存储输入的大整数。 将字符串转换为倒序存储的整数数组 A。 乘法实现： 函数 mul 实现大整数与单个整数的逐位乘法，并处理进位。 主函数逻辑： 将字符串转换为整数数组，并进行逐位乘法计算。 逆序输出结果。","link":"/2024/05/30/%E9%AB%98%E7%B2%BE%E5%BA%A6%E4%B9%98%E6%B3%95/"},{"title":"面经2-attention(注意力机制)","text":"1.通俗的解释什么是attention注意力机制（Attention Mechanism）是深度学习中一种非常重要的技术，它帮助模型更好地“关注”输入数据中的重要部分。为了更通俗地解释，我们可以用一个简单的类比来帮助理解。 类比：读书做笔记假设你在阅读一本书，并且需要在阅读过程中做一些笔记。书中的内容非常多，但你不能也不需要记住每一个字。那么你会怎么做呢？你会重点关注那些对你来说重要的信息。注意力机制就像你在读书时选择性地关注重要内容一样。 具体步骤 输入信息： 你有一本书（输入数据），每一页上有很多文字（输入序列）。 关键内容： 你要做笔记，所以你需要找到哪些内容是最重要的，比如关键的段落、句子或单词。 注意力权重： 你给每个句子或段落分配一个重要性分数（权重）。更重要的内容分数更高，不太重要的内容分数更低。 加权求和： 你根据这些分数来决定每段内容在你笔记中的重要性。重要性高的内容，你会详细记下（加权求和后保留更多信息），重要性低的内容，你会略过或简要记下。 在深度学习中的应用在深度学习中，注意力机制通过以下步骤工作： 输入序列： 模型接收一段输入序列，比如一句话的每个单词的表示（向量）。 计算注意力分数： 模型计算每个单词对当前处理单词的重要性，类似于你给每段内容分配一个重要性分数。 生成注意力权重： 使用这些分数通过一个softmax函数转化为注意力权重，这些权重和分数可以理解为“关注度”。 加权求和： 对输入序列中的所有单词的表示进行加权求和，权重高的单词对最终表示的影响更大。 例子假设你在翻译一个句子：”The cat sat on the mat.” 在翻译时，模型需要决定哪些单词对当前正在翻译的单词最重要。例如，在翻译“sat”时，模型可能会发现“cat”和“mat”也很重要，因为它们在语义上相关。这时，注意力机制会给“cat”和“mat”更高的权重，而给其他不太相关的单词更低的权重。 总结注意力机制帮助模型在处理大量信息时，更加高效地聚焦于最相关和重要的部分。这不仅提高了模型的性能，也使得模型在处理复杂任务时更加灵活和精确。就像你在读书时会重点标记和记住重要的部分一样，注意力机制使得模型在处理数据时能够有效地“注意”到关键信息。 2.注意力机制的计算注意力机制（Attention Mechanism）在深度学习中的计算方法主要包括三个步骤：计算注意力分数、生成注意力权重、加权求和。以下是详细的计算过程，以自注意力（Self-Attention）为例进行解释。 1. 输入表示假设我们有一个输入序列，可以表示为矩阵 \\(X\\)，其中每一行代表序列中一个词的向量表示。对于一个长度为 \\(n\\) 的序列，每个词的向量维度为 \\(d\\)，因此输入矩阵 \\(X\\) 的形状为 \\(n \\times d\\)。 2. 计算查询（Query）、键（Key）和值（Value）首先，我们需要为每个输入向量计算查询（Query）、键（Key）和值（Value）向量。这是通过三个不同的线性变换完成的。假设 \\(W_Q\\)、\\(W_K\\) 和 \\(W_V\\) 分别是查询、键和值的权重矩阵，它们的形状都是 \\(d \\times d_k\\)。 $$ Q = XW_Q $$$$ K = XW_K $$$$ V = XW_V $$ 其中，\\(Q\\)、\\(K\\) 和 \\(V\\) 分别是查询、键和值的矩阵，它们的形状都是 \\(n \\times d_k\\)。 3. 计算注意力分数（Attention Scores）接下来，我们计算查询和键的点积来得到注意力分数。注意力分数表示每个词对其他词的重要性。 $$ \\text{scores} = QK^T $$ 这里，\\(\\text{scores}\\) 的形状是 \\(n \\times n\\)，表示每个词对其他所有词的注意力分数。 4. 生成注意力权重（Attention Weights）为了使得注意力分数更稳定，我们会对其进行缩放，除以 \\(\\sqrt{d_k}\\)。接下来，应用softmax函数将注意力分数转化为注意力权重，这些权重表示每个词对其他词的注意力分配。 $$ \\text{scaled_scores} = \\frac{QK^T}{\\sqrt{d_k}} $$$$ \\text{weights} = \\text{softmax}(\\text{scaled_scores}) $$ 注意力权重矩阵 \\(\\text{weights}\\) 的形状也是 \\(n \\times n\\)。 5. 加权求和（Weighted Sum）最后，使用注意力权重对值\\（Value\\）向量进行加权求和，得到最终的输出。 $$ \\text{output} = \\text{weights}V $$ 输出矩阵 \\(\\text{output}\\) 的形状是 \\(n \\times d_k\\)。 总结注意力机制的计算过程可以总结为以下几个步骤： 计算查询、键和值：$$ Q = XW_Q, \\quad K = XW_K, \\quad V = XW_V $$ 计算注意力分数：$$ \\text{scores} = QK^T $$ 缩放注意力分数并应用softmax：$$ \\text{scaled_scores} = \\frac{\\text{scores}}{\\sqrt{d_k}}, \\quad \\text{weights} = \\text{softmax}(\\text{scaled_scores}) $$ 计算加权求和：$$ \\text{output} = \\text{weights}V $$ 这个过程实现了从输入序列到输出序列的自适应权重计算，使得模型能够关注到输入序列中的重要部分。这种机制在各种任务（如机器翻译、文本生成、图像处理等）中都表现出了强大的性能。 3.注意力机制的k,q相似度计算都有哪些方法，各自有什么优缺点在注意力机制中，查询（Query，Q）和键（Key，K）之间的相似度计算是核心步骤，用于确定注意力权重。不同的相似度计算方法有不同的优缺点。以下是几种常见的方法及其优缺点： 1. 点积相似度（Dot-Product Similarity）计算方法$$ \\text{score}(Q, K) = Q \\cdot K^T $$ 优点 计算简单：点积相似度计算非常高效，尤其是在硬件加速（如GPU）上可以充分利用矩阵乘法的优化。 常用方法：点积相似度是Transformer模型中的默认选择，被广泛使用和验证。 缺点 维度影响：随着向量维度增加，点积值可能会变得很大，导致softmax函数的梯度过小。为此，通常需要缩放因子（如 \\(\\sqrt{d_k}\\)）来稳定计算。 2. 缩放点积相似度（Scaled Dot-Product Similarity）计算方法$$ \\text{score}(Q, K) = \\frac{Q \\cdot K^T}{\\sqrt{d_k}} $$ 优点 稳定梯度：通过缩放因子 \\(\\sqrt{d_k}\\) 减少了随着维度增加而导致的梯度消失问题。 广泛应用：在Transformer模型中被默认使用，性能稳定。 缺点 需要缩放：虽然解决了梯度问题，但增加了一步额外的缩放计算。 3. 余弦相似度（Cosine Similarity）计算方法$$ \\text{score}(Q, K) = \\frac{Q \\cdot K^T}{|Q| |K|} $$ 优点 归一化相似度：将向量的相似度归一化到[-1, 1]之间，消除了向量长度对相似度的影响。 可解释性强：余弦相似度在各种应用中都有较好的解释性。 缺点 计算复杂度：需要计算向量的范数，增加了计算复杂度。 性能问题：在某些场景下，余弦相似度的效果可能不如点积相似度。 4. 加性注意力（Additive Attention 或 Bahdanau Attention）计算方法$$ \\text{score}(Q, K) = w^T \\tanh(W_Q Q + W_K K + b) $$其中，\\(w\\)、\\(W_Q\\)、\\(W_K\\) 和 \\(b\\) 是可训练的参数。 优点 灵活性高：通过可训练参数，可以更灵活地学习不同类型的相似度。 广泛应用：特别是在早期的Seq2Seq模型中应用广泛。 缺点 计算开销大：涉及更多的参数和非线性操作（tanh），计算开销较大。 复杂度高：相比点积相似度，计算更复杂。 5. 高斯注意力（Gaussian Attention）计算方法$$ \\text{score}(Q, K) = \\exp\\left(-\\frac{|Q - K|^2}{2\\sigma^2}\\right) $$ 优点 平滑注意力分布：使用高斯函数计算相似度，可以产生更加平滑的注意力分布。 与距离相关：自然地反映了向量之间的欧氏距离。 缺点 参数选择：需要选择合适的 \\(\\sigma\\) 值，参数选择不当可能导致效果不佳。 计算开销大：计算欧氏距离和指数函数增加了计算开销。 总结每种相似度计算方法都有其特定的优缺点，选择哪种方法通常取决于具体应用场景和需求： 点积相似度和缩放点积相似度：计算简单高效，适用于大多数Transformer模型。 余弦相似度：适用于需要归一化相似度的场景，但计算复杂度较高。 加性注意力：灵活性高，但计算开销大，适用于需要灵活相似度计算的应用。 高斯注意力：平滑分布和距离相关，但计算复杂度和参数选择是挑战。 实际应用中，缩放点积相似度是最常用和有效的方法，尤其是在Transformer架构中。 4.attention的计算中为什么要除以根号dk在注意力机制的计算中，将点积相似度除以 \\(\\sqrt{d_k}\\) 是为了稳定计算过程，防止数值溢出。这一步骤通常称为缩放点积相似度（Scaled Dot-Product Attention）。以下是详细的原因和解释： 原因和解释1. 避免数值不稳定 高维点积值过大： 在高维空间中，向量的点积值随着维度的增加会变得很大。这是因为点积的结果是多个元素乘积的累加，维度越高，累加的值越大。假设两个向量 \\(Q\\) 和 \\(K\\) 的每个元素都是均值为零、方差为1的独立随机变量，那么它们的点积 \\(\\sum_{i=1}^{d_k} Q_i K_i\\) 的方差是 \\(d_k\\)。随着 \\(d_k\\) 增加，点积的值会越来越大。 softmax梯度消失： 在计算注意力权重时，点积相似度值作为输入会被传递到softmax函数中。如果这些值很大，softmax函数的输出会变得极端，即接近0或1。这会导致梯度消失问题，使得模型在训练过程中难以有效更新参数。 2. 缩放稳定计算 **缩放因子 \\(\\sqrt{d_k}\\)**： 为了避免上述问题，我们在计算点积相似度后，除以 \\(\\sqrt{d_k}\\)。这一缩放因子将点积相似度值缩小到一个更合理的范围，防止值过大。 具体地，缩放后的值更接近于均值为0、方差为1的标准正态分布。这使得softmax函数的输入值不会太大，从而生成的注意力权重更加平滑，梯度更新也更稳定。 数学解释假设 \\(Q\\) 和 \\(K\\) 是维度为 \\(d_k\\) 的向量：$$ \\text{score}(Q, K) = Q \\cdot K^T = \\sum_{i=1}^{d_k} Q_i K_i $$ 如果 \\(Q_i\\) 和 \\(K_i\\) 的元素是均值为0、方差为1的随机变量，那么点积的结果的期望值为0，但方差为 \\(d_k\\)：$$ \\text{Var}(Q \\cdot K^T) = d_k $$ 为了使得点积相似度的方差不随\\(d_k\\) 增加，我们将其除以 \\(\\sqrt{d_k}\\)：$$ \\text{scaled_score}(Q, K) = \\frac{Q \\cdot K^T}{\\sqrt{d_k}} $$ 这将点积的方差标准化为1，输入到softmax函数的值范围更加稳定。 例子和效果例如，在维度 \\(d_k = 64\\) 的情况下，如果不进行缩放，点积的值可能会变得很大（例如，在0到64之间）。经过softmax后，权重会极端化，导致某些注意力权重接近1，而其他接近0。这种极端的权重分布会使模型的学习变得困难。而通过缩放因子 \\(\\sqrt{64} = 8\\)，点积值会被缩小到一个更合理的范围（例如，在0到8之间），使得softmax输出的权重更平滑，梯度更稳定。 总结将点积相似度除以 \\(\\sqrt{d_k}\\) 的目的是为了： 防止高维向量点积值过大导致的数值不稳定问题。 生成更平滑的注意力权重分布，避免softmax输出的极端化，稳定梯度更新过程。 这一步骤是Transformer模型中的一个重要细节，确保了注意力机制在高维情况下的有效性和稳定性。","link":"/2024/06/27/%E9%9D%A2%E7%BB%8F2-attention-%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/"},{"title":"算法总结","text":"目录 一、基础算法 3 快速排序算法模板 3 归并排序算法模板 4 逆序对数量 5 整数二分算法模板 6 浮点数二分算法模板 7 高精度加法 7 高精度减法 8 高精度比大小（cmp函数） 8 高精度乘低精度 8 高精度乘高精度 9 高精度除低精度 9 高精度除高精度 10 一维前缀和 11 二维前缀和 11 一维差分 12 二维差分 13 位运算 14 双指针算法 14 离散化 14 区间合并 16 二、数据结构 17 单链表 17 双链表 18 栈 19 队列 20 循环队列 21 单调栈 22 单调队列 23 KMP字符串匹配 24 二叉树的存储与遍历 25 Trie树 28 并查集 29 堆 32 一般hash 33 字符串哈希 34 三、搜索与图论 37 树与图的存储 38 邻接矩阵 38 邻接表 38 树与图的遍历 38 应用：数字全排列 39 应用：树的重心 39 应用：n-皇后问题 41 宽度优先遍历 42 应用：走迷宫 42 应用：八数码 43 拓扑排序 44 Dijkstra算法 46 Bellman-Ford算法 49 SPFA算法（队列优化的Bellman-Ford算法） 52 floyd算法 55 最短路算法总结 57 prim算法 57 Kruskal算法 59 染色法判别二分图 62 匈牙利算法 64 四、数学知识 67 试除法判定质数 68 试除法分解质因数 68 埃氏筛法求质数 68 线性筛法求质数 69 试除法求所有约数 69 约数个数 69 约数之和 70 欧几里得算法(求最大公约数) 71 最小公倍数 72 求欧拉函数 72 线性筛法求欧拉函数 73 快速幂 74 扩展欧几里得算法 74 中国剩余定理 75 扩展中国剩余定理 76 高斯消元法 76 求组合数 79 Lucas定理求组合数 81 分解质因数法求组合数 83 容斥原理应用 87 博弈论 88 五、动态规划 91 闫式dp分析法.jpg 91 背包问题 91 区间DP 100 计数类DP 102 数位统计DP 102 状态压缩DP 104 树形DP 106 记忆化搜索 108 六、贪心 109 区间问题 109 区间选点 109 区间分组 111 排序不等式 112 排队打水 112 一、基础算法快速排序算法模板void quick_sort(int q[], int l, int r) { //递归的终止情况 if (l &gt;= r) return; //选取分界线。这里选数组中间那个数 int i = l - 1, j = r + 1, x = q[l + r &gt;&gt; 1]; //划分成左右两个部分 while (i &lt; j) { do i ++ ; while (q[i] &lt; x); do j -- ; while (q[j] &gt; x); if (i &lt; j) swap(q[i], q[j]); } //对左右部分排序 quick_sort(q, l, j), quick_sort(q, j + 1, r); } 边界问题：因为边界问题只有这两种组合，不能随意搭配 1.x不能取q[l]和q[l+r&gt;&gt;1]; quick_sort(q,l,i-1),quick_sort(q,i,r); 2.x不能取q[r]和q[(l+r+1)&gt;&gt;1]; quick_sort(q,l,j),quick_sort(q,j+1,r); 归并排序算法模板void merge_sort(int q[], int l, int r) { //递归的终止情况 if (l &gt;= r) return; //第一步：分成子问题 int mid = l + r &gt;&gt; 1; //第二步：递归处理子问题 merge_sort(q, l, mid); merge_sort(q, mid + 1, r); //第三步：合并子问题 int k = 0, i = l, j = mid + 1; while (i &lt;= mid &amp;&amp; j &lt;= r) if (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ]; else tmp[k ++ ] = q[j ++ ]; while (i &lt;= mid) tmp[k ++ ] = q[i ++ ]; while (j &lt;= r) tmp[k ++ ] = q[j ++ ]; //第四步：复制回原数组 for (i = l, j = 0; i &lt;= r; i ++, j ++ ) q[i] = tmp[j]; } 逆序对数量在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。 思路：归并排序 举个例子： 在合并 {4 ,5} {1 , 2} 的时候，首先我们判断 1 &lt; 4，我们即可统计出逆序对为2，为什么呢？这利用了数组的部分有序性。因为我们知道 {4 ,5} 这个数组必然是有序的，因为是合并上来的。此时当 1比4小的时候，证明4以后的数也都比1大，此时就构成了从4开始到 {4,5}这个数组结束，这么多个逆序对（2个），此时利用一个临时数组，将1存放起来，接着比较2和4的大小，同样可以得到有2个逆序对，于是将2也放进临时数组中，此时右边数组已经完全没有元素了，则将左边剩余的元素全部放进临时元素中，最后将临时数组中的元素放进原数组对应的位置。 最后接着向上合并~ 逆序对数量.png 归并排序求逆序对.gif using namespace std; typedef long long LL; const int N = 100010; int n; int q[N], tmp[N]; LL merge_sort(int l, int r) { if (l &gt;= r)return 0; int mid = (l + r) &gt;&gt; 1; LL res = merge_sort(l, mid) + merge_sort(mid + 1, r); // 归并的过程 int k = 0, i = l, j = mid + 1; while (i &lt;= mid &amp;&amp; j &lt;= r) if (q[i] &lt;= q[j])tmp[k++] = q[i++]; else { tmp[k++] = q[j++]; res += mid - i + 1; } //扫尾 while (i &lt;= mid)tmp[k++] = q[i++]; while (j &lt;= r)tmp[k++] = q[j++]; //物归原主 for (i = l, j = 0; i &lt;= r; j++, i++)q[i] = tmp[j]; return res; } int main() { cin &gt;&gt; n; for (int i = 0; i &lt; n; i++)cin &gt;&gt; q[i]; cout &lt;&lt; merge_sort(0, n - 1) &lt;&lt; endl; return 0; } 整数二分算法模板对lower_bound来说，它寻找的就是第一个满足条件“值大于等于x”的元素的位置；对upper_bound函数来说，它寻找的是第一个满足“值大于 x”的元素的位置。 bool check(int x) {/* … */} // 检查x是否满足某种性质 // 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用： int bsearch_1(int l, int r) { while (l &lt; r) { int mid = l + r &gt;&gt; 1; if (check(mid)) r = mid; // check()判断mid是否满足性质 else l = mid + 1;//左加右减 } return l; } // 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用： int bsearch_2(int l, int r) { while (l &lt; r) { int mid = l + r + 1 &gt;&gt; 1;//如果下方else后面是l则这里加1 if (check(mid)) l = mid; else r = mid - 1;//左加右减 } return l; } 浮点数二分算法模板bool check(double x) {/* … */} // 检查x是否满足某种性质 double bsearch_3(double l, double r) { const double eps = 1e-6; // eps 表示精度，取决于题目对精度的要求 while (r - l &gt; eps) { double mid = (l + r) / 2; if (check(mid)) r = mid; else l = mid; } return l; } 高精度加法// C = A + B, A &gt;= 0, B &gt;= 0 vector add(vector &amp;a,vector &amp;b){ //c为答案 vector&lt;int&gt; c; //t为进位 int t=0; for(int i=0;i&lt;a.size()||i&lt;b.size();i++){ //不超过a的范围添加a[i] if(i&lt;a.size())t+=a[i]; //不超过b的范围添加b[i] if(i&lt;b.size())t+=b[i]; //取当前位的答案 c.push_back(t%10); //是否进位 t/=10; } //如果t!=0的话向后添加1 if(t)c.push_back(1); return c; } 高精度减法// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0 vector sub(vector &amp;A, vector &amp;B) { //答案 vector&lt;int&gt; C; //遍历最大的数 for (int i = 0, t = 0; i &lt; A.size(); i ++ ) { //t为进位 t = A[i] - t; //不超过B的范围t=A[i]-B[i]-t; if (i &lt; B.size()) t -= B[i]; //合二为一，取当前位的答案 C.push_back((t + 10) % 10); //t&lt;0则t=1 if (t &lt; 0) t = 1; //t&gt;=0则t=0 else t = 0; } //去除前导零 while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); return C; } 高精度比大小（cmp函数）//高精度比大小 bool cmp(vector &amp;A, vector &amp;B) { if (A.size() != B.size()) return A.size() &gt; B.size(); for (int i = A.size() - 1; i &gt;= 0; i -- ) if (A[i] != B[i]) return A[i] &gt; B[i]; return true; } 高精度乘低精度// C = A * b, A &gt;= 0, b &gt;= 0 vector mul(vector &amp;A, int b) { //类似于高精度加法 vector&lt;int&gt; C; //t为进位 int t = 0; for (int i = 0; i &lt; A.size() || t; i ++ ) { //不超过A的范围t=t+A[i]*b if (i &lt; A.size()) t += A[i] * b; //取当前位的答案 C.push_back(t % 10); //进位 t /= 10; } //去除前导零 while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); return C; } 高精度乘高精度高精度加减乘除：https://www.bilibili.com/video/BV1LA411v7mt/ vector mul(vector &amp;A, vector &amp;B) { vector&lt;int&gt; C(A.size() + B.size()); // 初始化为 0，C的size可以大一点 for (int i = 0; i &lt; A.size(); i++) for (int j = 0; j &lt; B.size(); j++) C[i + j] += A[i] * B[j]; for (int i = 0, t = 0; i &lt; C.size(); i++) { // i = C.size() - 1时 t 一定小于 10 t += C[i]; C[i] = t % 10; t /= 10; } while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); // 必须要去前导 0，因为最高位很可能是 0 return C; } 高精度除低精度// A / b = C … r, A &gt;= 0, b &gt; 0 vector div(vector &amp;A, int b, int &amp;r)//高精度A，低精度b，余数r { vector&lt;int&gt; C;//答案 r = 0; for (int i = A.size() - 1; i &gt;= 0; i -- ) { r = r * 10 + A[i];//补全r&gt;=b C.push_back(r / b);//取当前位的答案 r %= b;//r%b为下一次计算 } reverse(C.begin(), C.end());//倒序为答案 while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();//去除前导零 return C; } 高精度除高精度高精度加减乘除：https://www.bilibili.com/video/BV1LA411v7mt/ vector div(vector &amp;A, vector &amp;B, vector &amp;r) { vector&lt;int&gt; C; if (!cmp(A, B)) { C.push_back(0); r.assign(A.begin(), A.end()); return C; } int j = B.size(); r.assign(A.end() - j, A.end()); while (j &lt;= A.size()) { int k = 0; while (cmp(r, B)) { r = sub(r, B); k ++; } C.push_back(k); if (j &lt; A.size()) r.insert(r.begin(), A[A.size() - j - 1]); if (r.size() &gt; 1 &amp;&amp; r.back() == 0) r.pop_back(); j++; } reverse(C.begin(), C.end()); while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); return C; } 一维前缀和前缀和可以用于快速计算一个序列的区间和，也有很多问题里不是直接用前缀和，但是借用了前缀和的思想。 预处理:s[i]=a[i]+a[i-1] 求区间[l,r]:sum=s[r]-s[l-1] “前缀和数组”和”原数组”可以合二为一 应用 const int N=100010; int a[N]; int main(){ int n,m; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1;i&lt;=n;i++)a[i]=a[i-1]+a[i]; scanf(&quot;%d&quot;,&amp;m); while(m--){ int l,r; scanf(&quot;%d%d&quot;,&amp;l,&amp;r); printf(&quot;%d\\n&quot;,a[r]-a[l-1]); } return 0; } 二维前缀和计算矩阵的前缀和：s[x][y] = s[x - 1][y] + s[x][y -1] - s[x-1][y-1] + a[x][y] 以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为： 计算子矩阵的和：s = s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 -1] 应用 int s[1010][1010]; int n,m,q; int main(){ scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;q); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) scanf(&quot;%d&quot;,&amp;s[i][j]); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) s[i][j]+=s[i-1][j]+s[i][j-1]-s[i-1][j-1]; while(q--){ int x1,y1,x2,y2; scanf(&quot;%d%d%d%d&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2); printf(&quot;%d\\n&quot;,s[x2][y2]-s[x2][y1-1]-s[x1-1][y2]+s[x1-1][y1-1]); } return 0; } 一维差分差分是前缀和的逆运算，对于一个数组a，其差分数组b的每一项都是a [ i ]和前一项a [ i − 1 ]的差。 注意：差分数组和原数组必须分开存放！！！！ 给区间[l, r]中的每个数加上c：B[l] += c, B[r + 1] -= c 应用 using namespace std; int a[100010],s[100010]; int main(){ int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i]; for(int i=1;i&lt;=n;i++)s[i]=a[i]-a[i-1];// 读入并计算差分数组 while(m--){ int l,r,c; cin&gt;&gt;l&gt;&gt;r&gt;&gt;c; s[l]+=c; s[r+1]-=c;// 在原数组中将区间[l, r]加上c } for(int i=1;i&lt;=n;i++){ s[i]+=s[i-1]; cout&lt;&lt;s[i]&lt;&lt;' '; }// 给差分数组计算前缀和，就求出了原数组 return 0; } 二维差分给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c： S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c 应用 const int N = 1e3 + 10; int a[N][N], b[N][N]; void insert(int x1, int y1, int x2, int y2, int c) { b[x1][y1] += c; b[x2 + 1][y1] -= c; b[x1][y2 + 1] -= c; b[x2 + 1][y2 + 1] += c; } int main() { int n, m, q; cin &gt;&gt; n &gt;&gt; m &gt;&gt; q; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) cin &gt;&gt; a[i][j]; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { insert(i, j, i, j, a[i][j]); //构建差分数组 } } while (q--) { int x1, y1, x2, y2, c; cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c; insert(x1, y1, x2, y2, c);//加c } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { b[i][j] += b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1]; //二维前缀和 } } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { printf(&quot;%d &quot;, b[i][j]); } printf(&quot;\\n&quot;); } return 0; } 关于前缀和与差分的相关博客链接：https://blog.csdn.net/qq_39757593/article/details/129219491 位运算求n的第k位数字: n &gt;&gt; k &amp; 1 返回n的最后一位1：lowbit(n) = n &amp; -n 双指针算法for (int i = 0, j = 0; i &lt; n; i ++ ) { while (j &lt; i &amp;&amp; check(i, j)) j ++ ; // 具体问题的逻辑 } 常见问题分类： (1) 对于一个序列，用两个指针维护一段区间 (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作 离散化离散化的本质是建立了一段数列到自然数之间的映射关系（value -&gt; index)，通过建立新索引，来缩小目标区间，使得可以进行一系列连续数组可以进行的操作比如二分，前缀和等… 离散化首先需要排序去重： 1.排序：sort(alls.begin(),alls.end()) 2.去重：alls.earse(unique(alls.begin(),alls.end()),alls.end()); vector alls; // 存储所有待离散化的值 sort(alls.begin(), alls.end()); // 将所有值排序 alls.erase(unique(alls.begin(), alls.end()), alls.end()); // 去掉重复元素 // 二分求出x对应的离散化的值 int find(int x) // 找到第一个大于等于x的位置 { int l = 0, r = alls.size() - 1; while (l &lt; r) { int mid = l + r &gt;&gt; 1; if (alls[mid] &gt;= x) r = mid; else l = mid + 1; } return r + 1; // 映射到1, 2, ...n } 应用 typedef pair&lt;int, int&gt; PII; const int N = 300010; int n, m; int a[N], s[N]; vector alls;//存入下标容器 vector add, query;//add增加容器，存入对应下标和增加的值的大小 //query存入需要计算下标区间和的容器 int find(int x) { int l = 0, r = alls.size() - 1; while (l &lt; r)//查找大于等于x的最小的值的下标 { int mid = l + r &gt;&gt; 1; if (alls[mid] &gt;= x) r = mid; else l = mid + 1; } return r + 1;//因为使用前缀和，其下标要+1可以不考虑边界问题 } int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i ++ ) { int x, c; cin &gt;&gt; x &gt;&gt; c; add.push_back({x, c});//存入下标即对应的数值c alls.push_back(x);//存入数组下标x=add.first } for (int i = 0; i &lt; m; i ++ ) { int l, r; cin &gt;&gt; l &gt;&gt; r; query.push_back({l, r});//存入要求的区间 alls.push_back(l);//存入区间左右下标 alls.push_back(r); } // 区间去重 sort(alls.begin(), alls.end()); alls.erase(unique(alls.begin(), alls.end()), alls.end()); // 处理插入 for (auto item : add) { int x = find(item.first);//将add容器的add.secend值存入数组a[]当中， a[x] += item.second;//在去重之后的下标集合alls内寻找对应的下标并添加数值 } // 预处理前缀和 for (int i = 1; i &lt;= alls.size(); i ++ ) s[i] = s[i - 1] + a[i]; // 处理询问 for (auto item : query) { int l = find(item.first), r = find(item.second);//在下标容器中查找对应的左右两端[l~r]下标，然后通过下标得到前缀和相减再得到区间a[l~r]的和 cout &lt;&lt; s[r] - s[l - 1] &lt;&lt; endl; } return 0; } 区间合并// 将所有存在交集的区间合并 void merge(vector &amp;segs) { vector&lt;PII&gt; res; sort(segs.begin(), segs.end()); int st = -2e9, ed = -2e9; for (auto seg : segs) if (ed &lt; seg.first) { if (st != -2e9) res.push_back({st, ed}); st = seg.first, ed = seg.second; } else ed = max(ed, seg.second); if (st != -2e9) res.push_back({st, ed}); segs = res; } 二、数据结构单链表const int N=100010; int head,e[N],ne[N],idx; //初始化 void init(){ head=-1; idx=0; } //在链表头部添加节点 void add_to_head(int x){ e[idx]=x,ne[idx]=head,head=idx++; } //在位置k添加节点x void add(int k,int x){ e[idx]=x,ne[idx]=ne[k],ne[k]=idx++; } //删除位置k的节点 void remove(int k){ ne[k]=ne[ne[k]]; } 应用 int main(){ int m; init(); cin&gt;&gt;m; while(m--){ int k,x; char op; cin&gt;&gt;op; if(op=='H'){ cin&gt;&gt;x; add_to_head(x); }else if(op=='D'){ cin&gt;&gt;k; if(!k)head=ne[head]; remove(k-1); }else { cin&gt;&gt;k&gt;&gt;x; add(k-1,x); } } for(int i=head;i!=-1;i=ne[i])cout&lt;&lt;e[i]&lt;&lt;' '; cout&lt;&lt;endl; return 0; } 双链表const int N=100010; int e[N],l[N],r[N],idx; //初始化 void init(){ l[1]=0; r[0]=1; idx=2; } //在节点a的右边插入一个数x void insert(int a,int x){ e[idx]=x; l[idx]=a,r[idx]=r[a]; l[r[a]]=idx,r[a]=idx++; } //删除节点a void remove(int a){ l[r[a]]=l[a]; r[l[a]]=r[a]; } 应用 int main(){ int m; cin&gt;&gt;m; init(); while(m--){ string op; cin&gt;&gt;op; int k,x; if(op==&quot;L&quot;){//在最左端插入数x cin&gt;&gt;x; insert(0,x); }else if(op==&quot;R&quot;){//在最右端插入数x cin&gt;&gt;x; insert(l[1],x); }else if(op==&quot;D&quot;){//删除第k个插入的数 cin&gt;&gt;k; remove(k+1); }else if(op==&quot;IL&quot;){//在第k个位置的左侧插入一个数 cin&gt;&gt;k&gt;&gt;x; insert(l[k+1],x); }else if(op==&quot;LR&quot;){//在第k个位置的右侧插入一个数 cin&gt;&gt;k&gt;&gt;x; insert(k+1,x); } } for(int i=r[0];i!=1;i=r[i])printf(&quot;%d &quot;,e[i]); cout&lt;&lt;endl; return 0; } 栈// tt表示栈顶 int stk[N], tt = 0; // 向栈顶插入一个数 stk[ ++ tt] = x; // 从栈顶弹出一个数 tt – ; // 栈顶的值 stk[tt]; // 判断栈是否为空，如果 tt &gt; 0，则表示不为空 if (tt &gt; 0) { } 应用 const int N=100010; int stk[N],tt; int main(){ int m; cin&gt;&gt;m; while(m--){ string op; int x; cin&gt;&gt;op; if(op==&quot;push&quot;){ cin&gt;&gt;x; stk[tt++]=x; }else if(op==&quot;pop&quot;){ tt--; }else if(op==&quot;query&quot;){ cout&lt;&lt;stk[tt-1]&lt;&lt;endl; }else{ if(!tt)cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; } } return 0; } 队列普通队列 // hh 表示队头，tt表示队尾 int q[N], hh = 0, tt = -1; // 向队尾插入一个数 q[ ++ tt] = x; // 从队头弹出一个数 hh ++ ; // 队头的值 q[hh]; // 判断队列是否为空，如果 hh &lt;= tt，则表示不为空 if (hh &lt;= tt) { } 应用 int const N=100010; int que[N],hh,tt=-1; int main(){ int m; cin&gt;&gt;m; while(m--){ string op; int x; cin&gt;&gt;op; if(op==&quot;push&quot;){ cin&gt;&gt;x; que[++tt]=x; }else if(op==&quot;query&quot;){ cout&lt;&lt;que[hh]&lt;&lt;endl; }else if(op==&quot;pop&quot;){ hh++; }else{ if(hh&gt;tt)cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; } } return 0; } 循环队列// hh 表示队头，tt表示队尾的后一个位置 int q[N], hh = 0, tt = 0; // 向队尾插入一个数 q[tt ++ ] = x; if (tt == N) tt = 0; // 从队头弹出一个数 hh ++ ; if (hh == N) hh = 0; // 队头的值 q[hh]; // 判断队列是否为空，如果hh != tt，则表示不为空 if (hh != tt) { } 单调栈常见模型：找出每个数左边离它最近的比它大/小的数 int tt = 0; for (int i = 1; i &lt;= n; i ++ ) { while (tt &amp;&amp; check(stk[tt], i)) tt -- ; stk[ ++ tt] = i; } 应用 找出每个数左边离它最近的比它大/小的数 stack stk; int main(){ int n; cin &gt;&gt; n; stk.push(-1); for (int i = 0; i &lt; n; i ++){ int x; cin &gt;&gt; x; while (stk.size() &amp;&amp; stk.top() &gt;= x) stk.pop(); cout &lt;&lt; stk.top() &lt;&lt; &quot; &quot;; stk.push(x); } return 0; } 单调队列常见模型：找出滑动窗口中的最大值/最小值 int hh = 0, tt = -1; for (int i = 0; i &lt; n; i ++ ) { while (hh &lt;= tt &amp;&amp; check_out(q[hh])) hh ++ ; // 判断队头是否滑出窗口 while (hh &lt;= tt &amp;&amp; check(q[tt], i)) tt -- ; q[ ++ tt] = i; } const int N = 1000010; int a[N]; int main() { int n, k; cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; a[i];//读入数据 deque&lt;int&gt; q; for(int i = 1; i &lt;= n; i++) { while(q.size() &amp;&amp; q.back() &gt; a[i]) //新进入窗口的值小于队尾元素，则队尾出队列 q.pop_back(); q.push_back(a[i]);//将新进入的元素入队 if(i - k &gt;= 1 &amp;&amp; q.front() == a[i - k])//若队头是否滑出了窗口，队头出队 q.pop_front(); if(i &gt;= k)//当窗口形成，输出队头对应的值 cout &lt;&lt; q.front() &lt;&lt;&quot; &quot;; } q.clear(); cout &lt;&lt; endl; //最大值亦然 for(int i = 1; i &lt;= n; i++) { while(q.size() &amp;&amp; q.back() &lt; a[i]) q.pop_back(); q.push_back(a[i]); if(i - k &gt;= 1 &amp;&amp; a[i - k] == q.front()) q.pop_front(); if(i &gt;= k) cout &lt;&lt; q.front() &lt;&lt; &quot; &quot;; } } KMP字符串匹配视频讲解：[最浅显易懂的 KMP 算法讲解_哔哩哔哩_bilibili]：https://www.bilibili.com/video/BV1AY4y157yL 下标从1开始的kmp算法 const int N = 100010, M = 1000010; int n, m; int ne[N]; char s[M], p[N]; int main() { cin &gt;&gt; n &gt;&gt; p + 1 &gt;&gt; m &gt;&gt; s + 1; for (int i = 2, j = 0; i &lt;= n; i ++ ) { while (j &amp;&amp; p[i] != p[j + 1]) j = ne[j]; if (p[i] == p[j + 1]) j ++ ; ne[i] = j; }//处理ne数组 for (int i = 1, j = 0; i &lt;= m; i ++ ) { while (j &amp;&amp; s[i] != p[j + 1]) j = ne[j]; if (s[i] == p[j + 1]) j ++ ; if (j == n) { printf(&quot;%d &quot;, i - n); j = ne[j]; } }//匹配算法 return 0; } // s[]是长文本，p[]是模式串，n是s的长度，m是p的长度 求模式串的Next数组： for (int i = 2, j = 0; i &lt;= m; i ++ ) { while (j &amp;&amp; p[i] != p[j + 1]) j = ne[j]; if (p[i] == p[j + 1]) j ++ ; ne[i] = j; } // 匹配 for (int i = 1, j = 0; i &lt;= n; i ++ ) { while (j &amp;&amp; s[i] != p[j + 1]) j = ne[j]; if (s[i] == p[j + 1]) j ++ ; if (j == m) { j = ne[j]; // 匹配成功后的逻辑 } } 下标从0开始的kmp算法 const int N = 1000010; int n, m; char s[N], p[N]; int ne[N]; int main() { cin &gt;&gt; m &gt;&gt; p &gt;&gt; n &gt;&gt; s; ne[0] = -1; for (int i = 1, j = -1; i &lt; m; i ++ ) { while (j &gt;= 0 &amp;&amp; p[j + 1] != p[i]) j = ne[j]; if (p[j + 1] == p[i]) j ++ ; ne[i] = j; } for (int i = 0, j = -1; i &lt; n; i ++ ) { while (j != -1 &amp;&amp; s[i] != p[j + 1]) j = ne[j]; if (s[i] == p[j + 1]) j ++ ; if (j == m - 1) { cout &lt;&lt; i - j &lt;&lt; ' '; j = ne[j]; } } return 0; } 二叉树的存储与遍历const int N = 1e6 + 10; // 二叉树的存储,l数组为左节点,r数组为右结点 int l[N], r[N]; // 存储节点的数据 char w[N]; // 节点的下标指针 int idx = 0; // 先序创建 int pre_create(int n) { cin &gt;&gt; w[n]; if (w[n] == '#') return -1; l[n] = pre_create(++idx); r[n] = pre_create(++idx); return n; } // 中序创建 int in_create(int n) { if (w[n] == '#') return -1; l[n] = in_create(++idx); cin &gt;&gt; w[n]; r[n] = in_create(++idx); return n; } // 后序创建 int back_create(int n) { if (w[n] == '#') return -1; l[n] = back_create(++idx); r[n] = back_create(++idx); cin &gt;&gt; w[n]; return n; } // 先序遍历 void pre_print(int n){ if (w[n] != '#') cout &lt;&lt; w[n] &lt;&lt; ' '; if (l[n] &gt; 0) pre_print(l[n]); if (r[n] &gt; 0) pre_print(r[n]); } // 中序遍历 void in_print(int n){ if (l[n] &gt; 0) in_print(l[n]); if (w[n] != '#') cout &lt;&lt; w[n] &lt;&lt; ' '; if (r[n] &gt; 0) in_print(r[n]); } // 后序遍历 void back_print(int n){ if (l[n] &gt; 0) back_print(l[n]); if (r[n] &gt; 0) back_print(r[n]); if (w[n] != '#') cout &lt;&lt; w[n] &lt;&lt; ' '; } // 层序遍历 void bfs(int root){ queue&lt;int&gt; que; que.push(root); while (!que.empty()) { int t = que.front(); cout &lt;&lt; w[t] &lt;&lt; ' '; que.pop(); if (l[t] &gt; 0 &amp;&amp; w[l[t]] != '#') que.push(l[t]); if (r[t] &gt; 0 &amp;&amp; w[r[t]] != '#') que.push(r[t]); } } 应用 int main(){ // 先序创建 pre_create(++idx); // 中序创建 // in_create(++idx); // 后序创建 // back_create(++idx); // 先序遍历 pre_print(1); // 中序遍历 in_print(1); // 后序遍历 back_print(1); // 层序遍历 bfs(1); // 测试数据abc##de#g##f### // 输出如下： // a b c d e g f // c b e g d f a // c g e f d b a // a b c d e f g return 0; } Trie树Trie 树是一种多叉树的结构，每个节点保存一个字符，一条路径表示一个字符串。 相关链接：https://www.acwing.com/solution/content/27771/ int son[N][26], cnt[N], idx; // 0号点既是根节点，又是空节点 // son[][]存储树中每个节点的子节点 // cnt[]存储以每个节点结尾的单词数量 // 插入一个字符串 void insert(char *str) { int p = 0; for (int i = 0; str[i]; i ++ ) { int u = str[i] - 'a'; if (!son[p][u]) son[p][u] = ++ idx; p = son[p][u]; } cnt[p] ++ ; } // 查询字符串出现的次数 int query(char *str) { int p = 0; for (int i = 0; str[i]; i ++ ) { int u = str[i] - 'a'; if (!son[p][u]) return 0; p = son[p][u]; } return cnt[p]; } const int N = 100010; int son[N][26], cnt[N], idx; char str[N]; void insert(char *str) { int p = 0; for (int i = 0; str[i]; i ++ ) { int u = str[i] - 'a'; if (!son[p][u]) son[p][u] = ++ idx; p = son[p][u]; } cnt[p] ++ ; }//插入 int query(char *str) { int p = 0; for (int i = 0; str[i]; i ++ ) { int u = str[i] - 'a'; if (!son[p][u]) return 0; p = son[p][u]; } return cnt[p]; }//查询 int main() { int n; scanf(&quot;%d&quot;, &amp;n); while (n -- ) { char op[2]; scanf(&quot;%s%s&quot;, op, str); if (*op == 'I') insert(str); else printf(&quot;%d\\n&quot;, query(str)); } return 0; } 并查集(1)朴素并查集： int p[N]; //存储每个点的祖宗节点 // 返回x的祖宗节点 int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } // 初始化，假定节点编号是1~n for (int i = 1; i &lt;= n; i ++ ) p[i] = i; // 合并a和b所在的两个集合： p[find(a)] = find(b); (2)维护size的并查集： int p[N], size[N]; //p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量 // 返回x的祖宗节点 int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } // 初始化，假定节点编号是1~n for (int i = 1; i &lt;= n; i ++ ) { p[i] = i; size[i] = 1; } // 合并a和b所在的两个集合： size[find(b)] += size[find(a)]; p[find(a)] = find(b); (3)维护到祖宗节点距离的并查集： int p[N], d[N]; //p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离 // 返回x的祖宗节点 int find(int x) { if (p[x] != x) { int u = find(p[x]); d[x] += d[p[x]]; p[x] = u; } return p[x]; } // 初始化，假定节点编号是1~n for (int i = 1; i &lt;= n; i ++ ) { p[i] = i; d[i] = 0; } // 合并a和b所在的两个集合： p[find(a)] = find(b); d[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量 应用 const int N=100010; int p[N],n,m; int find(int x){//找到祖宗节点+路径压缩 if(p[x]!=x)p[x]=find(p[x]); return p[x]; } int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)p[i]=i; while(m--){ char op[2]; int a,b; scanf(&quot;%s%d%d&quot;,op,&amp;a,&amp;b); if(op[0]=='M')p[find(a)]=find(b); else { if(find(a)==find(b))puts(&quot;Yes&quot;); else puts(&quot;No&quot;); } } return 0; } 堆// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1 // ph[k]存储第k个插入的点在堆中的位置 // hp[k]存储堆中下标是k的点是第几个插入的 int h[N], ph[N], hp[N], size; // 交换两个点，及其映射关系 void heap_swap(int a, int b) { swap(ph[hp[a]],ph[hp[b]]); swap(hp[a], hp[b]); swap(h[a], h[b]); } void down(int u) { int t = u; if (u * 2 &lt;= size &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2; if (u * 2 + 1 &lt;= size &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1; if (u != t) { heap_swap(u, t); down(t); } } void up(int u) { while (u / 2 &amp;&amp; h[u] &lt; h[u / 2]) { heap_swap(u, u / 2); u &gt;&gt;= 1; } } // O(n)建堆 for (int i = n / 2; i; i – ) down(i); 应用：堆排序 const int N=100010; int heap[N],cnt; void down(int u){ int t=u; if(u*2&lt;=cnt&amp;&amp;heap[u*2]&lt;=heap[t])t=u*2; if(u*2+1&lt;=cnt&amp;&amp;heap[u*2+1]&lt;=heap[t])t=u*2+1; if(t!=u){ swap(heap[t],heap[u]); down(t); } }//down操作 void up(int u){ while(u/2&amp;&amp;heap[u/2]&gt;heap[u]){ swap(heap[u/2],heap[u]); u&gt;&gt;=1; } }//up操作 int main(){ int n,m; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;heap[i]); cnt=n; for(int i=n/2;i;i--)down(i); while(m--){ printf(&quot;%d &quot;,heap[1]); heap[1]=heap[cnt--]; down(1); } return 0; } 一般hash(1) 拉链法 int h[N], e[N], ne[N], idx; // 向哈希表中插入一个数 void insert(int x) { int k = (x % N + N) % N; e[idx] = x; ne[idx] = h[k]; h[k] = idx ++ ; } // 在哈希表中查询某个数是否存在 bool find(int x) { int k = (x % N + N) % N; for (int i = h[k]; i != -1; i = ne[i]) if (e[i] == x) return true; return false; } (2) 开放寻址法 int h[N]; // 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置 int find(int x) { int t = (x % N + N) % N; while (h[t] != null &amp;&amp; h[t] != x) { t ++ ; if (t == N) t = 0; } return t; } 字符串哈希核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低 小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果 typedef unsigned long long ULL; ULL h[N], p[N]; // h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64 // 初始化 p[0] = 1; for (int i = 1; i &lt;= n; i ++ ) { h[i] = h[i - 1] * P + str[i]; p[i] = p[i - 1] * P; } // 计算子串 str[l ~ r] 的哈希值 ULL get(int l, int r) { return h[r] - h[l - 1] * p[r - l + 1]; } STLSTL容器.png 视频讲解：[100 STL 容器_哔哩哔哩_bilibili]：https://www.bilibili.com/video/BV1tF411G73c/ vector, 变长数组，倍增的思想 size() 返回元素个数 empty() 返回是否为空 clear() 清空 front()/back() push_back()/pop_back() begin()/end() [] 支持比较运算，按字典序 pair&lt;int, int&gt; first, 第一个元素 second, 第二个元素 支持比较运算，以first为第一关键字，以second为第二关键字（字典序） string，字符串 size()/length() 返回字符串长度 empty() clear() substr(起始下标，(子串长度)) 返回子串 c_str() 返回字符串所在字符数组的起始地址 queue, 队列 size() empty() push() 向队尾插入一个元素 front() 返回队头元素 back() 返回队尾元素 pop() 弹出队头元素 priority_queue, 优先队列，默认是大根堆 size() empty() push() 插入一个元素 top() 返回堆顶元素 pop() 弹出堆顶元素 定义成小根堆的方式：priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q; stack, 栈 size() empty() push() 向栈顶插入一个元素 top() 返回栈顶元素 pop() 弹出栈顶元素 deque, 双端队列 size() empty() clear() front()/back() push_back()/pop_back() push_front()/pop_front() begin()/end() [] set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列 size() empty() clear() begin()/end() ++, -- 返回前驱和后继，时间复杂度 O(logn) set/multiset insert() 插入一个数 find() 查找一个数 count() 返回某一个数的个数 erase() (1) 输入是一个数x，删除所有x O(k + logn) (2) 输入一个迭代器，删除这个迭代器 lower_bound()/upper_bound() lower_bound(x) 返回大于等于x的最小的数的迭代器 upper_bound(x) 返回大于x的最小的数的迭代器 map/multimap insert() 插入的数是一个pair erase() 输入的参数是pair或者迭代器 find() [] 注意multimap不支持此操作。 时间复杂度是 O(logn) lower_bound()/upper_bound() unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表 和上面类似，增删改查的时间复杂度是 O(1) 不支持 lower_bound()/upper_bound()， 迭代器的++，-- bitset, 圧位 bitset&lt;10000&gt; s; ~, &amp;, |, ^ &gt;&gt;, &lt;&lt; ==, != [] count() 返回有多少个1 any() 判断是否至少有一个1 none() 判断是否全为0 set() 把所有位置成1 set(k, v) 将第k位变成v reset() 把所有位变成0 flip() 等价于~ flip(k) 把第k位取反 三、搜索与图论树与图的存储树是一种特殊的图，与图的存储方式相同。 对于无向图中的边ab，存储两条有向边a-&gt;b, b-&gt;a。 因此我们可以只考虑有向图的存储。 邻接矩阵邻接矩阵：g[a][b] 存储边a-&gt;b的距离 邻接表// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点 int h[N], e[N], ne[N], idx; // 添加一条边a-&gt;b void add(int a, int b) { //存下b的值，b下一个指向a的下个一节点，a的下一个节点指向b e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ; } // 初始化 idx = 0; memset(h, -1, sizeof h); 树与图的遍历时间复杂度O(n+m)，n表示点数，m表示边数 深度优先遍历 int dfs(int u) { st[u] = true; // st[u] 表示点u已经被遍历过 for (int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j]) dfs(j); } } 应用：数字全排列#include using namespace std; int res[10],b[10],n; void dfs(int k){ if(k==n){//k==n则输出n个数字 for(int i=0;i&lt;n;i++)printf(&quot;%d &quot;,res[i]); cout&lt;&lt;endl; } for(int i=1;i&lt;=n;i++){ if(!b[i]){//判断是否被用过 res[k]=i;//当前k位存入位置 b[i]=1;//表示被占用 dfs(k+1); b[i]=0;//恢复现场 } } } int main(){ cin&gt;&gt;n; dfs(0);//从0开始枚举 return 0; } 应用：树的重心#include #include #include #include using namespace std; const int N = 100010, M = N * 2;//无向图n条边时，最多2n个idx，因为每条边在邻接表中会出现两次 int n;//n个结点,n-1条边 int h[N], e[M], ne[M], idx;//n个链表头，e每一个结点的值，ne每一个结点的next指针 int ans = N;//最小的最大值 bool st[N];//状态数组，防止子节点搜索父节点 void add(int a, int b)//a-&gt;b {//e记录当前点的值(地址-&gt;值),ne下一点的地址(地址-&gt;地址)，h记录指向的第一个点的地址(值-&gt;地址) e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ; }//头插法 int dfs(int u)//通过h数组找到子结点的向 { st[u] = true;//st标记当前点被搜过 int size = 0, sum = 0; //size删掉元素后各个子连通块的最大值 //sum当前子树大小，遍历叶节点时，返回1 for (int i = h[u]; i != -1; i = ne[i])//遍历单链表，链表末端初始化为-1 { int j=e[i]; if(st[j])continue;//此处防逆向dfs int s = dfs(j);//s各个子连通块的大小 size = max(size, s);//size删掉元素后各个连通块的最大值 sum += s;//各个连通块大小之和 } size = max(size, n - sum - 1);//判断最大子连通块与父连通块的最大值 ans = min(ans, size);//全局变量ans存最小的最大值 //注意：本题若求最大的最大值，则只需去除任意叶节点即可，即n-1 return sum + 1;//各个子连通块，当前结点之和 } int main() { scanf(&quot;%d&quot;, &amp;n); memset(h, -1, sizeof h);//n个头节点全部指向-1 for (int i = 0; i &lt; n - 1; i ++ )//n个结点，n-1条边 { int a, b; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); add(a, b), add(b, a);//不知道子节点还是父节点，所以需要建两条边可以双向查找 } dfs(1);//结点编号为1~n且可能只有一个结点，则参数只能为1 printf(&quot;%d\\n&quot;, ans); return 0; } 应用：n-皇后问题n皇后搜索图示 using namespace std; const int N = 11; char q[N][N];//存储棋盘 bool dg[N * 2], udg[N * 2], cor[N];//点对应的两个斜线以及列上是否有皇后 int n; void dfs(int r) { if(r == n)//放满了棋盘，输出棋盘 { for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) cout &lt;&lt; q[i][j]; cout &lt;&lt; endl; } cout &lt;&lt; endl; return; } for(int i = 0; i &lt; n; i++)//第 r 行，第 i 列 是否放皇后 { if(!cor[i] &amp;&amp; !dg[i + r] &amp;&amp; !udg[n - i + r])//不冲突，放皇后 { q[r][i] = 'Q'; cor[i] = dg[i + r] = udg[n - i + r] = 1;//对应的 列， 斜线 状态改变 dfs(r + 1);//处理下一行 cor[i] = dg[i + r] = udg[n - i + r] = 0;//恢复现场 q[r][i] = '.'; } } } int main() { cin &gt;&gt; n; for (int i = 0; i &lt; n; i ++ ) for (int j = 0; j &lt; n; j ++ ) q[i][j] = '.'; dfs(0); return 0; } 宽度优先遍历queue q; st[1] = true; // 表示1号点已经被遍历过 q.push(1); while (q.size()) { int t = q.front(); q.pop(); for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j]) { st[j] = true; // 表示点j已经被遍历过 q.push(j); } } } 应用：走迷宫typedef pair&lt;int,int&gt; PII;//声明pair时候必须要在代码前面写上using namespace std; const int N=110; int g[N][N],f[N][N],n,m; int bfs(int x,int y){ queue&lt;PII&gt; que; que.push({x,y}); int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0}; while(!que.empty()){ PII t=que.front(); que.pop(); g[t.first][t.second]=1; for(int i=0;i&lt;4;i++){ int a=t.first+dx[i],b=t.second+dy[i]; if(a&gt;=0&amp;&amp;b&gt;=0&amp;&amp;a&lt;n&amp;&amp;b&lt;m&amp;&amp;!g[a][b]){ g[a][b]=1; f[a][b]=f[t.first][t.second]+1; que.push({a,b}); } } } return f[n-1][m-1]; } int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) scanf(&quot;%d&quot;,&amp;g[i][j]); cout&lt;&lt;bfs(0,0)&lt;&lt;endl; return 0; } 应用：八数码using namespace std; int bfs(string state) { queue&lt;string&gt; q; unordered_map&lt;string, int&gt; d; int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1}; string ed = &quot;12345678x&quot;; q.push(state); d[state] = 0; while (q.size()) { auto t = q.front(); q.pop(); if (t == ed)//等于结果就输出步数 return d[t]; int distance = d[t]; int k = t.find('x');//寻找x int x = k / 3, y = k % 3;//计算下标 for (int i = 0; i &lt; 4; i ++ ) { int a = x + dx[i], b = y + dy[i]; if (a &gt;= 0 &amp;&amp; a &lt; 3 &amp;&amp; b &gt;= 0 &amp;&amp; b &lt; 3) { swap(t[a * 3 + b], t[k]);//交换 if (!d.count(t)) {//不存在就入队 d[t] = distance + 1; q.push(t); } swap(t[a * 3 + b], t[k]);//还原 } } } return -1; } int main() { char s[2]; string state; for (int i = 0; i &lt; 9; i ++ ) { cin &gt;&gt; s; state += *s; } cout&lt;&lt;bfs(state)&lt;&lt;endl; return 0; } 拓扑排序啥是拓扑排序？ 一个有向图，如果图中有入度为 0 的点，就把这个点删掉，同时也删掉这个点所连的边。 一直进行上面出处理，如果所有点都能被删掉，则这个图可以进行拓扑排序。 纯净版bool topsort() { int hh = 0, tt = -1; // d[i] 存储点i的入度 for (int i = 1; i &lt;= n; i ++ ) if (!d[i]) q[ ++ tt] = i; while (hh &lt;= tt) { int t = q[hh ++ ]; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (-- d[j] == 0) q[ ++ tt] = j; } } // 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。 return tt == n - 1; } 解说版using namespace std; const int N = 100010; int e[N], ne[N], idx; //邻接表存储图 int h[N];//邻接表的每个头链表 int q[N], hh = 0, tt = -1; //队列保存入度为0的点，也就是能够输出的点 int n, m; //保存图的点数和边数 int d[N];//保存各个点的入度 void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx++; } void topsort() { for (int i = 1; i &lt;= n; i++) {//遍历一遍顶点的入度。 if (!d[i])//如果入度为0，则可以入队列 q[++tt] = i; } while (tt &gt;= hh) { //循环处理队列中点的 int a = q[hh++]; for (int i = h[a]; i != -1; i = ne[i]) { int b = e[i]; //a 有一条边指向b d[b]--;//删除边后，b的入度减1 if (!d[b])//如果b的入度减为 0,则 b 可以输出，入队列 q[++tt] = b; } } if (tt == n - 1) {//如果队列中的点的个数与图中点的个数相同，则可以进行拓扑排序 for (int i = 0; i &lt; n; i++)//队列中保存了所有入度为0的点，依次输出 printf(&quot;%d &quot;, q[i]); } else//如果队列中的点的个数与图中点的个数不相同，则可以进行拓扑排序 cout &lt;&lt; -1; } int main() { cin &gt;&gt; n &gt;&gt; m; //保存点的个数和边的个数 memset(h, -1, sizeof h); //初始化领接矩阵 while (m--) { //依次读入边 int a, b; cin &gt;&gt; a &gt;&gt; b; d[b]++;//顶点b的入度+1 add(a, b); //添加到邻接矩阵 } topsort();//进行拓扑排序 return 0; } Dijkstra算法朴素版时间复杂是O(n2+m) ，n表示点数，m表示边数 int g[N][N]; // 存储每条边 int dist[N]; // 存储1号点到每个点的最短距离 bool st[N]; // 存储每个点的最短路是否已经确定 // 求1号点到n号点的最短路，如果不存在则返回-1 int dijkstra() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; for (int i = 0; i &lt; n - 1; i ++ ) { int t = -1; // 在还未确定最短路的点中，寻找距离最小的点 for (int j = 1; j &lt;= n; j ++ ) if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j])) t = j; // 用t更新其他点的距离 for (int j = 1; j &lt;= n; j ++ ) dist[j] = min(dist[j], dist[t] + g[t][j]); st[t] = true; } if (dist[n] == 0x3f3f3f3f) return -1; return dist[n]; } 应用const int N = 510, M = 100010; int h[N], e[M], ne[M], w[M], idx;//邻接表存储图 int state[N];//state 记录是否找到了源点到该节点的最短距离 int dist[N];//dist 数组保存源点到其余各个节点的距离 int n, m;//图的节点个数和边数 void add(int a, int b, int c)//插入边 { e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++; } void Dijkstra() { memset(dist, 0x3f, sizeof(dist));//dist 数组的各个元素为无穷大 dist[1] = 0;//源点到源点的距离为置为 0 for (int i = 0; i &lt; n; i++) { int t = -1; for (int j = 1; j &lt;= n; j++)//遍历 dist 数组，找到没有确定最短路径的节点中距离源点最近的点t { if (!state[j] &amp;&amp; (t == -1 || dist[j] &lt; dist[t])) t = j; } state[t] = 1;//state[i] 置为 1。 for (int j = h[t]; j != -1; j = ne[j])//遍历 t 所有可以到达的节点 i { int i = e[j]; dist[i] = min(dist[i], dist[t] + w[j]);//更新 dist[j] } } } int main() { memset(h, -1, sizeof(h));//邻接表初始化 cin &gt;&gt; n &gt;&gt; m; while (m--)//读入 m 条边 { int a, b, w; cin &gt;&gt; a &gt;&gt; b &gt;&gt; w; add(a, b, w); } Dijkstra(); if (dist[n] != 0x3f3f3f3f)//如果dist[n]被更新了，则存在路径 cout &lt;&lt; dist[n]; else cout &lt;&lt; &quot;-1&quot;; } 堆优化版时间复杂度O(mlogn) ，n表示点数，m表示边数 typedef pair&lt;int, int&gt; PII; int n; // 点的数量 int h[N], w[N], e[N], ne[N], idx; // 邻接表存储所有边 int dist[N]; // 存储所有点到1号点的距离 bool st[N]; // 存储每个点的最短距离是否已确定 // 求1号点到n号点的最短距离，如果不存在，则返回-1 int dijkstra(){ memset(dist,0x3f,sizeof dist);//距离初始化为无穷大 dist[1]=0;//1-&gt;1的节点距离为0 priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt; heap;//小根堆 heap.push({0,1});//插入距离和节点编号 while(heap.size()){ auto t=heap.top();//取距离源点最近的点 heap.pop(); int ver=t.second,distance=t.first;//ver：节点编号，distance源点距离ver if(st[ver])continue;//如果距离已经确定，则跳过该点 st[ver]=true; for(int i=h[ver];i!=-1;i=ne[i])//更新ver所指向的节点距离 { int j=e[i]; if(dist[j]&gt;dist[ver]+w[i]){ dist[j]=dist[ver]+w[i]; heap.push({dist[j],j});//距离变小，则入堆 } } } if(dist[n]==0x3f3f3f3f)return -1; return dist[n]; } 关于Dijkstra的相关博客链接：[AcWing 849. Dijkstra求最短路 I：图解 详细代码（图解） - AcWing：https://www.acwing.com/solution/content/38318/ [AcWing 850. Dijkstra求最短路 II：详解+代码注释 - AcWing]：https://www.acwing.com/solution/content/38323/ Bellman-Ford算法时间复杂度O(nm)，n表示点数，m表示边数 注意在模板题中需要对下面的模板稍作修改，加上备份数组，详情见模板题。 Bellman-ford算法动态规划图示.png 上图为Bellman-ford草稿图 int n, m; // n表示点数，m表示边数 int dist[N],backup[N]; // dist[x]存储1到x的最短路距离 struct Edge // 边，a表示出点，b表示入点，w表示边的权重 { int a, b, w; }edges[M]; // 求1到n的最短路距离，如果无法从1走到n，则返回-1。 int bellman_ford() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; // 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。 for (int i = 0; i &lt; n; i ++ ) { memcpy(back,dist,sizeof dist); for (int j = 0; j &lt; m; j ++ ) { int a = edges[j].a, b = edges[j].b, w = edges[j].w; if (dist[b] &gt; backup[a] + w) dist[b] = backup[a] + w; } } if (dist[n] &gt; 0x3f3f3f3f / 2) return -1; return dist[n]; } 应用int n,m,k; const int N=512,M=10012; struct Edge{ int a,b,w; }e[M]; int dist[N]; int back[N]; void bellman_ford(){ memset(dist,0x3f,sizeof dist); dist[1]=0; for(int i=0;i&lt;k;i++){ memcpy(back,dist,sizeof dist); for(int j=0;j&lt;m;j++){ int a=e[j].a,b=e[j].b,c=e[j].w; dist[b]=min(dist[b],back[a]+c); } } } int main(){ scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k); for(int i=0;i&lt;m;i++){ int a,b,w; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;w); e[i]={a,b,w}; } bellman_ford(); if(dist[n]&gt;0x3f3f3f3f/2)cout&lt;&lt;&quot;impossible&quot;&lt;&lt;endl; else cout&lt;&lt;dist[n]&lt;&lt;endl; return 0; } 问题：为什么把每一条边用不等式刷k次就是k条件下的值？ 你可以想象这个图是1-&gt;2-&gt;3-&gt;4….-&gt;n这样一条直线。比如说第一次迭代，为什么只有与原点相连的点才能被更新dist呢？因为原点的dist是0，其他点的dist是+∞，满足dist[2] &gt; dist[1]+c，而+∞并不&gt;+∞+c，所以第一次迭代结束就是不超过一条边走到i节点最短路的距离，依次类推，第二次迭代，只有3会被更新，因为只有1、2的dist不是+∞，第二次迭代就是不超过2条边走到i节点的最短距离。这就是为什么k次迭代最多是走了k条边，同时也是为什么一共只用迭代n-1次，因为n个点的有向图，如果能走到，原点到n号点的最短距离最多是n-1次，也就是1-&gt;2-&gt;…-&gt;n直线这种。 SPFA算法（队列优化的Bellman-Ford算法）时间复杂度平均情况下O(m)，最坏情况下O(nm)，n表示点数，m表示边数 模板 int n; // 总点数 int h[N], w[N], e[N], ne[N], idx; // 邻接表存储所有边 int dist[N]; // 存储每个点到1号点的最短距离 bool st[N]; // 存储每个点是否在队列中 // 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1 int spfa() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; queue&lt;int&gt; q; q.push(1); st[1] = true; while (q.size()) { auto t = q.front(); q.pop(); st[t] = false; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] &gt; dist[t] + w[i]) { dist[j] = dist[t] + w[i]; if (!st[j]) // 如果队列中已存在j，则不需要将j重复插入 { q.push(j); st[j] = true; } } } } if (dist[n] == 0x3f3f3f3f) return -1; return dist[n]; } 应用const int N = 1e6 + 10; int n, m;//节点数量和边数 int h[N], w[N], e[N], ne[N], idx;//邻接矩阵存储图 int dist[N];//存储距离 bool st[N];//存储状态 void add(int a, int b, int c) { e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ; } int spfa() { memset(dist, 0x3f, sizeof dist);//距离初始化为无穷大 dist[1] = 0;//初始化1到1的距离为0 queue&lt;int&gt; que;//队列 que.push(1);//1入队 while (que.size())//判断是否存在 { int t=que.front(); que.pop();//获取第一个并出队 st[t]=false;//第一个取消占用 for(int i=h[t];i!=-1;i=ne[i]){//遍历第一个可以到达的结点 int j=e[i]; if(dist[j]&gt;dist[t]+w[i]){//1号点可到达的节点距离是否大于上次的距离距离加上当前的距离 dist[j]=dist[t]+w[i];//赋值给可到达的节点 if(!st[j]){//如果可到达的节点未被占用 que.push(j);//则入队 st[j]=true;//占用 } } } } return dist[n]; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); memset(h, -1, sizeof h); while (m -- ) { int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); add(a, b, c); } int t=spfa(); if(t==0x3f3f3f3f)cout&lt;&lt;&quot;impossible&quot;&lt;&lt;endl; else printf(&quot;%d\\n&quot;,t); return 0; } 应用：spfa判断图中是否存在负权int n; // 总点数 int h[N], w[N], e[N], ne[N], idx; // 邻接表存储所有边 int dist[N], cnt[N]; // dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数 bool st[N]; // 存储每个点是否在队列中 // 如果存在负环，则返回true，否则返回false。 bool spfa() { // 不需要初始化dist数组 // 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。 queue&lt;int&gt; q; for (int i = 1; i &lt;= n; i ++ ) { q.push(i); st[i] = true; } while (q.size()) { auto t = q.front(); q.pop(); st[t] = false; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] &gt; dist[t] + w[i]) { dist[j] = dist[t] + w[i]; cnt[j] = cnt[t] + 1; if (cnt[j] &gt;= n) return true; // 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环 if (!st[j]) { q.push(j); st[j] = true; } } } } return false; } floyd算法时间复杂度O(n3)，n表示点数 视频讲解：https://www.bilibili.com/video/BV14R4y1x7GB/ 模板 初始化： for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= n; j ++ ) if (i == j) d[i][j] = 0; else d[i][j] = INF; // 算法结束后，d[a][b]表示a到b的最短距离 void floyd() { for (int k = 1; k &lt;= n; k ++ )//k为中转节点 for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= n; j ++ ) d[i][j] = min(d[i][j], d[i][k] + d[k][j]); } 应用 using namespace std; const int N = 210, INF = 1e9; int n, m, Q; int d[N][N]; void floyd() { for (int k = 1; k &lt;= n; k ++ )//k为中转节点 for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= n; j ++ ) d[i][j] = min(d[i][j], d[i][k] + d[k][j]); } int main() { scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;Q); for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= n; j ++ ) if (i == j) d[i][j] = 0; else d[i][j] = INF; while (m -- ) { int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); d[a][b] = min(d[a][b], c); } floyd(); while (Q -- ) { int a, b; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); int t = d[a][b]; if (t &gt; INF / 2) puts(&quot;impossible&quot;); else printf(&quot;%d\\n&quot;, t); } return 0; } 最短路算法总结最短路 单源最短路：给定V中的一个顶点，称为源。要计算从源到其他所有各顶点的最短路径长度。这里的长度就是指路上各边权之和。这个问题通常称为单源最短路径 问题。 所有边权都是正数： 朴素Dijkstra算法 O(n^2) 适合稠密图，贪心思想 堆优化版的Dijkstra算法 O(mlogn)适合稀疏图，贪心思想 ​ 存在负权边： ​ Bellman-ford O(nm)，动态规划思想 ​ SPFA 一般：O(m)，最坏O(nm) 多源汇最短路：任意两点最短路径被称为多源最短路径，即给定任意两个点，一个出发点，一个到达点，求这两个点的之间的最短路径，就是任意两点最短路径问题 Floyd算法 O(n^3) prim算法时间复杂度是O(n2+m)，n表示点数，m表示边数 int n; // n表示点数 int g[N][N]; // 邻接矩阵，存储所有边 int dist[N]; // 存储其他点到当前最小生成树的距离 bool st[N]; // 存储每个点是否已经在生成树中 // 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和 int prim() { memset(dist, 0x3f, sizeof dist); int res = 0; for (int i = 0; i &lt; n; i ++ ) { int t = -1; for (int j = 1; j &lt;= n; j ++ ) if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j])) t = j; if (i &amp;&amp; dist[t] == INF) return INF; if (i) res += dist[t]; st[t] = true; for (int j = 1; j &lt;= n; j ++ ) dist[j] = min(dist[j], g[t][j]); } return res; } 应用 const int N = 510, INF = 0x3f3f3f3f; int n, m; int g[N][N]; int dist[N]; bool st[N]; int prim() { memset(dist, 0x3f, sizeof dist); int res = 0; for (int i = 0; i &lt; n; i ++ ) { int t = -1; for (int j = 1; j &lt;= n; j ++ ) if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j])) t = j; if (i &amp;&amp; dist[t] == INF) return INF; if (i) res += dist[t]; st[t] = true; for (int j = 1; j &lt;= n; j ++ ) dist[j] = min(dist[j], g[t][j]); } return res; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); memset(g, 0x3f, sizeof g); while (m -- ) { int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); g[a][b] = g[b][a] = min(g[a][b], c); } int t = prim(); if (t == INF) puts(&quot;impossible&quot;); else printf(&quot;%d\\n&quot;, t); return 0; } Kruskal算法时间复杂度O(mlogm)，n表示点数，m表示边数 int n, m; // n是点数，m是边数 int p[N]; // 并查集的父节点数组 struct Edge // 存储边 { int a, b, w; bool operator&lt; (const Edge &amp;W)const { return w &lt; W.w; } }edges[M]; int find(int x) // 并查集核心操作 { if (p[x] != x) p[x] = find(p[x]); return p[x]; } int kruskal() { sort(edges, edges + m); for (int i = 1; i &lt;= n; i ++ ) p[i] = i; // 初始化并查集 int res = 0, cnt = 0; for (int i = 0; i &lt; m; i ++ ) { int a = edges[i].a, b = edges[i].b, w = edges[i].w; a = find(a), b = find(b); if (a != b) // 如果两个连通块不连通，则将这两个连通块合并 { p[a] = b; res += w; cnt ++ ; } } if (cnt &lt; n - 1) return INF; return res; } 应用 #include #include #include using namespace std; const int N = 100010, M = 200010, INF = 0x3f3f3f3f; int n, m; int p[N]; struct Edge { int a, b, w; bool operator&lt; (const Edge &amp;W)const { return w &lt; W.w; } }edges[M]; int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } int kruskal() { sort(edges, edges + m); for (int i = 1; i &lt;= n; i ++ ) p[i] = i; // 初始化并查集 int res = 0, cnt = 0; for (int i = 0; i &lt; m; i ++ ) { int a = edges[i].a, b = edges[i].b, w = edges[i].w; a = find(a), b = find(b); if (a != b) { p[a] = b; res += w; cnt ++ ; } } if (cnt &lt; n - 1) return INF; return res; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 0; i &lt; m; i ++ ) { int a, b, w; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;w); edges[i] = {a, b, w}; } int t = kruskal(); if (t == INF) puts(&quot;impossible&quot;); else printf(&quot;%d\\n&quot;, t); return 0; } 染色法判别二分图什么叫二分图 有两顶点集且图中每条边的的两个顶点分别位于两个顶点集中，每个顶点集中没有边直接相连接！ 说人话的定义：图中点通过移动能分成左右两部分，左侧的点只和右侧的点相连，右侧的点只和左侧的点相连。 下图就是个二分图： 时间复杂度是O(n+m)，n表示点数，m表示边数 int n; // n表示点数 int h[N], e[M], ne[M], idx; // 邻接表存储图 int color[N]; // 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色 // 参数：u表示当前节点，c表示当前点的颜色 bool dfs(int u, int c) { color[u] = c; for (int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if (color[j] == -1) { if (!dfs(j, !c)) return false; } else if (color[j] == c) return false; } return true; } bool check() { memset(color, -1, sizeof color); bool flag = true; for (int i = 1; i &lt;= n; i ++ ) if (color[i] == -1) if (!dfs(i, 0)) { flag = false; break; } return flag; } 应用using namespace std; const int N = 100010, M = 200010;// 由于是无向图, 顶点数最大是N，那么边数M最大是顶点数的2倍 int n, m; int h[N], e[M], ne[M], idx; int color[N]; void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ; } bool dfs(int u, int c) { color[u] = c; for (int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if (!color[j]) { if (!dfs(j, 3 - c)) return false; } else if (color[j] == c) return false; } return true; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); memset(h, -1, sizeof h); while (m -- ) { int a, b; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); add(a, b), add(b, a);// 无向图，a-&gt;b, b-&gt;a } bool flag = true; for (int i = 1; i &lt;= n; i ++ ) if (!color[i]) { if (!dfs(i, 1)) { flag = false; break; } } if (flag) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); return 0; } 匈牙利算法要了解匈牙利算法必须先理解下面的概念： 匹配：在图论中，一个「匹配」是一个边的集合，其中任意两条边都没有公共顶点。 最大匹配：一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配。 下面是一些补充概念： 完美匹配：如果一个图的某个匹配中，所有的顶点都是匹配点，那么它就是一个完美匹配。 交替路：从一个未匹配点出发，依次经过非匹配边、匹配边、非匹配边…形成的路径叫交替路。 增广路：从一个未匹配点出发，走交替路，如果途径另一个未匹配点（出发的点不算），则这条交替 路称为增广路（agumenting path）。 时间复杂度O(nm)，n表示点数，m表示边数 //遍历自己喜欢的女孩int n1, n2; // n1表示第一个集合中的点数，n2表示第二个集合中的点数 int h[N], e[M], ne[M], idx; // 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边 int match[N]; // 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个 bool st[N]; // 表示第二个集合中的每个点是否已经被遍历过 void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ; } bool find(int x) { //遍历自己喜欢的女孩 for (int i = h[x]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j])//如果在这一轮模拟匹配中,这个女孩尚未被预定 { st[j] = true;//那x就预定这个女孩了 //如果女孩j没有男朋友，或者她原来的男朋友能够预定其它喜欢的女孩。配对成功 if (match[j] == 0 || find(match[j])) { match[j] = x; return true; } } } //自己中意的全部都被预定了。配对失败。 return false; } // 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点 int res = 0; for (int i = 1; i &lt;= n1; i ++ ) { memset(st, false, sizeof st); if (find(i)) res ++ ; } 应用：二分图的最大匹配 匈牙利算法图示化 相关题解：[AcWing 861. 二分图的最大匹配—-图解 - AcWing]：https://www.acwing.com/solution/content/179030/ using namespace std; const int N = 510, M = 100010; int n1, n2, m; int h[N], e[M], ne[M], idx; int match[N]; bool st[N]; void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ; } bool find(int x) { // 和各个点尝试能否匹配 for (int i = h[x]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j])//打标记 { st[j] = true; // 当前尝试点没有被匹配或者和当前尝试点匹配的那个点可以换另一个匹配 if (match[j] == 0 || find(match[j])) { // 和当前尝试点匹配在一起 match[j] = x; return true; } } } return false; } int main() { scanf(&quot;%d%d%d&quot;, &amp;n1, &amp;n2, &amp;m); memset(h, -1, sizeof h); // 保存图，因为只从一遍找另一边，所以该无向图只需要存储一个方向 while (m -- ) { int a, b; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); add(a, b); } int res = 0; //为各个点找匹配 for (int i = 1; i &lt;= n1; i ++ ) { memset(st, false, sizeof st); //找到匹配 if (find(i)) res ++ ; } printf(&quot;%d\\n&quot;, res); return 0; } 四、数学知识算法的数学知识定理证明可以在这里查阅：[数学部分简介 - OI Wiki (oi-wiki.org)]：https://oi-wiki.org/math/ 试除法判定质数bool is_prime(int x) { if (x &lt; 2) return false; for (int i = 2; i &lt;= x / i; i ++ ) if (x % i == 0) return false; return true; } 试除法分解质因数void divide(int x) { for (int i = 2; i &lt;= x / i; i ++ ) if (x % i == 0)//i 一定是质数 { int s = 0; while (x % i == 0) x /= i, s ++ ; cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; s &lt;&lt; endl; } if (x &gt; 1) cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; 1 &lt;&lt; endl; cout &lt;&lt; endl; } 埃氏筛法求质数int primes[N], cnt; // primes[]存储所有素数 bool st[N]; // st[x]存储x是否被筛掉 void get_primes(int n) { for (int i = 2; i &lt;= n; i ++ ) { if (st[i]) continue; primes[cnt ++ ] = i; for (int j = i + i; j &lt;= n; j += i) st[j] = true; } } 线性筛法求质数算法动画讲解：https://www.bilibili.com/video/BV1LR4y1Z7pm int primes[N], cnt; // primes[]存储所有素数 bool st[N]; // st[x]存储x是否被筛掉 void get_primes(int n) { for (int i = 2; i &lt;= n; i ++ ) { if (!st[i]) primes[cnt ++ ] = i; for (int j = 0; primes[j] &lt;= n / i; j ++ ) { st[primes[j] * i] = true; if (i % primes[j] == 0) break; } } } 试除法求所有约数vector get_divisors(int x) { vector&lt;int&gt; res; for (int i = 1; i &lt;= x / i; i ++ ) if (x % i == 0) { res.push_back(i); if (i != x / i) res.push_back(x / i); } sort(res.begin(), res.end()); return res; } 约数个数约数个数定理和约数和定理公式推导：https://www.bilibili.com/video/BV13R4y1o777 约数个数定理推导：https://www.bilibili.com/video/BV1NY41187GM 约数个数.png using namespace std; typedef long long LL; const int N = 110, mod = 1e9 + 7; int main() { int n; cin &gt;&gt; n; unordered_map&lt;int, int&gt; primes; while (n -- ) { int x; cin &gt;&gt; x; for (int i = 2; i &lt;= x / i; i ++ ) while (x % i == 0) { x /= i; primes[i] ++ ; } if (x &gt; 1) primes[x] ++ ; } LL res = 1; for (auto p : primes) res = res * (p.second + 1) % mod; cout &lt;&lt; res &lt;&lt; endl; return 0; } 约数之和约数个数定理和约数和定理公式推导：https://www.bilibili.com/video/BV13R4y1o777 约数之和.png using namespace std; typedef long long LL; const int N = 110, mod = 1e9 + 7; int main() { int n; cin &gt;&gt; n; unordered_map&lt;int, int&gt; primes; while (n -- ) { int x; cin &gt;&gt; x; for (int i = 2; i &lt;= x / i; i ++ ) while (x % i == 0) { x /= i; primes[i] ++ ; } if (x &gt; 1) primes[x] ++ ; } LL res = 1; for (auto p : primes) { LL a = p.first, b = p.second; LL t = 1; while (b -- ) t = (t * a + 1) % mod;//遍历b次后得到t=p^b+p^(b-1)+...+p+1 res = res * t % mod; } cout &lt;&lt; res &lt;&lt; endl; return 0; } 代码第26行解释： 约数之和小公式推导.png 欧几里得算法(求最大公约数)int gcd(int a, int b) { return b ? gcd(b, a % b) : a; } 最小公倍数int lcm(int a, int b) { return abs(a * b) / gcd(a, b); } 求欧拉函数前置知识 互质：互质是公约数只有1的两个整数，叫做互质整数。 欧拉函数定义 1∼N−1 中与N互质的数的个数被称为欧拉函数，记为ϕ(N)。 若在算数基本定理中，N=pa11pa22…pamm，则： ϕ(N)=N⋅p1−1p1⋅p2−1p2⋅…⋅pm−1pm 欧拉函数推导 首先我们要知道1,2,3…N−1,N与N互质的个数是1∼N数列去除N的质因子的倍数。 例如N=10,即1,2,3,4,5,6,7,8,9,10去除N的质因子的倍数, 则1,\\bcancel2,3,\\bcancel4,\\bcancel5,\\bcancel6,7,\\bcancel8,9,\\bcancel10. 显然，1,3,7,9与10互质。 由上方结论使用容斥原理进行数学推导如下： 代码模板int phi(int x) { int res = x; for (int i = 2; i &lt;= x / i; i ++ ) if (x % i == 0) { res = res / i * (i - 1); while (x % i == 0) x /= i; } if (x &gt; 1) res = res / x * (x - 1); return res; } 线性筛法求欧拉函数int primes[N], cnt; // primes[]存储所有素数 int euler[N]; // 存储每个数的欧拉函数 bool st[N]; // st[x]存储x是否被筛掉 void get_eulers(int n) // 线性筛法求1~n的欧拉函数 { euler[1] = 1; for (int i = 2; i &lt;= n; i ++ ) { if (!st[i]) { primes[cnt ++ ] = i; euler[i] = i - 1; } for (int j = 0; primes[j] &lt;= n / i; j ++ ) { int t = primes[j] * i; st[t] = true; if (i % primes[j] == 0) { euler[t] = euler[i] * primes[j]; break; } euler[t] = euler[i] * (primes[j] - 1); } } } 快速幂快速幂公式证明：[快速幂 - OI Wiki (oi-wiki.org)]：https://oi-wiki.org/math/binary-exponentiation/ // 求 m^k mod p，时间复杂度 O(logk)。 // m为底数，k为幂 int qmi(int m, int k, int p) { int res = 1 % p, t = m; while (k) { if (k&amp;1) res = res * t % p; t = t * t % p; k &gt;&gt;= 1; } return res; } 扩展欧几里得算法扩展欧几里得算法讲解：https://www.bilibili.com/video/BV1KU4y1a7E2/ 优秀题解：https://www.acwing.com/solution/content/1393 优秀博客：https://blog.csdn.net/mango114514/article/details/121048335 x的第一个正解就是(x%k+k)%k 其中，k=b/gcd(a,b) // 求x, y，使得ax + by = gcd(a, b) int exgcd(int a, int b, int &amp;x, int &amp;y) { if (!b) { x = 1, y = 0; return a; } int d = exgcd(b, a % b, y, x); y -= (a/b) * x; return d; } 中国剩余定理中国剩余定理讲解：https://www.bilibili.com/video/BV1AN4y1N7Su/ 中国剩余定理.png LL exgcd(LL a,LL b,LL &amp;x,LL &amp;y){ if(b==0){ x=1,y=0; return a; } LL d=exgcd(b,a%b,y,x); y -= (a/b) * x; return d; } LL CRT(LL m[],LL r[]){ LL m=1,ans=0; for(int i=1;i&lt;=n;i++)M*=m[i]; for(int i=1;i&lt;=n;i++){ LL c=M/m[i],x,y; exgcd(c,m[i],x,y); ans=(ans+r[i]*c*x%M)%M; } return (ans%M+M)%M; } 扩展中国剩余定理扩展中国剩余定理讲解：https://www.bilibili.com/video/BV1Ut4y1F7HG/ 扩展中国剩余定理.png LL exgcd(LL a,LL b,LL &amp;x,LL &amp;y){ if(b==0){ x=1,y=0; return a; } LL d=exgcd(b,a%b,y,x); y -= (a/b) * x; return d; } LL EXCRT(LL m[],LL r[]){ LL m1,m2,r1,r2,p,q; m1=m[1],r1=r[1]; for(int i=2;i&lt;=n;i++){ m2=m[i],r2=r[i]; LL d = exgcd(m1,m2,p,q); if((r2-r1)%d){ return -1; } p=p*(r2-r1)/d;//特解 p=(p%(m2/d)+m2/d)%(m2/d); r1=m1*p+r1; m1=m1*m2/d; } return (r1%m1+m1)%m1; } 高斯消元法高斯消元 O(n3) 求解例如下面方程组 ⎧⎩⎨⎪⎪⎪⎪⎪⎪a11x1+a12x2+…+a1nxn=b1a21x1+a22x2+…+a2nxn=b2⋮⋮⋮⋮an1x1+an2x2+…+annxn=bn 高斯消元讲解：https://www.bilibili.com/video/BV1Kd4y127vZ/ 模板// a[N][N]是增广矩阵 int gauss() { int c, r; for (c = 0, r = 0; c &lt; n; c ++ ) { int t = r; for (int i = r; i &lt; n; i ++ ) // 找到绝对值最大的行 if (fabs(a[i][c]) &gt; fabs(a[t][c])) t = i; if (fabs(a[t][c]) &lt; eps) continue; for (int i = c; i &lt;= n; i ++ ) swap(a[t][i], a[r][i]); // 将绝对值最大的行换到最顶端 for (int i = n; i &gt;= c; i -- ) a[r][i] /= a[r][c]; // 将当前行的首位变成1 for (int i = r + 1; i &lt; n; i ++ ) // 用当前行将下面所有的列消成0 if (fabs(a[i][c]) &gt; eps) for (int j = n; j &gt;= c; j -- ) a[i][j] -= a[r][j] * a[i][c]; r ++ ; } if (r &lt; n) { for (int i = r; i &lt; n; i ++ ) if (fabs(a[i][n]) &gt; eps) return 2; // 无解 return 1; // 有无穷多组解 } for (int i = n - 1; i &gt;= 0; i -- ) for (int j = i + 1; j &lt; n; j ++ ) a[i][n] -= a[i][j] * a[j][n]; return 0; // 有唯一解 } 应用using namespace std; const int N = 110; const double eps = 1e-6; int n; double a[N][N]; int gauss() { int c, r;// c 代表 列 col ， r 代表 行 row for (c = 0, r = 0; c &lt; n; c ++ ) { int t = r;// 先找到当前这一列，绝对值最大的一个数字所在的行号 for (int i = r; i &lt; n; i ++ ) if (fabs(a[i][c]) &gt; fabs(a[t][c])) t = i; if (fabs(a[t][c]) &lt; eps) continue;// 如果当前这一列的最大数都是 0 ，那么所有数都是 0，就没必要去算了，因为它的约束方程，可能在上面几行 for (int i = c; i &lt; n + 1; i ++ ) swap(a[t][i], a[r][i]);//// 把当前这一行，换到最上面（不是第一行，是第 r 行）去 for (int i = n; i &gt;= c; i -- ) a[r][i] /= a[r][c];// 把当前这一行的第一个数，变成 1， 方程两边同时除以 第一个数，必须要到着算，不然第一个数直接变1，系数就被篡改，后面的数字没法算 for (int i = r + 1; i &lt; n; i ++ )// 把当前列下面的所有数，全部消成 0 if (fabs(a[i][c]) &gt; eps)// 如果非0 再操作，已经是 0就没必要操作了 for (int j = n; j &gt;= c; j -- )// 从后往前，当前行的每个数字，都减去对应列 * 行首非0的数字，这样就能保证第一个数字是 a[i][0] -= 1*a[i][0]; a[i][j] -= a[r][j] * a[i][c]; r ++ ;// 这一行的工作做完，换下一行 } if (r &lt; n)// 说明剩下方程的个数是小于 n 的，说明不是唯一解，判断是无解还是无穷多解 {// 因为已经是阶梯型，所以 r ~ n-1 的值应该都为 0 for (int i = r; i &lt; n; i ++ )// if (fabs(a[i][n]) &gt; eps)// a[i][n] 代表 b_i ,即 左边=0，右边=b_i,0 != b_i, 所以无解。 return 2; return 1;// 否则， 0 = 0，就是r ~ n-1的方程都是多余方程 } // 唯一解 ↓，从下往上回代，得到方程的解 for (int i = n - 1; i &gt;= 0; i -- ) for (int j = i + 1; j &lt; n; j ++ ) a[i][n] -= a[j][n] * a[i][j];//因为只要得到解，所以只用对 b_i 进行操作，中间的值，可以不用操作，因为不用输出 return 0; } int main() { cin &gt;&gt; n; for (int i = 0; i &lt; n; i ++ ) for (int j = 0; j &lt; n + 1; j ++ ) cin &gt;&gt; a[i][j]; int t = gauss(); if (t == 0) { for (int i = 0; i &lt; n; i ++ ) printf(&quot;%.2lf\\n&quot;, a[i][n]); } else if (t == 1) puts(&quot;Infinite group solutions&quot;); else puts(&quot;No solution&quot;); return 0; } 求组合数递推法求组合数排列组合详细讲解：https://www.bilibili.com/video/BV1e7411J7SC/ 杨辉三角.png 杨辉三角组合数.png // c[a][b] 表示从a个苹果中选b个的方案数 int c[N][N]; for (int i = 0; i &lt; N; i ++ ) for (int j = 0; j &lt;= i; j ++ ) if (!j) c[i][j] = 1; else c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod; //本质上杨辉三角 通过预处理逆元的方式求组合数模板// 首先预处理出所有阶乘取模的余数fact[N]，以及所有阶乘取模的逆元infact[N] // 如果取模的数是质数，可以用费马小定理求逆元 int qmi(int a, int k, int p) // 快速幂模板 { int res = 1; while (k) { if (k &amp; 1) res = (LL)res * a % p; a = (LL)a * a % p; k &gt;&gt;= 1; } return res; } // 预处理阶乘的余数和阶乘逆元的余数 fact[0] = infact[0] = 1; for (int i = 1; i &lt; N; i ++ ) { fact[i] = (LL)fact[i - 1] * i % mod; infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod; } 应用using namespace std; typedef long long LL; const int N = 100010,mod=1e9+7;//1e9+7是质数所以与[1,1e9+7)中的数互质 int fact[N],infact[N]; int qmi(int a,int k,int p){ int res=1; while(k){ if(k&amp;1)res=(LL)res*a%p; a=(LL)a*a%p; k&gt;&gt;=1; } return res; } int main() { fact[0]=infact[0]=1; for (int i = 1; i &lt;= N; i ++ ){ fact[i]=(LL)fact[i-1]*i%mod; infact[i]=(LL)infact[i-1]*qmi(i,mod-2,mod)%mod; } int n; scanf(&quot;%d&quot;,&amp;n); while (n -- ){ int a,b; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); printf(&quot;%d\\n&quot;,(LL)fact[a]*infact[b]%mod*infact[a-b]%mod); } return 0; } Lucas定理求组合数Lucas定理证明：https://blog.csdn.net/Qiuker_jl/article/details/109528164 模板// 若p是质数，则对于任意整数 1 &lt;= m &lt;= n，有： // C(n, m) = C(n % p, m % p) * C(n / p, m / p) (mod p) int qmi(int a, int k, int p) // 快速幂模板 { int res = 1 % p; while (k) { if (k &amp; 1) res = (LL)res * a % p; a = (LL)a * a % p; k &gt;&gt;= 1; } return res; } int C(int a, int b, int p) // 通过定理求组合数C(a, b) { if (a &lt; b) return 0; LL x = 1, y = 1; // x是分子，y是分母 for (int i = a, j = 1; j &lt;= b; i --, j ++ ) { x = (LL)x * i % p; y = (LL) y * j % p; } return x * (LL)qmi(y, p - 2, p) % p; } int lucas(LL a, LL b, int p) { if (a &lt; p &amp;&amp; b &lt; p) return C(a, b, p); return (LL)C(a % p, b % p, p) * lucas(a / p, b / p, p) % p; } 应用using namespace std; typedef long long LL; int qmi(int a,int k,int p) { int res = 1; while(k) { if(k&amp;1)res = (LL)res*a%p; a = (LL)a*a%p; k&gt;&gt;=1; } return res; } int C(int a,int b,int p)//自变量类型int { if(b&gt;a)return 0;//漏了边界条件 int res = 1; // a!/(b!(a-b)!) = (a-b+1)*...*a / b! 分子有b项 for(int i=1,j=a;i&lt;=b;i++,j--)//i&lt;=b而不是&lt; { res = (LL)res*j%p; res = (LL)res*qmi(i,p-2,p)%p; } return res; } //对公式敲 int lucas(LL a,LL b,int p) { if(a&lt;p &amp;&amp; b&lt;p)return C(a,b,p);//lucas递归终点是C_{bk}^{ak} return (LL)C(a%p,b%p,p)*lucas(a/p,b/p,p)%p;//a%p后肯定是&lt;p的,所以可以用C(),但a/p后不一定&lt;p 所以用lucas继续递归 } int main() { int n; cin &gt;&gt; n; while(n--) { LL a,b; int p; cin &gt;&gt; a &gt;&gt; b &gt;&gt; p; cout &lt;&lt; lucas(a,b,p) &lt;&lt; endl; } return 0; } 分解质因数法求组合数模板当我们需要求出组合数的真实值，而非对某个数的余数时，分解质因数的方式比较好用： 1. 筛法求出范围内的所有质数 2. 通过 C(a, b) = a! / b! / (a - b)! 这个公式求出每个质因子的次数。 n! 中p的次数是 n / p + n / p^2 + n / p^3 + ... 3. 用高精度乘法将所有质因子相乘 int primes[N], cnt; // 存储所有质数 int sum[N]; // 存储每个质数的次数 bool st[N]; // 存储每个数是否已被筛掉 void get_primes(int n) // 线性筛法求素数 { for (int i = 2; i &lt;= n; i ++ ) { if (!st[i]) primes[cnt ++ ] = i; for (int j = 0; primes[j] &lt;= n / i; j ++ ) { st[primes[j] * i] = true; if (i % primes[j] == 0) break; } } } int get(int n, int p) // 求n！中的次数 { int res = 0; while (n) { res += n / p; n /= p; } return res; } vector mul(vector a, int b) // 高精度乘低精度模板 { vector&lt;int&gt; c; int t = 0; for (int i = 0; i &lt; a.size(); i ++ ) { t += a[i] * b; c.push_back(t % 10); t /= 10; } while (t) { c.push_back(t % 10); t /= 10; } return c; } get_primes(a); // 预处理范围内的所有质数 for (int i = 0; i &lt; cnt; i ++ ) // 求每个质因数的次数 { int p = primes[i]; sum[i] = get(a, p) - get(b, p) - get(a - b, p); } vector res; res.push_back(1); for (int i = 0; i &lt; cnt; i ++ ) // 用高精度乘法将所有质因子相乘 for (int j = 0; j &lt; sum[i]; j ++ ) res = mul(res, primes[i]); 应用using namespace std; const int N = 5010; int primes[N],cnt=0; // v[i] 记录数字 i 为素数还是合数，v[i]=true时 i 为合数，否则 i 为素数 bool v[N]; // sum[i]=c 表示质数 i 的个数为 c int sum[N]; // 线性筛法 void get_primes(int n) { for(int i=2;i&lt;=n;++i) { // i为质数，则存在primes中 if(!v[i])primes[cnt++]=i; // 给当前数i乘上一个质因子pj for(int j=0;primes[j]&lt;=n/i;++j) { v[primes[j]*i]=true; if(i%primes[j]==0)break; } } } // 计算 n 里面含有质数 p 的个数，这里的计算是不重不漏的。 // p^k的倍数会被计算k次：第一次算p的倍数时，被加一次；第二次算p^2的倍数时，被加一次；第三次算p^3的倍数时，被加一次…第k次算p^k的倍数时，被加一次。总共被加了k次，是不重不漏的。 int get(int n,int p) { int res=0; while(n) { res+=n/p; n/=p; } return res; } // A * b：把 b 看成一个整体，然后与 A 中每一位相乘，A中的数字采用小端存储，即低位数字存储在数组的前面，高位数字存储在数组的后面 vector mul(const vector&amp; A,const int b) { if(b==0)return {0}; vector&lt;int&gt; res; // t 表示乘法进位，这里的进位不限于0 1，可以为任意数字 for(int i=0,t=0,n=A.size();i&lt;n||t&gt;0;++i) { // 获得当前位的乘积和 if(i&lt;n)t+=A[i]*b; // 添加个位数字 res.push_back(t%10); // 保留进位 t/=10; } // 如 1234 * 0 = 0000，需要删除前导0 while(res.size()&gt;1&amp;&amp;res.back()==0)res.pop_back(); return res; } int main() { int a,b;cin&gt;&gt;a&gt;&gt;b; // 将 a 分解质因数 get_primes(a); for(int i=0;i&lt;cnt;++i) { // 当前的质数为 p int p=primes[i]; // 用分子里面 p 的个数减去分母里面 p 的个数。这里的计算组合数的公式为a!/(b!*(a-b)!)，因此用 a 里面 p 的个数减去 b 里面 p 的个数和 (a-b) 里面 p 的个数。 sum[i]=get(a,p)-get(b,p)-get(a-b,p); } // 使用高精度乘法把所有质因子乘到一块去就好了 vector&lt;int&gt; res={1}; for(int i=0;i&lt;cnt;++i) // res*p^k，这里是k个p相乘，不是k*p，所以需要使用一个循环 for(int j=0;j&lt;sum[i];++j) res=mul(res,primes[i]); // 倒序打印 res 即可，由于采用小端存储，所以高位在后，从后往前打印即可 for(int i=res.size()-1;i&gt;=0;i--)printf(&quot;%d&quot;,res[i]); return 0; } 容斥原理应用经典例题：[890. 能被整除的数 - AcWing题库]：https://www.acwing.com/problem/content/892/ AC代码： using namespace std; typedef long long LL; const int N = 20; int p[N], n, m; int main() { cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; m; i++) cin &gt;&gt; p[i]; int res = 0; //枚举从1 到 1111…(m个1)的每一个集合状态, (至少选中一个集合) for(int i = 1; i &lt; 1 &lt;&lt; m; i++) { int t = 1; //选中集合对应质数的乘积 int s = 0; //选中的集合数量 //枚举当前状态的每一位 for(int j = 0; j &lt; m; j++){ //选中一个集合 if(i &gt;&gt; j &amp; 1){ //乘积大于n, 则n/t = 0, 跳出这轮循环 if((LL)t * p[j] &gt; n){ t = -1; break; } s++; //有一个1，集合数量+1 t *= p[j]; } } if(t == -1) continue; if(s &amp; 1) res += n / t; //选中奇数个集合, 则系数应该是1, n/t为当前这种状态的集合数量 else res -= n / t; //反之则为 -1 } cout &lt;&lt; res &lt;&lt; endl; return 0; } 详细题解：[AcWing 890. 能被整除的数 - AcWing]：https://www.acwing.com/solution/content/29702/ 博弈论NIM游戏定理1：必胜态的后继状态至少存在一个必败态 定理2：必败态的后继状态均为必胜态 NIM游戏科普：[尼姆游戏（学霸就是这样欺负人的）_哔哩哔哩_bilibili]：https://www.bilibili.com/video/BV1ek4y1q7JD/ [再看nim游戏_哔哩哔哩_bilibili]：https://www.bilibili.com/video/BV1nt4y1C7Sk/ 经典例题：[P2197 【模板】nim 游戏 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)]：https://www.luogu.com.cn/problem/P2197 AC代码： using namespace std; int T; int main() { cin &gt;&gt; T; while (T--) { int n; scanf(&quot;%d&quot;, &amp;n); int ans = 0; for (int i = 0; i &lt; n; i++) { int k; scanf(&quot;%d&quot;, &amp;k); ans ^= k; } if (ans) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); } return 0; } 结论： 若初态为必胜态(a1⊕a2⊕…⊕an≠0 ).则先手必胜 若初态为必败态(a1⊕a2⊕…⊕an=0 ).则先手必败 视频讲解：[581 尼姆（Nim）游戏【博弈论】_哔哩哔哩_bilibili]：https://www.bilibili.com/video/BV1ns4y1D7dg/ 台阶型NIM游戏 经典例题：[892. 台阶-Nim游戏 - AcWing题库]：https://www.acwing.com/problem/content/894/ AC代码： using namespace std; const int N = 100010; int main() { int n; scanf(&quot;%d&quot;, &amp;n); int res = 0; for (int i = 1; i &lt;= n; i ++ ) { int x; scanf(&quot;%d&quot;, &amp;x); if (i &amp; 1) res ^= x; } if (res) puts(&quot;Yes&quot;); else puts(“No”); return 0; } 结论：若奇数台阶上的a1⊕a3⊕a5⊕…≠0，则先手必胜，反之先手必败。 视频讲解：[582 台阶型 Nim游戏【博弈论】_哔哩哔哩_bilibili]：https://www.bilibili.com/video/BV18M411M7TC/ 集合型NIM游戏 经典例题：[893. 集合-Nim游戏 - AcWing题库]：https://www.acwing.com/problem/content/895/ AC代码： using namespace std; const int N=110,M=10010; int n,m; int f[M],s[N];//s存储的是可供选择的集合,f存储的是所有可能出现过的情况的sg值 int sg(int x) { if(f[x]!=-1) return f[x]; //因为取石子数目的集合是已经确定了的,所以每个数的sg值也都是确定的,如果存储过了,直接返回即可 unordered_set&lt;int&gt; S; //set代表的是有序集合(注:因为在函数内部定义,所以下一次递归中的S不与本次相同) for(int i=0;i&lt;m;i++) { int sum=s[i]; if(x&gt;=sum) S.insert(sg(x-sum)); //先延伸到终点的sg值后,再从后往前排查出所有数的sg值 } for(int i=0;;i++) //循环完之后可以进行选出最小的没有出现的自然数的操作 if(!S.count(i)) return f[x]=i; } int main() { cin&gt;&gt;m; for(int i=0;i&lt;m;i++) cin&gt;&gt;s[i]; cin&gt;&gt;n; memset(f,-1,sizeof(f));//初始化f均为-1,方便在sg函数中查看x是否被记录过 int res=0; for(int i=0;i&lt;n;i++) { int x; cin&gt;&gt;x; res^=sg(x); //观察异或值的变化,基本原理与Nim游戏相同 } if(res) printf(&quot;Yes&quot;); else printf(&quot;No&quot;); return 0; } 思路：转换成有向图游戏 视频讲解：[583 有向图游戏 SG函数【博弈论】_哔哩哔哩_bilibili]：https://www.bilibili.com/video/BV1eT411B7A8/ 五、动态规划动态规划三大特征：最优子结构、无后效性、重复子问题 闫式dp分析法.jpg 背包问题01背包每件物品只能装一次 完全背包每件物品可以装无限次 多重背包每件物品只能装有限次（多次） 分组背包每组只能选择一件物品装入（01背包升级） 相关链接：https://zhuanlan.zhihu.com/p/166439661 01背包问题 01背包每件物品只能装一次 视频讲解：[408 背包DP【模板】01背包_哔哩哔哩_bilibili]：https://www.bilibili.com/video/BV1kp4y1e794/ 01背包DP分析.png 01背包.png using namespace std; const int N=1010; int n,m; int v[N],w[N];//v代表体积，w代表价值 int f[N][N]; int main(){ cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++)cin&gt;&gt;v[i]&gt;&gt;w[i]; for(int i=1;i&lt;=n;i++)//i代表这n件物品 { for(int j=1;j&lt;=m;j++){//j代表背包容量 if(v[i]&gt;j)//如果v[i]的容量大于当前的背包容量则不装进行下一个 f[i][j]=f[i-1][j]; else f[i][j]=max(f[i-1][j],f[i-1][j-v[i]]+w[i]);//如果v[i]的容量小于当前背包容量则可以选择装与不装得到最大值 } } cout&lt;&lt;f[n][m]&lt;&lt;endl;//输出最后的一个一定是最大的 return 0; } 01背包，使用滚动数组，倒序遍历 using namespace std; const int N=1010; int n,m; int v[N],w[N];//v代表体积，w代表价值 int dp[N]; int main(){ cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++)//i代表这n件物品 { cin&gt;&gt;v[i]&gt;&gt;w[i];//在线算法 for(int j=m;j&gt;=v[i];j--){//j代表背包容量，滚动数组必须倒序遍历 dp[j]=max(dp[j],dp[j-v[i]]+w[i]);//滚动数组 } } cout&lt;&lt;dp[m]&lt;&lt;endl;//输出最后的一个一定是最大的 return 0; } 状态转移方程：dp[j]=max(dp[j],dp[j-v[i]]+w[i]); 完全背包问题完全背包每件物品可以装无限次 视频讲解：[409 背包DP 完全背包【动态规划】_哔哩哔哩_bilibili]：https://www.bilibili.com/video/BV15v411y7Qz/ using namespace std; int v[N],w[N]; int dp[N]; int main(){ int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++){//遍历物品 cin&gt;&gt;v[i]&gt;&gt;w[i];//在线算法 for(int j=v[i];j&lt;=m;j++){//正序遍历背包容量 dp[j]=max(dp[j],dp[j-v[i]]+w[i]);//滚动数组 } } cout&lt;&lt;dp[m]&lt;&lt;endl;//输出答案 return 0; } 完全背包问题和01背包优化版的区别在于第二重循环的v[i]和m做交换 状态转移方程：dp[j]=max(dp[j],dp[j-v[i]]+w[i]); 多重背包问题1多重背包每件物品只能装有限次（多次） using namespace std; int n,m; int v[N],w[N],s[N]; int dp[N][N]; int main(){ cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++)cin&gt;&gt;v[i]&gt;&gt;w[i]&gt;&gt;s[i]; for(int i=1;i&lt;=n;i++)//物品 for(int j=0;j&lt;=m;j++)//背包容量 for(int k=0;k&lt;=s[i]&amp;&amp;k*v[i]&lt;=j;k++) dp[i][j]=max(dp[i][j],dp[i-1][j-v[i]*k]+w[i]*k); cout&lt;&lt;dp[n][m]&lt;&lt;endl; return 0; } 状态转移方程：dp[i][j]=max(dp[i][j],dp[i-1][j-v[i]*k]+w[i]*k);k为第i个物品的个数 多重背包问题2(二进制优化)思路：转换成2进制，再用01背包求解 视频讲解：[410 背包DP 多重背包 二进制优化【动态规划】_哔哩哔哩_bilibili]：https://www.bilibili.com/video/BV1MA41177cg/ using namespace std; const int N = 12010, M = 2010; int n, m; int v[N], w[N]; int f[M]; int main() { cin &gt;&gt; n &gt;&gt; m; int cnt = 0; for (int i = 1; i &lt;= n; i ++ ) { int a, b, s; cin &gt;&gt; a &gt;&gt; b &gt;&gt; s; int k = 1; while (k &lt;= s) { cnt ++ ; v[cnt] = a * k; w[cnt] = b * k; s -= k; k *= 2; } if (s &gt; 0) { cnt ++ ; v[cnt] = a * s; w[cnt] = b * s; } }//二进制优化操作 n = cnt; for (int i = 1; i &lt;= n; i ++ ) for (int j = m; j &gt;= v[i]; j -- ) f[j] = max(f[j], f[j - v[i]] + w[i]); cout &lt;&lt; f[m] &lt;&lt; endl; return 0; } 分组背包问题分组背包每组只能选择一件物品装入 视频讲解：[416 背包DP 分组背包【动态规划】_哔哩哔哩_bilibili]：https://www.bilibili.com/video/BV16a411w77X/ using namespace std; const int N=110; int f[N]; int v[N][N],w[N][N],s[N]; int n,m,k; int main(){ cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++){ cin&gt;&gt;s[i]; for(int j=0;j&lt;s[i];j++){ cin&gt;&gt;v[i][j]&gt;&gt;w[i][j]; } } for(int i=0;i&lt;n;i++){ for(int j=m;j&gt;=0;j--){ for(int k=0;k&lt;s[i];k++){ //for(int k=s[i];k&gt;=1;k--)也可以 if(j&gt;=v[i][k]) f[j]=max(f[j],f[j-v[i][k]]+w[i][k]); } } } cout&lt;&lt;f[m]&lt;&lt;endl; } 状态转移方程：f[j]=max(f[j],f[j-v[i][k]]+w[i][k]); 线性DP 数字三角形 视频讲解：[402 线性DP 数字三角形【动态规划】_哔哩哔哩_bilibili]：https://www.bilibili.com/video/BV1Rk4y1173p/ 数字三角形DP分析.png using namespace std; const int N=510,INF=1e9; int n; int a[N][N]; int f[N][N]; int main(){ scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=i;j++){ scanf(&quot;%d&quot;,&amp;a[i][j]); } } for(int i=0;i&lt;=n;i++){ for(int j=0;j&lt;=i+1;j++){ f[i][j]=-INF; } } f[1][1]=a[1][1]; for(int i=2;i&lt;=n;i++) for(int j=1;j&lt;=i;j++) f[i][j]=max(f[i-1][j-1]+a[i][j],f[i-1][j]+a[i][j]);//状态转移方程 int res=-INF; for(int i=1;i&lt;=n;i++)res=max(res,f[n][i]); printf(&quot;%d&quot;,res); return 0; } 状态转移方程：f[i][j]=max(f[i-1][j-1]+a[i][j],f[i-1][j]+a[i][j]); 最长上升子序列1视频讲解：[403 线性DP 最长上升子序列【动态规划】_哔哩哔哩_bilibili]：https://www.bilibili.com/video/BV1KK4y1e7t7/ using namespace std; const int N = 1010; int n; int a[N],f[N]; int main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i ++ )scanf(&quot;%d&quot;,&amp;a[i]); for (int i = 1; i &lt;= n; i ++ ){ f[i]=1;//只有a[i]一个数 for (int j = 1; j &lt;= i; j ++ ) if(a[j]&lt;a[i]) f[i]=max(f[i],f[j]+1); } int res=0; for (int i = 1; i &lt;= n; i ++ )res=max(res,f[i]); printf(&quot;%d\\n&quot;,res); return 0; } 状态转移方程：if(a[j]&lt;a[i])f[i]=max(f[i],f[j]+1); 最长上升子序列2(二分优化)视频讲解：[404 线性DP 最长上升子序列 二分优化_哔哩哔哩_bilibili]：https://www.bilibili.com/video/BV1Kp4y1e77H/ using namespace std; const int N = 100010; int n; int a[N]; int q[N]; int main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i ++ ) scanf(&quot;%d&quot;, &amp;a[i]); int len = 0; for (int i = 0; i &lt; n; i ++ ) { int l = 0, r = len; while (l &lt; r) { int mid = l + r + 1 &gt;&gt; 1; if (q[mid] &lt; a[i]) l = mid; else r = mid - 1; } len = max(len, r + 1); q[r + 1] = a[i];//替换或添加 } printf(&quot;%d\\n&quot;, len); return 0; } 最长公共子序列视频讲解：[405 线性DP 最长公共子序列【动态规划】_哔哩哔哩_bilibili]：https://www.bilibili.com/video/BV1EK411K7Eb/ using namespace std; const int N=1010; int n,m; char a[N],b[N]; int f[N][N]; int main() { cin&gt;&gt;n&gt;&gt;m&gt;&gt;a+1&gt;&gt;b+1; for (int i = 1; i &lt;= n; i ++ ){ for (int j = 1; j &lt;= m; j ++ ){ f[i][j]=max(f[i-1][j],f[i][j-1]); if(a[i]==b[j])f[i][j]=max(f[i][j],f[i-1][j-1]+1); } } cout&lt;&lt;f[n][m]&lt;&lt;endl; return 0; } 状态转移方程： f[i][j]=max(f[i-1][j],f[i][j-1]); if(a[i]==b[j])f[i][j]=max(f[i][j],f[i-1][j-1]+1); 最短编辑距离给定两个字符串 A和 B，现在要将 A 经过若干操作变为 B，可进行的操作有： 删除–将字符串 A中的某个字符删除。 插入–在字符串 A 的某个位置插入某个字符。 替换–将字符串 A中的某个字符替换为另一个字符。 现在请你求出，将 A变为 B 至少需要进行多少次操作。 视频讲解：[407 线性DP 编辑距离【动态规划】_哔哩哔哩_bilibili]：https://www.bilibili.com/video/BV1gk4y1177j/ 闫氏DP分析法【最短编辑距离】.png using namespace std; const int N = 1010; int n,m; char a[N],b[N]; int f[N][N]; int main() { scanf(&quot;%d%s&quot;, &amp;n, a+1); scanf(&quot;%d%s&quot;, &amp;m, b+1); for (int i = 0; i &lt;= m; i ++ )f[0][i]=i; for (int i = 0; i &lt;= n; i ++ )f[i][0]=i;//初始化字符串的编辑操作 for (int i = 1; i &lt;= n; i ++ ){ for (int j = 1; j &lt;= m; j ++ ){ f[i][j]=min(f[i-1][j]+1,f[i][j-1]+1); if(a[i]==b[j])f[i][j]=min(f[i][j],f[i-1][j-1]); else f[i][j]=min(f[i][j],f[i-1][j-1]+1);//状态转移方程 } } printf(&quot;%d\\n&quot;,f[n][m]); return 0; } 状态转移方程: f[i][j]=min(f[i-1][j]+1,f[i][j-1]+1); if(a[i]==b[j])f[i][j]=min(f[i][j],f[i-1][j-1]); else f[i][j]=min(f[i][j],f[i-1][j-1]+1);//状态转移方程 区间DP石子合并每堆石子有一定的质量，可以用一个整数来描述，现在要将这 N堆石子合并成为一堆。 每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同。 视频讲解：[428 区间DP【模板】石子合并_哔哩哔哩_bilibili]：https://www.bilibili.com/video/BV1gz4y1y7Rv/ 闫氏DP分析法 using namespace std; const int N = 310; int n; int s[N]; int f[N][N];//状态表示：集合f[l][r]为[l,r]区间；属性：所堆成的最小值 int main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i ++ )scanf(&quot;%d&quot;,&amp;s[i]); for (int i = 1; i &lt;= n; i ++ )s[i]+=s[i-1];//前缀和用来求一段区间的和 for (int len = 2; len &lt;= n; len ++ )//区间长度为len//枚举长度 for (int i = 1; i+len-1 &lt;= n; i ++ ){//意思就是i在区间[1,n-len+1]中去//枚举区间 int l=i,r=i+len-1;//区间在[i,i+len-1]中间长度为len//设置l和r的区间 f[l][r]=1e9;//初始化最大值 for (int k = l; k &lt; r; k ++ )//枚举分界点//不取r f[l][r]=min(f[l][r],f[l][k]+f[k+1][r]+s[r]-s[l-1]);//找到最小值状态转移方程为f[l][k]+f[k+1][r]+s[r]-s[l-1]; } printf(&quot;%d\\n&quot;,f[1][n]);//输出区间[1,n]的最小值 return 0; } 状态转移方程找到最小值状态转移方程为f[l][r]=min(f[l][r],f[l][k]+f[k+1][r]+s[r]-s[l-1]) 计数类DP整数划分一个正整数 n 可以表示成若干个正整数之和，我们将这样的一种表示称为正整数 n 的一种划分。 现在给定一个正整数 n，请你求出 n共有多少种不同的划分方法。 完全背包写法 //完全背包的写法 using namespace std; const int M=1e9+7; int f[1010],n; int main() { cin&gt;&gt;n; f[0]=1; for (int i = 1; i &lt;= n; i ++ ) for (int j = i; j &lt;= n; j ++ ){ f[j]=(f[j-i]+f[j])%M; } cout&lt;&lt;f[n]&lt;&lt;endl; return 0; } 状态转移方程：f[j]=(f[j-i]+f[j]) 数位统计DP计数问题题目链接：[338. 计数问题 - AcWing题库]：https://www.acwing.com/problem/content/340/ 计数问题分类讨论.png using namespace std; //因为我们举的分类中，有需要求一串数字中某个区间的数字，例如abcdefg有一个分类需要求出efg+1 int get(vector num,int l,int r){ int res=0; for(int i=l;i&gt;=r;i--)res=res*10+num[i];//这里从小到大枚举的是因为下面count的时候读入数据是从最低为读到最高位，那么此时在num里，最高位存的就是数字的最低位，那么假如我们要求efg，那就是从2算到0 return res; } int power10(int i)//这里有power10是因为有一个分类需要求得十次方得值 { int res=1; while(i--)res*=10; return res; } int count(int n,int x){ if(!n)return 0;//n=0则返回0 vector&lt;int&gt; num;//num用来存储数中的每一位数字 while(n){ num.push_back(n%10); n/=10; } n=num.size();//得出它的长度 int res=0; for (int i = n-1-!x; i &gt;=0; i -- ) //这里需要注意，我们的长度需要减一，是因为num是从0开始存储，而长度是元素的个数，因此需要减1才能读到正确的数值，而!x出现的原因是因为我们不能让前导零出现，如果此时需要我们列举的是0得出现的次数，那么我们自然不能让他们出现第一位，而是从第二位开始枚举 { if(i&lt;n-1)//其实这里可以不同if判断，因为for循环里面实际上就已经达成了if得判断，但为了方便理解还是加上if来理解，这里i要小于n-1的原因是因为我们不能越界只有7位数就最高从七位数开始读起 { res+=get(num,n-1,i+1)*power10(i);//这里就是第一个分类，000~abc-1，那么此时情况个数就会是abc*103,这里的3取决于后面的efg的长度，假如他是efgh，那么就是4 //这里的n-1,i+1,自己将数组列出然后根据分类标准就可以得出为什么l是n-1,r=i+1 if(!x)res-=power10(i);//假如此时我们要列举的是0出现的次数，因为不能出现前导零，这样是不合法也不符合我们的分类情况，例如abcdefg我们列举d，那么他就得从001~abc-1，这样就不会直接到efg，而是会到0efg，因为前面不是前导零，自然就可以列举这个时候0出现的次数，所以要减掉1个power10 } if(num[i]==x)res+=get(num,i-1,0)+1; else if(num[i]&gt;x)res+=power10(i); } return res;//返回res，即出现次数 } int main() { int a,b; while(cin&gt;&gt;a&gt;&gt;b,a||b){ if(a&gt;b)swap(a,b);//a大于b则交换a，b使得变成合法参数 for(int i=0;i&lt;10;i++) cout&lt;&lt;count(b,i)-count(a-1,i)&lt;&lt;' ';//使用前缀和思想解决[a,b]的i出现的次数 cout&lt;&lt;endl; } return 0; } 状态压缩DP蒙德里安的梦想题目链接：[U204941 蒙德里安的梦想 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)]：https://www.luogu.com.cn/problem/U204941 视频讲解：[431 状态压缩DP 蒙德里安的梦想【动态规划】_哔哩哔哩_bilibili]：https://www.bilibili.com/video/BV1cv411b7EG/ using namespace std; const int N = 12,M=1&lt;&lt;N; int n,m; long long f[N][M]; bool st[M]; int main() { int n,m; while(cin&gt;&gt;n&gt;&gt;m,n||m){ memset(f, 0, sizeof f); //预处理：判断合并列的状态i是否合法 //如果合并列的某行是1表示横放，是0表示竖放 //如果合并列不存在连续的奇数个0，即为合法状态 for (int i = 0; i &lt; 1&lt;&lt;n; i ++ ){ st[i]=true; int cnt=0;//记录合并列中连续0的个数 for (int j = 0; j &lt; n; j ++ ){ if(i&gt;&gt;j&amp;1){//如果是1 if(cnt&amp;1){//如果连续0的个数是奇数 st[i]=false;//记录i不合法 break; } }else cnt++;//如果是0，记录0的个数 } if(cnt&amp;1)st[i]=false;//处理高位0的个数 } //状态计算 f[0][0]=1;//第0列不横放是一种合法的方案 for (int i = 1; i &lt;= m; i ++ )//阶段：枚举列 for (int j = 0; j &lt; 1&lt;&lt;n; j ++ )//状态：枚举i列的状态 for (int k = 0; k &lt; 1&lt;&lt;n; k ++ )//状态：枚举i-1列的状态 //两列状态兼容：不出现重叠的1，不出现连续奇数个0 if((j&amp;k)==0&amp;&amp;st[j|k]) f[i][j]+=f[i-1][k]; cout&lt;&lt;f[m][0]&lt;&lt;endl;//第m列不横放，既答案 } return 0; } 状态转移方程： if((j&amp;k)==0&amp;&amp;st[j|k]) f[i][j]+=f[i-1][k]; 最短Hamilton路径题目链接：[U122241 最短Hamilton路径 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)]：https://www.luogu.com.cn/problem/U122241 using namespace std; const int N = 20,M = 1 &lt;&lt; N; int n; int w[N][N]; int f[M][N];//第一维表示是否访问到该点的压缩状态，第二维是走到点j //f[i][j]表示状态为i并且到j的最短路径 int main(){ cin&gt;&gt;n; for (int i = 0; i &lt; n; i ++ ) for (int j = 0; j &lt; n; j ++ )//读入i到j的距离 cin&gt;&gt;w[i][j]; memset(f, 0x3f, sizeof f); f[1][0]=0; for (int i = 0; i &lt; 1 &lt;&lt; n; i ++ )//枚举压缩的状态 for (int j = 0; j &lt; n; j ++ )//枚举到0~j的点 if(i &gt;&gt; j &amp; 1)//该状态存在j点 for (int k = 0; k &lt; n; k ++ )//枚举从j倒数第二个点k if(i &gt;&gt; k &amp; 1)//倒数点k存在 f[i][j]=min(f[i][j],f[i-(1&lt;&lt;j)][k]+w[k][j]);//状态转移方程，在f[i][j]和状态去掉j的点f[i-(i&lt;&lt;j)][k]+w[k][j]取最小值 cout&lt;&lt;f[(1&lt;&lt;n)-1][n-1]&lt;&lt;endl;//输出状态全满也就是所有点都经过且到最后一个点的最短距离 return 0; } 状态转移方程： f[i][j]=min(f[i][j],f[i-(1&lt;&lt;j)][k]+w[k][j]); 树形DP没有上司的舞会题目：[P1352 没有上司的舞会 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)]：https://www.luogu.com.cn/problem/P1352 视频讲解：[417 树形DP 没有上司的舞会【动态规划】_哔哩哔哩_bilibili]：https://www.bilibili.com/video/BV1eK411N7Ly/ using namespace std; const int N = 6010; int n; int w[N];//每个节点的高兴度 int h[N], e[N], ne[N], idx;//邻接表存储树 bool st[N];//判断是否有父节点 int f[N][2]; void add(int a, int b) // 添加一条边a-&gt;b { e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ; } void dfs(int u){ f[u][0]=0; f[u][1]=w[u];//初始化f[u][1]，当第二维是0则不选该点即高兴度为0，同理f[u][1]=w[u]; for (int i = h[u]; i!=-1 ; i =ne[i] ){//遍历u的子节点进行深度优先遍历 int j=e[i]; dfs(j); //状态转移方程 f[u][0]+=max(f[j][0],f[j][1]);//f[u][0]表示不选择父节点u，所以在f[j][0]和f[j][1]取最大值 f[u][1]+=f[j][0];//f[u][1]表示选择根节点u，所以累加不选择子节点的f[j][0] } } int main() { cin&gt;&gt;n; for (int i = 1; i &lt;= n; i ++ )cin&gt;&gt;w[i]; memset(h, -1, sizeof h); for (int i = 0; i &lt; n-1; i ++ ){ int a,b; cin&gt;&gt;a&gt;&gt;b; add(b,a); st[a]=true;//存储是否存在父节点 } int root=1; while(st[root])root++;//判断是否是根节点 dfs(root);//dfs对f[i][j]进行状态转移计算 cout&lt;&lt;max(f[root][0],f[root][1])&lt;&lt;endl;//取选与不选根节点的最大值 return 0; } 状态转移方程： f[u][0]+=max(f[j][0],f[j][1]); f[u][1]+=f[j][0]; 记忆化搜索滑雪题目链接：[P1434 [SHOI2002] 滑雪 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)]：https://www.luogu.com.cn/problem/P1434 using namespace std; const int N = 310; int n,m; int h[N][N]; int f[N][N]; int dx[4]={-1,0,1,0},dy[4]={0,1,0,-1}; int dp(int x,int y){ int &amp;v=f[x][y]; if(v!=-1)return v;//记忆化搜索核心 v=1; for (int i = 0; i &lt; 4; i ++ ){ int a=x+dx[i],b=y+dy[i]; if(a&gt;=1&amp;&amp;a&lt;=n&amp;&amp;b&gt;=1&amp;&amp;b&lt;=m&amp;&amp;h[a][b]&lt;h[x][y])//判断是否越界且上一个经过的点的高度是否大于当前高度 v=max(v,dp(a,b)+1); } return v; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= m; j ++ ) scanf(&quot;%d&quot;, &amp;h[i][j]); memset(f, -1, sizeof f); int res=0; for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= m; j ++ ) res=max(res,dp(i,j)); printf(&quot;%d\\n&quot;,res); return 0; } 状态转移方程：v=max(v,dp(a,b)+1); 六、贪心一个贪心算法总是做出当前最好的选择，也就是说，它期望通过局部最优选择从而得到全局最优的解决方案。—《算法导论》 区间问题区间选点给定 N个闭区间[ai,bi]，请你在数轴上选择尽量少的点，使得每个区间内至少包含一个选出的点 输出选择的点的最小数量。 using namespace std; const int N = 100010; int n; struct Range{ int l,r; bool operator &lt;(const Range&amp; W)const{ return r&lt;W.r; }//重载小于号 }range[N]; int main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i ++ ){ int l,r; scanf(&quot;%d%d&quot;, &amp;l, &amp;r); range[i]={l,r};//读入l,r } sort(range,range+n);//按右端点进行排序 int res=0,ed=-2e9;//ed代表上一个点的右端点 for (int i = 0; i &lt; n; i ++ ){ if(range[i].l&gt;ed){ res++;//点的数量加一 ed=range[i].r; } } printf(&quot;%d\\n&quot;,res); return 0; } 最大不相交区间数量给定 N个闭区间 [ai,bi]，请你在数轴上选择若干区间，使得选中的区间之间互不相交（包括端点）。 输出可选取区间的最大数量。 结论：最大不相交区间数量=最少覆盖区间点数 为什么最大不相交区间数=最少覆盖区间点数呢？ 因为如果几个区间能被同一个点覆盖 说明他们相交了，所以有几个点就是有几个不相交区间 using namespace std; const int N = 100010; int n; struct Range{ int l,r; bool operator &lt;(const Range&amp; W)const{ return r&lt;W.r; } }range[N]; int main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i ++ ){ int l,r; scanf(&quot;%d%d&quot;, &amp;l, &amp;r); range[i]={l,r}; } sort(range,range+n); int res=0,ed=-2e9; for (int i = 0; i &lt; n; i ++ ){ if(range[i].l&gt;ed){ res++; ed=range[i].r; } } printf(&quot;%d\\n&quot;,res); return 0; } 区间分组区间分组.png using namespace std; const int N = 1e5+10; int n; struct Range{ int l,r; bool operator&lt;(const Range &amp;W)const{ return l&lt;W.l; }//按左端点排序 }range[N]; int main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i ++ ){ int l,r; scanf(&quot;%d%d&quot;, &amp;l, &amp;r); range[i]={l,r}; } sort(range,range+n);//sort排序 priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; heap;//小根堆维护所有组的右端点最小值 for (int i = 0; i &lt; n; i ++ ){//从左往右枚举 auto r=range[i];//选择当前区间 if(heap.empty()||heap.top()&gt;=r.l)heap.push(r.r); else{ heap.pop(); heap.push(r.r); } } printf(&quot;%d\\n&quot;,heap.size()); return 0; } 排序不等式排队打水有 n个人排队到 1 个水龙头处打水，第 i 个人装满水桶所需的时间是 ti，请问如何安排他们的打水顺序才能使所有人的等待时间之和最小？ t[i]从小到大排序： 计算公式：t[0]×(n−1)+t[1]×(n−2)+t[2]×(n−3)…+t[n]×0 using namespace std; typedef long long LL; const int N = 1e5 + 10; int t[N]; int main() { int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;t[i]); sort(t, t + n);//排序 LL ans = 0; for (int i = 0; i &lt; n; i++) { ans += t[i] * (n - i - 1);//计算 } printf(&quot;%lld&quot;, ans); return 0; }","link":"/2024/06/13/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"},{"title":"高精度减法","text":"高精度减法实现在处理大整数运算时，直接使用内置的数据类型可能会导致溢出，因此需要使用字符串或数组来存储大整数，并逐位进行运算。本文将介绍如何使用C++实现高精度减法。 代码实现以下是一个实现高精度减法的完整C++代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; a, b; // 存储大整数string s1, s2; // 存储输入的两个大整数字符串int t;vector&lt;int&gt; sub(vector&lt;int&gt; a, vector&lt;int&gt; b) { vector&lt;int&gt; c; int t = 0; for(int i = 0; i &lt; a.size(); ++i) { a[i] -= t; if(i &lt; b.size()) a[i] -= b[i]; if(a[i] &lt; 0) t = 1; else t = 0; c.push_back((a[i] + 10) % 10); } while(c.size() &gt; 1 &amp;&amp; c.back() == 0) c.pop_back(); return c;}bool Max(vector&lt;int&gt; a, vector&lt;int&gt; b) { if(a.size() &lt; b.size()) return true; if(a.size() &gt; b.size()) return false; for(int i = a.size() - 1; i &gt;= 0; --i) if(a[i] &gt; b[i]) return false; else if(a[i] &lt; b[i]) return true; return 0;}int main() { cin &gt;&gt; s1 &gt;&gt; s2; for(int i = s1.size() - 1; i &gt;= 0; --i) a.push_back(s1[i] - '0'); for(int i = s2.size() - 1; i &gt;= 0; --i) b.push_back(s2[i] - '0'); if(Max(a, b) == true) { printf(&quot;-&quot;); auto c = sub(b, a); for(int i = c.size() - 1; i &gt;= 0; --i) printf(&quot;%d&quot;, c[i]); } else { auto c = sub(a, b); for(int i = c.size() - 1; i &gt;= 0; --i) printf(&quot;%d&quot;, c[i]); } return 0;} 示例输入输出以下是一些示例输入和对应的输出，帮助理解代码的工作原理。 示例 1输入： 121234567890123456789098765432109876543210 输出： 1-86419753208641975320 示例 2输入： 129876543210987654321012345678901234567890 输出： 186419753208641975320 示例 3输入： 125000000000000000000050000000000000000000 输出： 10 代码说明输入处理： 使用字符串 s1 和 s2 分别存储输入的两个大整数。 将字符串转换为倒序存储的整数数组 a 和 b。 减法实现： 函数 sub 实现两个大整数的逐位减法，考虑借位情况。 函数 Max 用于比较两个大整数的大小，确定是否需要输出负号。 主函数逻辑： 根据 Max 函数的结果，确定是 a - b 还是 b - a。 输出结果时，如果需要，先输出负号，再输出结果。","link":"/2024/05/30/%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%87%8F%E6%B3%95/"},{"title":"高精度加法","text":"高精度加法实现在处理大整数运算时，直接使用内置的数据类型可能会导致溢出，因此需要使用字符串或数组来存储大整数，并逐位进行运算。本文将介绍如何使用C++实现高精度加法。 代码实现以下是一个实现高精度加法的完整C++代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt; // 包含所有标准库的头文件using namespace std;vector&lt;int&gt; a; // 存储第一个大整数vector&lt;int&gt; b; // 存储第二个大整数string s1, s2; // 存储输入的两个大整数字符串// 实现两个大整数的加法函数vector&lt;int&gt; add(vector&lt;int&gt; a, vector&lt;int&gt; b) { if (a.size() &lt; b.size()) return add(b, a); // 确保 a 的长度大于或等于 b vector&lt;int&gt; c; // 存储结果的向量 int t = 0; // 进位 // 遍历较长的向量 a for (int i = 0; i &lt; a.size(); ++i) { t += a[i]; // 累加 a 的当前位 if (i &lt; b.size()) t += b[i]; // 如果 b 还有对应的位，则累加 b 的当前位 c.push_back(t % 10); // 将当前位的结果存入 c t /= 10; // 更新进位 } // 如果有剩余的进位，则加入结果 if (t) c.push_back(t); return c;}int main() { // 读取两个大整数的字符串 cin &gt;&gt; s1 &gt;&gt; s2; // 将字符串转换为向量，低位在前 for (int i = s1.size() - 1; i &gt;= 0; --i) a.push_back(s1[i] - '0'); for (int i = s2.size() - 1; i &gt;= 0; --i) b.push_back(s2[i] - '0'); //在C++中，字符（char）和整数（int）之间有一定的对应关系。具体来说，字符 '0' 到 '9' 的ASCII值分别是48到57。为了将字符 '0' 到 '9' 转换为对应的整数0到9，需要减去字符 '0' 的ASCII值。这是因为字符 '0' 的ASCII值是48，所以减去48就得到了对应的整数值。 // 计算两个向量的和 auto ans = add(a, b); // 逆序输出结果 for (int i = ans.size() - 1; i &gt;= 0; --i) printf(&quot;%d&quot;, ans[i]); return 0;} 示例输入输出以下是一些示例输入和对应的输出，帮助理解代码的工作原理。 示例 1输入： 121234567890123456789098765432109876543210 输出： 1111111111011111111100 示例 2输入： 125000000000000000000050000000000000000000 输出： 1100000000000000000000 示例 3输入： 12999999999999999999991 输出： 1100000000000000000000 代码说明输入处理： 使用字符串 s1 和 s2 分别存储输入的两个大整数。 将字符串转换为倒序存储的整数数组 a 和 b。 加法实现： 函数 add 实现两个大整数的逐位加法，考虑进位情况。 主函数逻辑： 将两个字符串转换为整数数组，并确保 a 的长度大于或等于 b。 计算两个向量的和，并逆序输出结果。","link":"/2024/05/30/%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8A%A0%E6%B3%95/"},{"title":"高精度除法","text":"高精度除法实现在处理大整数运算时，直接使用内置的数据类型可能会导致溢出，因此需要使用字符串或数组来存储大整数，并逐位进行运算。本文将介绍如何使用C++实现高精度除法。 代码实现以下是一个实现高精度除法的完整C++代码示例： 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; div(vector&lt;int&gt; a, int b, int &amp;r) { vector&lt;int&gt; c; r = 0; for (int i = a.size()-1; i &gt;= 0; i--) { r = r*10 + a[i]; c.push_back(r / b); r = r % b; } reverse(c.begin(), c.end()); return c;}int main() { string a; int b; cin &gt;&gt; a &gt;&gt; b; vector&lt;int&gt; A; for (int i = a.size() - 1; i &gt;= 0; i--) { A.push_back(a[i] - '0'); } int r = 0; auto C = div(A, b, r); for (int i = C.size() - 1; i &gt;= 0; i--) { printf(&quot;%d&quot;, C[i]); } cout &lt;&lt; endl &lt;&lt; r &lt;&lt; endl; return 0;} 示例输入输出以下是一些示例输入和对应的输出，帮助理解代码的工作原理。 示例 1输入： 121234567890123456789012345 输出： 1210000540890046170 示例 2输入： 1298765432109876543210123456789 输出： 1280000000450000003698765432 示例 3输入： 1210000000000000000000999999999 输出： 12100000000011 代码说明输入处理： 使用字符串 a 存储输入的大整数。 将字符串转换为倒序存储的整数数组 A。 除法实现： 函数 div 实现大整数与单个整数的逐位除法，并计算余数。 主函数逻辑： 将字符串转换为整数数组，并进行逐位除法计算。 输出结果并打印余数。","link":"/2024/05/30/%E9%AB%98%E7%B2%BE%E5%BA%A6%E9%99%A4%E6%B3%95/"},{"title":"xmu预推免机试","text":"1.给定一个字符串 &quot;a34b102&quot;，从中提取八进制数字 &quot;34102&quot;。将这个八进制数字转换为二进制，并计算其二进制表示中1的个数。C语言解决方案12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;// 函数：将八进制数转换为二进制并计算其中1的个数int countOnesInOctalToBinary(char *octalString) { long octalNum = strtol(octalString, NULL, 8); // 将八进制字符串转换为长整型数值 int count = 0; // 计算二进制中1的个数 while (octalNum &gt; 0) { count += octalNum &amp; 1; octalNum &gt;&gt;= 1; } return count;}int main() { char input[] = &quot;a34b102&quot;; char octalString[20]; // 存储提取的八进制数字字符串 int octalIndex = 0; // 提取字符串中的八进制数字部分 for (int i = 0; i &lt; strlen(input); i++) { if (input[i] &gt;= '0' &amp;&amp; input[i] &lt;= '7') { octalString[octalIndex++] = input[i]; } } octalString[octalIndex] = '\\0'; // 添加字符串结束符 printf(&quot;提取的八进制数字为：%s\\n&quot;, octalString); // 计算八进制转换为二进制中1的个数 int onesCount = countOnesInOctalToBinary(octalString); printf(&quot;八进制转换为二进制后1的个数为：%d\\n&quot;, onesCount); return 0;} 解决方案详解问题描述 输入：字符串 &quot;a34b102&quot;。 输出： 从输入字符串中提取八进制数字 &quot;34102&quot;。 将该八进制数字转换为二进制，并计算其二进制表示中1的个数。 C语言代码详解 countOnesInOctalToBinary 函数：将八进制字符串转换为长整型数值，并使用位操作计算其中1的个数。 main 函数： 初始化输入字符串 &quot;a34b102&quot;。 从输入字符串中提取八进制数字部分，并存储在 octalString 中。 调用 countOnesInOctalToBinary 函数，计算八进制数字转换为二进制后1的个数。 输出提取的八进制数字和计算得到的二进制中1的个数。 运行代码 编译并运行这段C程序。 输出结果应为：12提取的八进制数字为：34102八进制转换为二进制后1的个数为：5 这表明程序正确地从输入字符串中提取了八进制数字，并计算了所需的二进制中1的个数。","link":"/2024/06/29/xmu%E9%A2%84%E6%8E%A8%E5%85%8D%E6%9C%BA%E8%AF%95/"},{"title":"算法设计的一些概念","text":"1.简述分治算法分治算法（Divide and Conquer）的基本思想是将一个复杂的问题分解成多个较小的、相互独立的子问题，然后递归地解决这些子问题，最后将子问题的解合并起来得到原问题的解。具体步骤如下： 分解（Divide）：将问题划分为若干个规模较小的子问题。这些子问题的形式与原问题相同或相似，但规模要小于原问题。 解决（Conquer）：递归地求解这些子问题。当子问题的规模足够小时（达到某个递归基准），直接解决这些子问题，而不再进一步分解。 合并（Combine）：将子问题的解合并起来，形成原问题的解。 这种方法的一个典型应用是快速排序（Quicksort）和归并排序（Merge Sort）。以归并排序为例： 分解：将数组分成两个大致相等的子数组。 解决：递归地对这两个子数组进行排序。 合并：将两个已排序的子数组合并成一个有序的数组。 分治算法的优点在于能够将大问题转化为小问题，通过递归的方式简化问题的求解过程，常常能显著降低算法的时间复杂度。例如，归并排序的时间复杂度为 (O(n \\log n))，比起简单排序算法如冒泡排序的 (O(n^2)) 要高效得多。 分治算法的典型特点是： 递归的结构。 问题的可分解性和可合并性。 子问题的独立性。 这些特点使得分治算法在计算机科学中有着广泛的应用，如排序、搜索、矩阵乘法、傅里叶变换等。 2.简述动态规划算法的基本思想动态规划（Dynamic Programming，DP）是一种用于解决复杂问题的方法，尤其适用于那些可以分解为相对简单的子问题的问题。其基本思想是通过将问题分解为更小的子问题，并将这些子问题的结果进行储存和重用，从而减少重复计算，提高算法效率。动态规划的核心思想可以概括为以下几个步骤： 划分子问题：将原问题分解为若干个相互重叠的子问题。这个过程通常会基于问题的结构，找到一种递归的关系，将大问题拆解成小问题。 定义状态：确定问题的状态。状态通常是描述问题在某一步骤的特征，可以用一个或多个变量表示。例如，在求解最短路径问题时，状态可以是当前节点和已经经过的节点集合。 确定状态转移方程：找到状态之间的关系，即状态转移方程。状态转移方程描述了如何从一个状态转移到另一个状态，以及这些状态之间的递归关系。 确定初始状态和边界条件：明确初始状态和边界条件。初始状态是问题的起始点，边界条件是一些已知的简单解。 自底向上计算：从最简单的子问题开始，逐步计算并储存每个子问题的结果。最终，通过组合这些子问题的解，得到原问题的解。 储存和重用子问题的结果：利用一个表格（通常是数组或矩阵）来储存已经计算过的子问题的结果，以便在需要时直接使用，避免重复计算。 一个经典的例子是斐波那契数列的计算。斐波那契数列的递归定义是： [ F(n) = F(n-1) + F(n-2) ] 通过动态规划，可以避免重复计算，从而大大提高计算效率： 12345678def fibonacci(n): if n &lt;= 1: return n dp = [0] * (n + 1) dp[1] = 1 for i in range(2, n + 1): dp[i] = dp[i-1] + dp[i-2] return dp[n] 通过上述步骤和思想，动态规划可以高效地解决许多具有重叠子问题和最优子结构性质的问题。 3.简述回溯算法和分支限界算法的异同回溯算法和分支限界算法都是用于解决组合优化问题的常用方法，它们都采用了系统搜索的策略，但在实现细节和应用场景上有所不同。以下是对它们异同点的简述： 回溯算法基本思想：回溯算法是一种深度优先搜索（DFS）的方法，用于在解空间树中寻找所有可能的解或最优解。它通过在搜索过程中逐步构建解，并在发现当前部分解不能导致有效解时，回溯到上一步继续搜索。 特点： 逐步构建解：逐步扩展当前部分解，直到找到一个完整解或发现当前路径无效。 回溯：当发现当前路径不能通向有效解时，回到上一步继续尝试其他可能。 不剪枝：通常情况下不进行剪枝操作，尝试所有可能的路径。 应用场景：适用于需要遍历所有解空间，找出所有可行解的情况，例如八皇后问题、全排列生成等。 示例代码： 123456789def backtrack(solution, step): if step == goal: print(solution) else: for option in options: if is_valid(option): solution.append(option) backtrack(solution, step + 1) solution.pop() 分支限界算法基本思想：分支限界算法是一种广度优先搜索（BFS）或优先队列搜索的方法，通过对解空间进行分支和限界操作，有效剪枝以减少搜索空间，从而更快找到最优解或可行解。 特点： 分支：将问题逐步分解成更小的子问题，每个子问题代表解空间的一部分。 限界：使用限界函数（例如上下界估计）判断当前子问题是否可能包含最优解，如果不可能，则剪枝，避免无效搜索。 优先搜索：通常结合优先队列，根据限界函数值优先处理最有可能产生最优解的子问题。 应用场景：适用于需要找到最优解并且解空间较大的情况，例如旅行商问题、0/1背包问题等。 示例代码： 123456789101112import heapqdef branch_and_bound(initial_state): priority_queue = [] heapq.heappush(priority_queue, (initial_state.bound, initial_state)) while priority_queue: bound, current = heapq.heappop(priority_queue) if current.is_solution(): return current for child in current.generate_children(): if child.bound &lt; best_known_bound: heapq.heappush(priority_queue, (child.bound, child)) 异同点总结相同点： 系统搜索：都通过系统搜索策略寻找解。 解空间树：都以解空间树为基础进行问题求解。 适用于组合优化：都用于解决组合优化问题。 不同点： 搜索方式： 回溯算法采用深度优先搜索，逐步构建解并在必要时回溯。 分支限界算法通常采用广度优先搜索或优先队列搜索，通过限界函数进行剪枝。 剪枝策略： 回溯算法不进行系统性的剪枝操作。 分支限界算法通过限界函数进行有效剪枝，减少搜索空间。 应用场景： 回溯算法适合需要遍历所有解的情况。 分支限界算法适合需要找到最优解并且解空间较大的情况。 这两种算法在实际应用中各有优势，根据具体问题的性质选择合适的方法可以大大提高求解效率。 4.简述贪心算法贪心算法（Greedy Algorithm）是一种在每一步选择中都做出在当前看来是最优的选择，从而希望通过一系列局部最优的选择达到全局最优解决方案的算法策略。贪心算法的基本思想是通过分阶段逐步解决问题，在每一个阶段中选择当前状态下最优的决策。 贪心算法的基本思想 选择性质：贪心算法依赖于一种称为贪心选择性质的原则，即局部最优选择可以导致全局最优解。每一步选择的局部最优解是指在当前步骤中，不考虑后续步骤所选择的最优解。 最优子结构：问题可以通过局部最优选择形成一个最优解，即问题的最优解包含其子问题的最优解。 贪心算法的步骤 建立数学模型：将问题描述成数学模型，明确要达到的目标和约束条件。 贪心选择策略：设计一个贪心选择策略，每一步都选择当前最优的解。 验证贪心选择的正确性：确保通过贪心选择能得到问题的一个全局最优解，通常需要证明贪心选择具有最优子结构性质。 构造解：从局部最优解出发逐步构造全局最优解。 贪心算法的应用贪心算法广泛应用于一些能够通过局部最优解逐步构造全局最优解的问题，经典的应用包括： 最小生成树问题（Kruskal算法、Prim算法） 单源最短路径问题（Dijkstra算法） 活动选择问题 背包问题的部分情况（如分数背包问题） 示例：分数背包问题在分数背包问题中，给定一组物品，每个物品有一个价值和重量，目标是将这些物品装入一个背包，使得背包的总价值最大化，并且允许对物品进行分割。贪心算法的策略是根据每个物品的价值重量比进行选择，每次选择价值重量比最高的物品，直到背包装满。 1234567891011121314151617181920212223242526class Item: def __init__(self, value, weight): self.value = value self.weight = weight self.ratio = value / weightdef fractional_knapsack(items, capacity): # 按照物品的价值重量比排序 items.sort(key=lambda x: x.ratio, reverse=True) total_value = 0.0 for item in items: if capacity &gt;= item.weight: # 如果背包能装下当前物品，就全部装入 capacity -= item.weight total_value += item.value else: # 否则装入部分物品 total_value += item.ratio * capacity break return total_value# 示例用法items = [Item(60, 10), Item(100, 20), Item(120, 30)]capacity = 50print(f&quot;最大价值: {fractional_knapsack(items, capacity)}&quot;) 贪心算法的优缺点优点： 简单高效：贪心算法实现简单，通常能在多项式时间内解决问题。 局部最优选择：在很多实际问题中，贪心算法能快速找到较优解。 缺点： 局限性：贪心算法不总能保证全局最优解，特别是对不满足贪心选择性质和最优子结构性质的问题。 适用范围有限：贪心算法适用于问题具有贪心选择性质和最优子结构性质的问题，不适用于所有问题。 总之，贪心算法通过每一步都选择当前最优的策略，希望通过局部最优解达到全局最优解，但其应用需谨慎，确保问题具有贪心选择性质和最优子结构性质。","link":"/2024/06/30/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5/"}],"tags":[{"name":"日常","slug":"日常","link":"/tags/%E6%97%A5%E5%B8%B8/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"字符串","slug":"字符串","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"Computer","slug":"Computer","link":"/tags/Computer/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"面经1-swimtransformer","slug":"面经1-swimtransformer","link":"/tags/%E9%9D%A2%E7%BB%8F1-swimtransformer/"},{"name":"面经2-attention(注意力机制)","slug":"面经2-attention-注意力机制","link":"/tags/%E9%9D%A2%E7%BB%8F2-attention-%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/"},{"name":"面试真题","slug":"面试真题","link":"/tags/%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/"},{"name":"算法设计概念","slug":"算法设计概念","link":"/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%A6%82%E5%BF%B5/"}],"categories":[],"pages":[]}