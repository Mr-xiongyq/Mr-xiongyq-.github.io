{"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2024/03/17/hello-world/"},{"title":"First_blog","text":"你好，这是我的第一条博客","link":"/2024/03/17/First-blog/"},{"title":"快速排序(quick_sort)","text":"题目描述给定你一个长度为 n 的整数数列。请你使用快速排序对这个数列按照从小到大进行排序，并将排好序的数列按顺序输出。 输入格式输入共两行，第一行包含整数 n。第二行包含 n 个整数（所有整数均在 1∼109 范围内），表示整个数列。 输出格式输出共一行，包含 n 个整数，表示排好序的数列。 数据范围1 ≤ n ≤ 100000 样例输入样例：1253 1 2 4 5 输出样例：11 2 3 4 5 C++ 代码算法1：使用手写快速排序123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;#define N 100005int q[N], n;void quick_sort(int l, int r) { if(l &gt;= r) return ; int i = l - 1, j = r + 1; int x = q[l + r &gt;&gt; 1]; while(i &lt; j) { do ++i; while(q[i] &lt; x); do --j; while(q[j] &gt; x); if(i &lt; j) swap(q[i], q[j]); } quick_sort(l, j); quick_sort(j + 1, r);}int main() { scanf(&quot;%d&quot;,&amp;n); for(int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;,q+i); quick_sort(1, n); for(int i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;,q[i]); return 0;} 算法2：(c++STL) O(nlogn) 用algorithm库的sort函数1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;#define N 100005int q[N], n;int main() { scanf(&quot;%d&quot;,&amp;n); for(int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;,q+i); sort(q + 1, q + 1 + n); // STL yyds!!! for(int i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;,q[i]); return 0;}","link":"/2024/05/27/quick-sort/"},{"title":"归并排序(merge_sort)","text":"题目描述给定你一个长度为 n 的整数数列。请你使用归并排序对这个数列按照从小到大进行排序，并将排好序的数列按顺序输出。 输入格式输入共两行，第一行包含整数 n。第二行包含 n 个整数（所有整数均在 1∼109 范围内），表示整个数列。 输出格式输出共一行，包含 n 个整数，表示排好序的数列。 数据范围1 ≤ n ≤ 100000 样例输入样例：1253 1 2 4 5 输出样例：11 2 3 4 5 算法1 (排序) O(nlogn)归并排序板子，先分组，再组合（merge） C++ 代码1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;#define N 100005int n, q[N];void merge_sort(int q[], int l, int r) { if (l &gt;= r) return; int mid = (l + r) &gt;&gt; 1; merge_sort(q, l, mid); merge_sort(q, mid + 1, r); int temp[N]; int k = 0; int x = l, y = mid + 1; while (x &lt;= mid &amp;&amp; y &lt;= r) { if (q[x] &lt;= q[y]) temp[++k] = q[x++]; else temp[++k] = q[y++]; } while (x &lt;= mid) temp[++k] = q[x++]; while (y &lt;= r) temp[++k] = q[y++]; for (int i = 1, j = l; j &lt;= r; ++i, ++j) q[j] = temp[i];}int main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, q + i); merge_sort(q, 1, n); for (int i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;, q[i]); return 0;}","link":"/2024/05/27/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-merge-sort/"},{"title":"整数二分(besearch)","text":"题目描述给定一个按照升序排列的长度为 n 的整数数组，以及 q 个查询。对于每个查询，返回一个元素 k 的起始位置和终止位置（位置从 0 开始计数）。如果数组中不存在该元素，则返回 -1 -1。 输入格式 第一行包含整数 n 和 q，表示数组长度和询问个数。 第二行包含 n 个整数（均在 1∼10000 范围内），表示完整数组。 接下来 q 行，每行包含一个整数 k，表示一个询问元素。 输出格式共 q 行，每行包含两个整数，表示所求元素的起始位置和终止位置。如果数组中不存在该元素，则返回 -1 -1。 数据范围 1≤n≤100000 1≤q≤10000 1≤k≤10000 样例输入样例：123456 31 2 2 3 3 4345 输出样例：1233 45 5-1 -1 算法1(二分) O(nlogn)枚举左端点和右端点 C++ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;using namespace std;#define N 1000010int n, k, q, a[N];// 查找元素q在数组a中的首次和最后一次出现的位置void bearch(int q) { // leftans和rightans用于存储结果，初始化为最大值和最小值 int leftans = INT_MAX, rightans = INT_MIN; int l = 0, r = n - 1; // 找到元素q的首次出现位置 while (l &lt; r) { int mid = (l + r) &gt;&gt; 1; // 等价于 (l + r) / 2 if (a[mid] &gt;= q) r = mid; else l = mid + 1; } // 如果在数组a中没有找到元素q，输出-1 -1 if (a[l] != q) { printf(&quot;-1 -1\\n&quot;); return; } // 输出元素q的首次出现位置 printf(&quot;%d &quot;, l); // 重置左右边界，准备查找最后一次出现位置 l = 0, r = n - 1; // 找到元素q的最后一次出现位置 while (l &lt; r) { int mid = (l + r + 1) &gt;&gt; 1; // 等价于 (l + r + 1) / 2 if (a[mid] &lt;= q) l = mid; else r = mid - 1; } // 输出元素q的最后一次出现位置 printf(&quot;%d\\n&quot;, l); return;}int main() { // 输入数组长度n和查询次数k scanf(&quot;%d %d&quot;, &amp;n, &amp;k); // 输入数组元素 for (int i = 0; i &lt; n; ++i) scanf(&quot;%d&quot;, a + i); // 对每个查询执行bearch函数 while (k--) { scanf(&quot;%d&quot;, &amp;q); bearch(q); } return 0;} 算法2(upperbound 和 lowerbound) O(nlogn)STL 大法好！！！ 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;#define N 1000010int n, k, q, a[N];int main() { scanf(&quot;%d %d&quot;, &amp;n, &amp;k); for (int i = 0; i &lt; n; ++i) scanf(&quot;%d&quot;,a + i); while (k--) { scanf(&quot;%d&quot;, &amp;q); int t = lower_bound(a, a + n, q) - a; if (t == n || a[t] != q) { puts(&quot;-1 -1&quot;); continue; } printf(&quot;%d &quot;, t); t = upper_bound(a, a + n, q) - a; printf(&quot;%d\\n&quot;, t - 1); } return 0;}","link":"/2024/05/28/%E6%95%B4%E6%95%B0%E4%BA%8C%E5%88%86/"},{"title":"数的三次方根","text":"题目描述给定一个浮点数 n，求它的三次方根。 输入格式共一行，包含一个浮点数 n。 输出格式共一行，包含一个浮点数，表示问题的解。 注意，结果保留 6 位小数。 数据范围 −10000≤n≤10000 样例输入样例：11000.00 输出样例：110.000000 算法1(二分) O(logn)小数二分 C++ 代码123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;double x;double bsearch(double x) { double l = -1e3, r = 1e3; while(r - l &gt; 1e-8) { //取保留位数多2位,如:保留一位小数,写1e-3 double mid = (l + r) / 2; if(mid * mid * mid &gt;= x) r = mid; else l = mid; } return l;}int main() { cin &gt;&gt; x; printf(&quot;%.6lf&quot;,bsearch(x)); return 0;}","link":"/2024/05/28/%E6%95%B0%E7%9A%84%E4%B8%89%E6%AC%A1%E6%96%B9%E6%A0%B9/"},{"title":"高精度乘法","text":"高精度乘法实现在处理大整数运算时，直接使用内置的数据类型可能会导致溢出，因此需要使用字符串或数组来存储大整数，并逐位进行运算。本文将介绍如何使用C++实现高精度乘法。 代码实现以下是一个实现高精度乘法的完整C++代码示例： 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; mul(vector&lt;int&gt; a, int b) { vector&lt;int&gt; c; int t = 0; for (int i = 0; i &lt; a.size(); i++) { t += a[i] * b; c.push_back(t % 10); t = t / 10; } while (t) { c.push_back(t % 10); t = t / 10; } return c;}int main() { string a; int b; cin &gt;&gt; a &gt;&gt; b; vector&lt;int&gt; A; for (int i = a.size() - 1; i &gt;= 0; i--) { A.push_back(a[i] - '0'); } auto C = mul(A, b); for (int i = C.size() - 1; i &gt;= 0; i--) { printf(&quot;%d&quot;, C[i]); } return 0;} 示例输入输出以下是一些示例输入和对应的输出，帮助理解代码的工作原理。 示例 1输入： 12123456789012345678909 输出： 1111111110111111110010 示例 2输入： 12987654321098765432108 输出： 1790123456879012345680 示例 3输入： 12999999999999999999995 输出： 1499999999999999999995 代码说明输入处理： 使用字符串 a 存储输入的大整数。 将字符串转换为倒序存储的整数数组 A。 乘法实现： 函数 mul 实现大整数与单个整数的逐位乘法，并处理进位。 主函数逻辑： 将字符串转换为整数数组，并进行逐位乘法计算。 逆序输出结果。","link":"/2024/05/30/%E9%AB%98%E7%B2%BE%E5%BA%A6%E4%B9%98%E6%B3%95/"},{"title":"高精度减法","text":"高精度减法实现在处理大整数运算时，直接使用内置的数据类型可能会导致溢出，因此需要使用字符串或数组来存储大整数，并逐位进行运算。本文将介绍如何使用C++实现高精度减法。 代码实现以下是一个实现高精度减法的完整C++代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; a, b; // 存储大整数string s1, s2; // 存储输入的两个大整数字符串int t;vector&lt;int&gt; sub(vector&lt;int&gt; a, vector&lt;int&gt; b) { vector&lt;int&gt; c; int t = 0; for(int i = 0; i &lt; a.size(); ++i) { a[i] -= t; if(i &lt; b.size()) a[i] -= b[i]; if(a[i] &lt; 0) t = 1; else t = 0; c.push_back((a[i] + 10) % 10); } while(c.size() &gt; 1 &amp;&amp; c.back() == 0) c.pop_back(); return c;}bool Max(vector&lt;int&gt; a, vector&lt;int&gt; b) { if(a.size() &lt; b.size()) return true; if(a.size() &gt; b.size()) return false; for(int i = a.size() - 1; i &gt;= 0; --i) if(a[i] &gt; b[i]) return false; else if(a[i] &lt; b[i]) return true; return 0;}int main() { cin &gt;&gt; s1 &gt;&gt; s2; for(int i = s1.size() - 1; i &gt;= 0; --i) a.push_back(s1[i] - '0'); for(int i = s2.size() - 1; i &gt;= 0; --i) b.push_back(s2[i] - '0'); if(Max(a, b) == true) { printf(&quot;-&quot;); auto c = sub(b, a); for(int i = c.size() - 1; i &gt;= 0; --i) printf(&quot;%d&quot;, c[i]); } else { auto c = sub(a, b); for(int i = c.size() - 1; i &gt;= 0; --i) printf(&quot;%d&quot;, c[i]); } return 0;} 示例输入输出以下是一些示例输入和对应的输出，帮助理解代码的工作原理。 示例 1输入： 121234567890123456789098765432109876543210 输出： 1-86419753208641975320 示例 2输入： 129876543210987654321012345678901234567890 输出： 186419753208641975320 示例 3输入： 125000000000000000000050000000000000000000 输出： 10 代码说明输入处理： 使用字符串 s1 和 s2 分别存储输入的两个大整数。 将字符串转换为倒序存储的整数数组 a 和 b。 减法实现： 函数 sub 实现两个大整数的逐位减法，考虑借位情况。 函数 Max 用于比较两个大整数的大小，确定是否需要输出负号。 主函数逻辑： 根据 Max 函数的结果，确定是 a - b 还是 b - a。 输出结果时，如果需要，先输出负号，再输出结果。","link":"/2024/05/30/%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%87%8F%E6%B3%95/"},{"title":"高精度加法","text":"高精度加法实现在处理大整数运算时，直接使用内置的数据类型可能会导致溢出，因此需要使用字符串或数组来存储大整数，并逐位进行运算。本文将介绍如何使用C++实现高精度加法。 代码实现以下是一个实现高精度加法的完整C++代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt; // 包含所有标准库的头文件using namespace std;vector&lt;int&gt; a; // 存储第一个大整数vector&lt;int&gt; b; // 存储第二个大整数string s1, s2; // 存储输入的两个大整数字符串// 实现两个大整数的加法函数vector&lt;int&gt; add(vector&lt;int&gt; a, vector&lt;int&gt; b) { if (a.size() &lt; b.size()) return add(b, a); // 确保 a 的长度大于或等于 b vector&lt;int&gt; c; // 存储结果的向量 int t = 0; // 进位 // 遍历较长的向量 a for (int i = 0; i &lt; a.size(); ++i) { t += a[i]; // 累加 a 的当前位 if (i &lt; b.size()) t += b[i]; // 如果 b 还有对应的位，则累加 b 的当前位 c.push_back(t % 10); // 将当前位的结果存入 c t /= 10; // 更新进位 } // 如果有剩余的进位，则加入结果 if (t) c.push_back(t); return c;}int main() { // 读取两个大整数的字符串 cin &gt;&gt; s1 &gt;&gt; s2; // 将字符串转换为向量，低位在前 for (int i = s1.size() - 1; i &gt;= 0; --i) a.push_back(s1[i] - '0'); for (int i = s2.size() - 1; i &gt;= 0; --i) b.push_back(s2[i] - '0'); //在C++中，字符（char）和整数（int）之间有一定的对应关系。具体来说，字符 '0' 到 '9' 的ASCII值分别是48到57。为了将字符 '0' 到 '9' 转换为对应的整数0到9，需要减去字符 '0' 的ASCII值。这是因为字符 '0' 的ASCII值是48，所以减去48就得到了对应的整数值。 // 计算两个向量的和 auto ans = add(a, b); // 逆序输出结果 for (int i = ans.size() - 1; i &gt;= 0; --i) printf(&quot;%d&quot;, ans[i]); return 0;} 示例输入输出以下是一些示例输入和对应的输出，帮助理解代码的工作原理。 示例 1输入： 121234567890123456789098765432109876543210 输出： 1111111111011111111100 示例 2输入： 125000000000000000000050000000000000000000 输出： 1100000000000000000000 示例 3输入： 12999999999999999999991 输出： 1100000000000000000000 代码说明输入处理： 使用字符串 s1 和 s2 分别存储输入的两个大整数。 将字符串转换为倒序存储的整数数组 a 和 b。 加法实现： 函数 add 实现两个大整数的逐位加法，考虑进位情况。 主函数逻辑： 将两个字符串转换为整数数组，并确保 a 的长度大于或等于 b。 计算两个向量的和，并逆序输出结果。","link":"/2024/05/30/%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8A%A0%E6%B3%95/"},{"title":"高精度除法","text":"高精度除法实现在处理大整数运算时，直接使用内置的数据类型可能会导致溢出，因此需要使用字符串或数组来存储大整数，并逐位进行运算。本文将介绍如何使用C++实现高精度除法。 代码实现以下是一个实现高精度除法的完整C++代码示例： 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; div(vector&lt;int&gt; a, int b, int &amp;r) { vector&lt;int&gt; c; r = 0; for (int i = a.size()-1; i &gt;= 0; i--) { r = r*10 + a[i]; c.push_back(r / b); r = r % b; } reverse(c.begin(), c.end()); return c;}int main() { string a; int b; cin &gt;&gt; a &gt;&gt; b; vector&lt;int&gt; A; for (int i = a.size() - 1; i &gt;= 0; i--) { A.push_back(a[i] - '0'); } int r = 0; auto C = div(A, b, r); for (int i = C.size() - 1; i &gt;= 0; i--) { printf(&quot;%d&quot;, C[i]); } cout &lt;&lt; endl &lt;&lt; r &lt;&lt; endl; return 0;} 示例输入输出以下是一些示例输入和对应的输出，帮助理解代码的工作原理。 示例 1输入： 121234567890123456789012345 输出： 1210000540890046170 示例 2输入： 1298765432109876543210123456789 输出： 1280000000450000003698765432 示例 3输入： 1210000000000000000000999999999 输出： 12100000000011 代码说明输入处理： 使用字符串 a 存储输入的大整数。 将字符串转换为倒序存储的整数数组 A。 除法实现： 函数 div 实现大整数与单个整数的逐位除法，并计算余数。 主函数逻辑： 将字符串转换为整数数组，并进行逐位除法计算。 输出结果并打印余数。","link":"/2024/05/30/%E9%AB%98%E7%B2%BE%E5%BA%A6%E9%99%A4%E6%B3%95/"},{"title":"双指针基础-字符串处理实现","text":"字符串处理实现在处理字符串时，可以使用C++中的字符串操作库进行各种处理。本文将介绍如何使用C++实现简单的字符串处理。 代码实现以下是一个实现字符串处理的完整C++代码示例： 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;cstring&gt; // 包含c字符串操作库using namespace std;int main(){ char str[1000]; cin.getline(str, 1000); // 使用cin.getline替代gets int n = strlen(str); for (int i = 0; i &lt; n; i++) { int j = i; while (j &lt; n &amp;&amp; str[j] != ' ') j++; for (int k = i; k &lt; j; k++) cout &lt;&lt; str[k]; cout &lt;&lt; endl; i = j; } return 0;} 示例输入输出以下是一些示例输入和对应的输出，帮助理解代码的工作原理。 示例 1输入： 1hello world 输出： 12helloworld 示例 2输入： 1this is a test 输出： 1234thisisatest 示例 3输入： 1C++ string processing example 输出： 1234C++stringprocessingexample 代码说明输入处理： 使用 cin.getline 函数读取整行输入字符串，避免使用不安全的 gets 函数。 使用 strlen 函数获取字符串长度。 字符串处理实现： 遍历输入字符串，找到每个单词，并逐个输出。 主函数逻辑： 读取输入字符串并获取其长度。 遍历字符串，通过空格分隔单词，并逐行输出每个单词。","link":"/2024/06/01/%E5%8F%8C%E6%8C%87%E9%92%88%E5%9F%BA%E7%A1%80/"},{"title":"前缀和","text":"前缀和实现在处理数组区间求和时，可以使用前缀和技术来提高效率。本文将介绍如何使用C++实现前缀和。 代码实现以下是一个实现前缀和的完整C++代码示例： 1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;#define N 100010long long f[N];int n, m, t, x, y;int main() { scanf(&quot;%d %d&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= n; ++i) { scanf(&quot;%d&quot;, &amp;t); f[i] = f[i - 1] + t; } while(m--) { scanf(&quot;%d %d&quot;, &amp;x, &amp;y); printf(&quot;%lld&quot;, f[y] - f[x - 1]); } return 0;} 示例输入输出以下是一些示例输入和对应的输出，帮助理解代码的工作原理。 示例 1输入： 123455 31 2 3 4 51 32 41 5 输出： 1236915 示例 2输入： 12346 21 1 1 1 1 11 63 5 输出： 1263 示例 3输入： 1234 110 20 30 402 3 输出： 150 代码说明输入处理： 使用 scanf 函数读取数组长度 n 和查询次数 m。 读取数组元素，并计算前缀和存储在数组 f 中。 前缀和实现： 通过累加前缀和数组 f，使 f[i] 表示前 i 个元素的和。 对于每个查询，计算并输出区间和 f[y] - f[x - 1]。 主函数逻辑： 读取输入数据并计算前缀和数组。 处理每个查询，输出对应的区间和。","link":"/2024/06/01/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"title":"高级前缀和","text":"高级前缀和实现在处理大范围坐标的区间求和时，可以使用离散化技术和前缀和结合来提高效率。本文将介绍如何使用C++实现这一方法。 代码实现以下是一个实现高级前缀和的完整C++代码示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;iostream&gt;using namespace std;#define ios ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)#include&lt;vector&gt;#include&lt;algorithm&gt;typedef pair&lt;int,int&gt; PII; const int N=300010;int a[N];//离散后的坐标及对应的值int s[N];//前缀和数组vector&lt;int&gt;alls;//记录需要的坐标vector&lt;PII&gt;add,question;int find(int x)//找离散后的坐标{ int l=0,r=alls.size()-1; while(l&lt;r) { int mid=l+r&gt;&gt;1; if(alls[mid]&gt;=x)r=mid; else l=mid+1; } return r+1; //找到第一个大于等于自己的数}int main(){ ios; int m,n; cin&gt;&gt;m&gt;&gt;n; for(int i=0;i&lt;m;i++) { int b,c; cin&gt;&gt;b&gt;&gt;c; alls.push_back(b); add.push_back({b,c}); } for(int i=0;i&lt;n;i++) { int b,c; cin&gt;&gt;b&gt;&gt;c; alls.push_back(b); alls.push_back(c); question.push_back({b,c}); } sort(alls.begin(),alls.end()); alls.erase(unique(alls.begin(),alls.end()),alls.end()); // 离散化并执行增加数值的操作 for(auto x:add) { int h=find(x.first); a[h]+=x.second; } // 构造前缀和数组 for(int i=1;i&lt;=alls.size();i++) s[i]=s[i-1]+a[i]; // 处理查询 for(auto x:question) { int h=find(x.first); int t=find(x.second); cout&lt;&lt;s[t]-s[h-1]&lt;&lt;&quot;&quot;; } return 0;} 示例输入输出以下是一些示例输入和对应的输出，帮助理解代码的工作原理。 示例 1输入： 1234563 21 22 34 51 22 4 输出： 1258 示例 2输入： 123456784 31 12 23 34 41 32 41 4 输出： 1236910 示例 3输入： 123452 2100 1200 2100 200150 250 输出： 1232 代码说明输入处理： 使用 cin 函数读取操作数 m 和查询数 n。 读取操作和查询的坐标，存储在对应的向量中，并记录所有需要的坐标。 离散化和前缀和实现： 通过排序和去重对坐标进行离散化。 使用离散化后的坐标构造前缀和数组。 主函数逻辑： 读取输入数据并进行离散化处理。 构造前缀和数组，并处理每个查询，输出对应的区间和。","link":"/2024/06/02/%E5%89%8D%E7%BC%80%E5%92%8C-1/"}],"tags":[{"name":"Computer","slug":"Computer","link":"/tags/Computer/"},{"name":"日常","slug":"日常","link":"/tags/%E6%97%A5%E5%B8%B8/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"}],"categories":[],"pages":[]}