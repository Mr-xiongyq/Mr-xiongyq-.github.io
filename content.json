{"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2024/03/17/hello-world/"},{"title":"First_blog","text":"你好，这是我的第一条博客","link":"/2024/03/17/First-blog/"},{"title":"快速排序(quick_sort)","text":"题目描述给定你一个长度为 n 的整数数列。请你使用快速排序对这个数列按照从小到大进行排序，并将排好序的数列按顺序输出。 输入格式输入共两行，第一行包含整数 n。第二行包含 n 个整数（所有整数均在 1∼109 范围内），表示整个数列。 输出格式输出共一行，包含 n 个整数，表示排好序的数列。 数据范围1 ≤ n ≤ 100000 样例输入样例：1253 1 2 4 5 输出样例：11 2 3 4 5 C++ 代码算法1：使用手写快速排序123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;#define N 100005int q[N], n;void quick_sort(int l, int r) { if(l &gt;= r) return ; int i = l - 1, j = r + 1; int x = q[l + r &gt;&gt; 1]; while(i &lt; j) { do ++i; while(q[i] &lt; x); do --j; while(q[j] &gt; x); if(i &lt; j) swap(q[i], q[j]); } quick_sort(l, j); quick_sort(j + 1, r);}int main() { scanf(&quot;%d&quot;,&amp;n); for(int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;,q+i); quick_sort(1, n); for(int i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;,q[i]); return 0;} 算法2：(c++STL) O(nlogn) 用algorithm库的sort函数1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;#define N 100005int q[N], n;int main() { scanf(&quot;%d&quot;,&amp;n); for(int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;,q+i); sort(q + 1, q + 1 + n); // STL yyds!!! for(int i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;,q[i]); return 0;}","link":"/2024/05/27/quick-sort/"},{"title":"归并排序(merge_sort)","text":"题目描述给定你一个长度为 n 的整数数列。请你使用归并排序对这个数列按照从小到大进行排序，并将排好序的数列按顺序输出。 输入格式输入共两行，第一行包含整数 n。第二行包含 n 个整数（所有整数均在 1∼109 范围内），表示整个数列。 输出格式输出共一行，包含 n 个整数，表示排好序的数列。 数据范围1 ≤ n ≤ 100000 样例输入样例：1253 1 2 4 5 输出样例：11 2 3 4 5 算法1 (排序) O(nlogn)归并排序板子，先分组，再组合（merge） C++ 代码1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;#define N 100005int n, q[N];void merge_sort(int q[], int l, int r) { if (l &gt;= r) return; int mid = (l + r) &gt;&gt; 1; merge_sort(q, l, mid); merge_sort(q, mid + 1, r); int temp[N]; int k = 0; int x = l, y = mid + 1; while (x &lt;= mid &amp;&amp; y &lt;= r) { if (q[x] &lt;= q[y]) temp[++k] = q[x++]; else temp[++k] = q[y++]; } while (x &lt;= mid) temp[++k] = q[x++]; while (y &lt;= r) temp[++k] = q[y++]; for (int i = 1, j = l; j &lt;= r; ++i, ++j) q[j] = temp[i];}int main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, q + i); merge_sort(q, 1, n); for (int i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;, q[i]); return 0;}","link":"/2024/05/27/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-merge-sort/"},{"title":"整数二分(besearch)","text":"题目描述给定一个按照升序排列的长度为 n 的整数数组，以及 q 个查询。对于每个查询，返回一个元素 k 的起始位置和终止位置（位置从 0 开始计数）。如果数组中不存在该元素，则返回 -1 -1。 输入格式 第一行包含整数 n 和 q，表示数组长度和询问个数。 第二行包含 n 个整数（均在 1∼10000 范围内），表示完整数组。 接下来 q 行，每行包含一个整数 k，表示一个询问元素。 输出格式共 q 行，每行包含两个整数，表示所求元素的起始位置和终止位置。如果数组中不存在该元素，则返回 -1 -1。 数据范围 1≤n≤100000 1≤q≤10000 1≤k≤10000 样例输入样例：123456 31 2 2 3 3 4345 输出样例：1233 45 5-1 -1 算法1(二分) O(nlogn)枚举左端点和右端点 C++ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;using namespace std;#define N 1000010int n, k, q, a[N];// 查找元素q在数组a中的首次和最后一次出现的位置void bearch(int q) { // leftans和rightans用于存储结果，初始化为最大值和最小值 int leftans = INT_MAX, rightans = INT_MIN; int l = 0, r = n - 1; // 找到元素q的首次出现位置 while (l &lt; r) { int mid = (l + r) &gt;&gt; 1; // 等价于 (l + r) / 2 if (a[mid] &gt;= q) r = mid; else l = mid + 1; } // 如果在数组a中没有找到元素q，输出-1 -1 if (a[l] != q) { printf(&quot;-1 -1\\n&quot;); return; } // 输出元素q的首次出现位置 printf(&quot;%d &quot;, l); // 重置左右边界，准备查找最后一次出现位置 l = 0, r = n - 1; // 找到元素q的最后一次出现位置 while (l &lt; r) { int mid = (l + r + 1) &gt;&gt; 1; // 等价于 (l + r + 1) / 2 if (a[mid] &lt;= q) l = mid; else r = mid - 1; } // 输出元素q的最后一次出现位置 printf(&quot;%d\\n&quot;, l); return;}int main() { // 输入数组长度n和查询次数k scanf(&quot;%d %d&quot;, &amp;n, &amp;k); // 输入数组元素 for (int i = 0; i &lt; n; ++i) scanf(&quot;%d&quot;, a + i); // 对每个查询执行bearch函数 while (k--) { scanf(&quot;%d&quot;, &amp;q); bearch(q); } return 0;} 算法2(upperbound 和 lowerbound) O(nlogn)STL 大法好！！！ 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;#define N 1000010int n, k, q, a[N];int main() { scanf(&quot;%d %d&quot;, &amp;n, &amp;k); for (int i = 0; i &lt; n; ++i) scanf(&quot;%d&quot;,a + i); while (k--) { scanf(&quot;%d&quot;, &amp;q); int t = lower_bound(a, a + n, q) - a; if (t == n || a[t] != q) { puts(&quot;-1 -1&quot;); continue; } printf(&quot;%d &quot;, t); t = upper_bound(a, a + n, q) - a; printf(&quot;%d\\n&quot;, t - 1); } return 0;}","link":"/2024/05/28/%E6%95%B4%E6%95%B0%E4%BA%8C%E5%88%86/"},{"title":"数的三次方根","text":"题目描述给定一个浮点数 n，求它的三次方根。 输入格式共一行，包含一个浮点数 n。 输出格式共一行，包含一个浮点数，表示问题的解。 注意，结果保留 6 位小数。 数据范围 −10000≤n≤10000 样例输入样例：11000.00 输出样例：110.000000 算法1(二分) O(logn)小数二分 C++ 代码123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;double x;double bsearch(double x) { double l = -1e3, r = 1e3; while(r - l &gt; 1e-8) { //取保留位数多2位,如:保留一位小数,写1e-3 double mid = (l + r) / 2; if(mid * mid * mid &gt;= x) r = mid; else l = mid; } return l;}int main() { cin &gt;&gt; x; printf(&quot;%.6lf&quot;,bsearch(x)); return 0;}","link":"/2024/05/28/%E6%95%B0%E7%9A%84%E4%B8%89%E6%AC%A1%E6%96%B9%E6%A0%B9/"},{"title":"高精度乘法","text":"高精度乘法实现在处理大整数运算时，直接使用内置的数据类型可能会导致溢出，因此需要使用字符串或数组来存储大整数，并逐位进行运算。本文将介绍如何使用C++实现高精度乘法。 代码实现以下是一个实现高精度乘法的完整C++代码示例： 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; mul(vector&lt;int&gt; a, int b) { vector&lt;int&gt; c; int t = 0; for (int i = 0; i &lt; a.size(); i++) { t += a[i] * b; c.push_back(t % 10); t = t / 10; } while (t) { c.push_back(t % 10); t = t / 10; } return c;}int main() { string a; int b; cin &gt;&gt; a &gt;&gt; b; vector&lt;int&gt; A; for (int i = a.size() - 1; i &gt;= 0; i--) { A.push_back(a[i] - '0'); } auto C = mul(A, b); for (int i = C.size() - 1; i &gt;= 0; i--) { printf(&quot;%d&quot;, C[i]); } return 0;} 示例输入输出以下是一些示例输入和对应的输出，帮助理解代码的工作原理。 示例 1输入： 12123456789012345678909 输出： 1111111110111111110010 示例 2输入： 12987654321098765432108 输出： 1790123456879012345680 示例 3输入： 12999999999999999999995 输出： 1499999999999999999995 代码说明输入处理： 使用字符串 a 存储输入的大整数。 将字符串转换为倒序存储的整数数组 A。 乘法实现： 函数 mul 实现大整数与单个整数的逐位乘法，并处理进位。 主函数逻辑： 将字符串转换为整数数组，并进行逐位乘法计算。 逆序输出结果。","link":"/2024/05/30/%E9%AB%98%E7%B2%BE%E5%BA%A6%E4%B9%98%E6%B3%95/"},{"title":"高精度减法","text":"高精度减法实现在处理大整数运算时，直接使用内置的数据类型可能会导致溢出，因此需要使用字符串或数组来存储大整数，并逐位进行运算。本文将介绍如何使用C++实现高精度减法。 代码实现以下是一个实现高精度减法的完整C++代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; a, b; // 存储大整数string s1, s2; // 存储输入的两个大整数字符串int t;vector&lt;int&gt; sub(vector&lt;int&gt; a, vector&lt;int&gt; b) { vector&lt;int&gt; c; int t = 0; for(int i = 0; i &lt; a.size(); ++i) { a[i] -= t; if(i &lt; b.size()) a[i] -= b[i]; if(a[i] &lt; 0) t = 1; else t = 0; c.push_back((a[i] + 10) % 10); } while(c.size() &gt; 1 &amp;&amp; c.back() == 0) c.pop_back(); return c;}bool Max(vector&lt;int&gt; a, vector&lt;int&gt; b) { if(a.size() &lt; b.size()) return true; if(a.size() &gt; b.size()) return false; for(int i = a.size() - 1; i &gt;= 0; --i) if(a[i] &gt; b[i]) return false; else if(a[i] &lt; b[i]) return true; return 0;}int main() { cin &gt;&gt; s1 &gt;&gt; s2; for(int i = s1.size() - 1; i &gt;= 0; --i) a.push_back(s1[i] - '0'); for(int i = s2.size() - 1; i &gt;= 0; --i) b.push_back(s2[i] - '0'); if(Max(a, b) == true) { printf(&quot;-&quot;); auto c = sub(b, a); for(int i = c.size() - 1; i &gt;= 0; --i) printf(&quot;%d&quot;, c[i]); } else { auto c = sub(a, b); for(int i = c.size() - 1; i &gt;= 0; --i) printf(&quot;%d&quot;, c[i]); } return 0;} 示例输入输出以下是一些示例输入和对应的输出，帮助理解代码的工作原理。 示例 1输入： 121234567890123456789098765432109876543210 输出： 1-86419753208641975320 示例 2输入： 129876543210987654321012345678901234567890 输出： 186419753208641975320 示例 3输入： 125000000000000000000050000000000000000000 输出： 10 代码说明输入处理： 使用字符串 s1 和 s2 分别存储输入的两个大整数。 将字符串转换为倒序存储的整数数组 a 和 b。 减法实现： 函数 sub 实现两个大整数的逐位减法，考虑借位情况。 函数 Max 用于比较两个大整数的大小，确定是否需要输出负号。 主函数逻辑： 根据 Max 函数的结果，确定是 a - b 还是 b - a。 输出结果时，如果需要，先输出负号，再输出结果。","link":"/2024/05/30/%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%87%8F%E6%B3%95/"},{"title":"高精度加法","text":"高精度加法实现在处理大整数运算时，直接使用内置的数据类型可能会导致溢出，因此需要使用字符串或数组来存储大整数，并逐位进行运算。本文将介绍如何使用C++实现高精度加法。 代码实现以下是一个实现高精度加法的完整C++代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt; // 包含所有标准库的头文件using namespace std;vector&lt;int&gt; a; // 存储第一个大整数vector&lt;int&gt; b; // 存储第二个大整数string s1, s2; // 存储输入的两个大整数字符串// 实现两个大整数的加法函数vector&lt;int&gt; add(vector&lt;int&gt; a, vector&lt;int&gt; b) { if (a.size() &lt; b.size()) return add(b, a); // 确保 a 的长度大于或等于 b vector&lt;int&gt; c; // 存储结果的向量 int t = 0; // 进位 // 遍历较长的向量 a for (int i = 0; i &lt; a.size(); ++i) { t += a[i]; // 累加 a 的当前位 if (i &lt; b.size()) t += b[i]; // 如果 b 还有对应的位，则累加 b 的当前位 c.push_back(t % 10); // 将当前位的结果存入 c t /= 10; // 更新进位 } // 如果有剩余的进位，则加入结果 if (t) c.push_back(t); return c;}int main() { // 读取两个大整数的字符串 cin &gt;&gt; s1 &gt;&gt; s2; // 将字符串转换为向量，低位在前 for (int i = s1.size() - 1; i &gt;= 0; --i) a.push_back(s1[i] - '0'); for (int i = s2.size() - 1; i &gt;= 0; --i) b.push_back(s2[i] - '0'); //在C++中，字符（char）和整数（int）之间有一定的对应关系。具体来说，字符 '0' 到 '9' 的ASCII值分别是48到57。为了将字符 '0' 到 '9' 转换为对应的整数0到9，需要减去字符 '0' 的ASCII值。这是因为字符 '0' 的ASCII值是48，所以减去48就得到了对应的整数值。 // 计算两个向量的和 auto ans = add(a, b); // 逆序输出结果 for (int i = ans.size() - 1; i &gt;= 0; --i) printf(&quot;%d&quot;, ans[i]); return 0;} 示例输入输出以下是一些示例输入和对应的输出，帮助理解代码的工作原理。 示例 1输入： 121234567890123456789098765432109876543210 输出： 1111111111011111111100 示例 2输入： 125000000000000000000050000000000000000000 输出： 1100000000000000000000 示例 3输入： 12999999999999999999991 输出： 1100000000000000000000 代码说明输入处理： 使用字符串 s1 和 s2 分别存储输入的两个大整数。 将字符串转换为倒序存储的整数数组 a 和 b。 加法实现： 函数 add 实现两个大整数的逐位加法，考虑进位情况。 主函数逻辑： 将两个字符串转换为整数数组，并确保 a 的长度大于或等于 b。 计算两个向量的和，并逆序输出结果。","link":"/2024/05/30/%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8A%A0%E6%B3%95/"},{"title":"高精度除法","text":"高精度除法实现在处理大整数运算时，直接使用内置的数据类型可能会导致溢出，因此需要使用字符串或数组来存储大整数，并逐位进行运算。本文将介绍如何使用C++实现高精度除法。 代码实现以下是一个实现高精度除法的完整C++代码示例： 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; div(vector&lt;int&gt; a, int b, int &amp;r) { vector&lt;int&gt; c; r = 0; for (int i = a.size()-1; i &gt;= 0; i--) { r = r*10 + a[i]; c.push_back(r / b); r = r % b; } reverse(c.begin(), c.end()); return c;}int main() { string a; int b; cin &gt;&gt; a &gt;&gt; b; vector&lt;int&gt; A; for (int i = a.size() - 1; i &gt;= 0; i--) { A.push_back(a[i] - '0'); } int r = 0; auto C = div(A, b, r); for (int i = C.size() - 1; i &gt;= 0; i--) { printf(&quot;%d&quot;, C[i]); } cout &lt;&lt; endl &lt;&lt; r &lt;&lt; endl; return 0;} 示例输入输出以下是一些示例输入和对应的输出，帮助理解代码的工作原理。 示例 1输入： 121234567890123456789012345 输出： 1210000540890046170 示例 2输入： 1298765432109876543210123456789 输出： 1280000000450000003698765432 示例 3输入： 1210000000000000000000999999999 输出： 12100000000011 代码说明输入处理： 使用字符串 a 存储输入的大整数。 将字符串转换为倒序存储的整数数组 A。 除法实现： 函数 div 实现大整数与单个整数的逐位除法，并计算余数。 主函数逻辑： 将字符串转换为整数数组，并进行逐位除法计算。 输出结果并打印余数。","link":"/2024/05/30/%E9%AB%98%E7%B2%BE%E5%BA%A6%E9%99%A4%E6%B3%95/"},{"title":"双指针基础-字符串处理实现","text":"字符串处理实现在处理字符串时，可以使用C++中的字符串操作库进行各种处理。本文将介绍如何使用C++实现简单的字符串处理。 代码实现以下是一个实现字符串处理的完整C++代码示例： 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;cstring&gt; // 包含c字符串操作库using namespace std;int main(){ char str[1000]; cin.getline(str, 1000); // 使用cin.getline替代gets int n = strlen(str); for (int i = 0; i &lt; n; i++) { int j = i; while (j &lt; n &amp;&amp; str[j] != ' ') j++; for (int k = i; k &lt; j; k++) cout &lt;&lt; str[k]; cout &lt;&lt; endl; i = j; } return 0;} 示例输入输出以下是一些示例输入和对应的输出，帮助理解代码的工作原理。 示例 1输入： 1hello world 输出： 12helloworld 示例 2输入： 1this is a test 输出： 1234thisisatest 示例 3输入： 1C++ string processing example 输出： 1234C++stringprocessingexample 代码说明输入处理： 使用 cin.getline 函数读取整行输入字符串，避免使用不安全的 gets 函数。 使用 strlen 函数获取字符串长度。 字符串处理实现： 遍历输入字符串，找到每个单词，并逐个输出。 主函数逻辑： 读取输入字符串并获取其长度。 遍历字符串，通过空格分隔单词，并逐行输出每个单词。","link":"/2024/06/01/%E5%8F%8C%E6%8C%87%E9%92%88%E5%9F%BA%E7%A1%80/"},{"title":"前缀和","text":"前缀和实现在处理数组区间求和时，可以使用前缀和技术来提高效率。本文将介绍如何使用C++实现前缀和。 代码实现以下是一个实现前缀和的完整C++代码示例： 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;#define N 100010long long f[N];int n, m, t, x, y;int main() { scanf(&quot;%d %d&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= n; ++i) { scanf(&quot;%d&quot;, &amp;t); f[i] = f[i - 1] + t; } while(m--) { scanf(&quot;%d %d&quot;, &amp;x, &amp;y); printf(&quot;%lld&quot;, f[y] - f[x - 1]); } return 0;} 示例输入输出以下是一些示例输入和对应的输出，帮助理解代码的工作原理。 示例 1输入： 123455 31 2 3 4 51 32 41 5 输出： 1236915 示例 2输入： 12346 21 1 1 1 1 11 63 5 输出： 1263 示例 3输入： 1234 110 20 30 402 3 输出： 150 代码说明输入处理： 使用 scanf 函数读取数组长度 n 和查询次数 m。 读取数组元素，并计算前缀和存储在数组 f 中。 前缀和实现： 通过累加前缀和数组 f，使 f[i] 表示前 i 个元素的和。 对于每个查询，计算并输出区间和 f[y] - f[x - 1]。 主函数逻辑： 读取输入数据并计算前缀和数组。 处理每个查询，输出对应的区间和。","link":"/2024/06/01/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"title":"高级前缀和","text":"高级前缀和实现在处理大范围坐标的区间求和时，可以使用离散化技术和前缀和结合来提高效率。本文将介绍如何使用C++实现这一方法。 题目假定有一个无限长的数轴，数轴上每个坐标都是0。现在，我们首先进行n次操作，每次操作将某一位置x上的数加c。接下来，进行m次询问，每个询问包含两个整数l和r，你需要求出在区间[l,r]之间所有数的和。 输入格式第一行包含两个整数n、m。接下来n行，每行包括两个整数x和c。再接下来里m行，每行包括两个整数l和r。 输出格式共m行，每行输入一个询问中所求得区间内数字和。 代码实现以下是一个实现高级前缀和的完整C++代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;iostream&gt;using namespace std;#define ios ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)#include&lt;vector&gt;#include&lt;algorithm&gt;typedef pair&lt;int,int&gt; PII; const int N=300010;int a[N]; // 离散化后的数组，用于存储离散化坐标对应的值int s[N]; // 前缀和数组，用于快速查询区间和vector&lt;int&gt; alls; // 用于存储所有需要离散化的坐标vector&lt;PII&gt; add, question; // add存储添加操作，question存储查询操作int find(int x) // 二分查找函数，找到x在alls中的位置（离散化后的坐标）{ int l=0, r=alls.size()-1; while(l &lt; r) { int mid = (l + r) &gt;&gt; 1; if(alls[mid] &gt;= x) r = mid; else l = mid + 1; } return r + 1; // 返回离散化后的坐标索引}int main(){ ios; // 优化输入输出 int m, n; cin &gt;&gt; m &gt;&gt; n; // 读取操作的数量，m是添加操作的数量，n是查询操作的数量 // 读取添加操作 for(int i = 0; i &lt; m; i++) { int b, c; cin &gt;&gt; b &gt;&gt; c; // 读取添加操作的坐标和值 alls.push_back(b); // 将坐标存入alls中 add.push_back({b, c}); // 将操作存入add中 } // 读取查询操作 for(int i = 0; i &lt; n; i++) { int b, c; cin &gt;&gt; b &gt;&gt; c; // 读取查询操作的区间起点和终点 alls.push_back(b); // 将查询区间的两个坐标都存入alls中 alls.push_back(c); question.push_back({b, c}); // 将查询操作存入question中 } // 离散化：对所有的坐标进行排序，并去重 sort(alls.begin(), alls.end()); alls.erase(unique(alls.begin(), alls.end()), alls.end()); // 离散化并执行添加操作 for(auto x : add) { int h = find(x.first); // 找到离散化后的坐标索引 a[h] += x.second; // 在离散化后的数组中进行添加操作 } // 构造前缀和数组 for(int i = 1; i &lt;= alls.size(); i++) s[i] = s[i - 1] + a[i]; // 处理查询操作 for(auto x : question) { int h = find(x.first); // 找到查询区间起点的离散化坐标 int t = find(x.second); // 找到查询区间终点的离散化坐标 cout &lt;&lt; s[t] - s[h - 1] &lt;&lt; &quot;&quot;; // 输出查询结果，即区间和 } return 0;} 示例输入输出以下是一些示例输入和对应的输出，帮助理解代码的工作原理。 示例 1输入： 1234563 21 22 34 51 22 4 输出： 1258 示例 2输入： 123456784 31 12 23 34 41 32 41 4 输出： 1236910 示例 3输入： 123452 2100 1200 2100 200150 250 输出： 1232 代码说明输入处理： 使用 cin 函数读取操作数 m 和查询数 n。 读取操作和查询的坐标，存储在对应的向量中，并记录所有需要的坐标。 离散化和前缀和实现： 通过排序和去重对坐标进行离散化。 使用离散化后的坐标构造前缀和数组。 主函数逻辑： 读取输入数据并进行离散化处理。 构造前缀和数组，并处理每个查询，输出对应的区间和。 当然可以。下面是一个具体的例子以及按照代码处理流程的解释： 输入示例假设输入如下： 1234563 21 52 63 71 32 3 输入解释 第1行：3 2 表示有3个添加操作和2个查询操作。 第2-4行：1 5，2 6，3 7 是3个添加操作，表示在坐标1加上5，在坐标2加上6，在坐标3加上7。 第5-6行：1 3，2 3 是2个查询操作，分别查询区间 [1, 3] 和 [2, 3] 的和。 按照代码处理流程 读取输入并存储操作： 12int m, n;cin &gt;&gt; m &gt;&gt; n; m = 3，n = 2。 123456for (int i = 0; i &lt; m; i++) { int b, c; cin &gt;&gt; b &gt;&gt; c; alls.push_back(b); add.push_back({b, c});} 处理添加操作，将坐标 b 存入 alls，并将操作 (b, c) 存入 add。 alls = [1, 2, 3]， add = [(1, 5), (2, 6), (3, 7)]。 1234567for (int i = 0; i &lt; n; i++) { int b, c; cin &gt;&gt; b &gt;&gt; c; alls.push_back(b); alls.push_back(c); question.push_back({b, c});} 处理查询操作，将区间起点和终点 b, c 存入 alls，并将操作 (b, c) 存入 question。 alls = [1, 2, 3, 1, 3, 2, 3]， question = [(1, 3), (2, 3)]。 离散化处理： 12sort(alls.begin(), alls.end());alls.erase(unique(alls.begin(), alls.end()), alls.end()); 对 alls 进行排序和去重。 alls = [1, 2, 3]。 执行添加操作： 1234for (auto x : add) { int h = find(x.first); a[h] += x.second;} 将添加操作应用到离散化后的数组 a 中。 find(1) = 1，find(2) = 2，find(3) = 3。 更新后 a 数组的变化： a = [0, 5, 6, 7]。 构建前缀和数组： 12for (int i = 1; i &lt;= alls.size(); i++) s[i] = s[i - 1] + a[i]; 构建前缀和数组 s。 前缀和数组 s： s = [0, 5, 11, 18]。 处理查询操作并输出结果： 12345for (auto x : question) { int h = find(x.first); int t = find(x.second); cout &lt;&lt; s[t] - s[h - 1] &lt;&lt; &quot; &quot;;} 处理查询操作并输出结果。 查询区间 [1, 3]： find(1) = 1，find(3) = 3， 结果：s[3] - s[0] = 18 - 0 = 18。 查询区间 [2, 3]： find(2) = 2，find(3) = 3， 结果：s[3] - s[1] = 18 - 5 = 13。 最终输出118 13 总结通过这个例子，我们可以看到代码是如何处理添加和查询操作的。代码通过离散化技术将原始坐标映射到较小的连续整数范围，从而在固定大小的数组上执行操作，这显著提高了处理效率。","link":"/2024/06/02/%E5%89%8D%E7%BC%80%E5%92%8C-1/"},{"title":"单链表","text":"题目：单链表的基本操作题目描述实现一个单链表，并支持以下三种操作： 将一个元素插入到链表的头部。 将一个元素插入到链表中指定元素的后面。 删除链表中指定元素的后一个元素。 链表初始为空。每个操作保证合法，且不会删除链表中不存在的元素。 输入格式第一行包含一个整数 m，表示操作的次数。 接下来 m 行，每行包含一个操作指令，具体形式如下： H x：将整数 x 插入到链表的头部。 D k：删除链表中第 k 个元素的后一个元素（k 从 1 开始）。 I k x：将整数 x 插入到链表中第 k 个元素的后面（k 从 1 开始）。 输出格式输出一行，表示最终链表中的所有元素，按顺序用空格隔开。 输入输出示例示例1输入 1234565H 1H 2I 2 3D 1I 1 4 输出 12 4 3 示例2输入 123454H 10H 20I 1 30D 2 输出 120 10 题目分析我们使用一个数组 e 存储链表的元素，数组 ne 存储每个节点的下一个节点的下标。head 存储链表头部节点的下标，idx 表示当前插入元素的下标。具体实现包括初始化链表、在头部插入元素、在指定位置插入元素，以及删除指定位置后的元素。 通过解析输入的操作指令，我们对链表进行相应的操作，最终输出链表中的所有元素。这段代码实现了一个简单的单链表操作，包括在头部插入节点、在某个节点后插入节点、删除某个节点后的节点以及遍历链表。 代码解释 定义常量和变量： 12const int N = 100010;int head, e[N], ne[N], idx; N 是数组的最大大小。 head 是链表的头指针。 e 数组存储节点的值。 ne 数组存储每个节点的下一个节点的索引。 idx 是当前节点的索引。 初始化函数： 1234void init() { head = -1; idx = 0;} 初始化链表，将 head 设为 -1 表示链表为空，idx 设为 0。 在头部插入节点： 123456void add_to_head(int x) { e[idx] = x; ne[idx] = head; head = idx; idx++;} 将值 x 插入到头部节点，更新头指针和 idx。 在节点 k 后插入节点： 123456void add(int k, int x) { e[idx] = x; ne[idx] = ne[k]; ne[k] = idx; idx++;} 在节点 k 后插入值 x 的新节点。 删除节点 k 后的节点： 123void remove(int k) { ne[k] = ne[ne[k]];} 删除节点 k 后的节点。 主函数： 123456789101112131415161718192021222324int main() { int m; cin &gt;&gt; m; init(); while (m--) { int k, x; char op; cin &gt;&gt; op; if (op == 'H') { cin &gt;&gt; x; add_to_head(x); } else if (op == 'D') { cin &gt;&gt; k; if (!k) head = ne[head]; remove(k - 1); } else { cin &gt;&gt; k &gt;&gt; x; add(k - 1, x); } } for (int i = head; i != -1; i = ne[i]) cout &lt;&lt; e[i] &lt;&lt; ' '; cout &lt;&lt; endl; return 0;} 读取操作数量 m。 初始化链表。 循环处理每个操作，根据操作类型执行相应的链表操作。 最后遍历并输出链表中的所有节点值。 处理流程示例假设输入如下： 1234565H 3H 2I 1 4D 2H 1 输入解释 第1行：5 表示有5个操作。 第2行：H 3 在头部插入值为3的节点。 第3行：H 2 在头部插入值为2的节点。 第4行：I 1 4 在第1个节点后插入值为4的节点。 第5行：D 2 删除第2个节点后的节点。 第6行：H 1 在头部插入值为1的节点。 按照代码处理流程 初始化链表： 12head = -1;idx = 0; 执行操作： 操作 H 3： 1add_to_head(3); 更新后 e = [3]，ne = [-1]，head = 0，idx = 1。 操作 H 2： 1add_to_head(2); 更新后 e = [3, 2]，ne = [-1, 0]，head = 1，idx = 2。 操作 I 1 4： 1add(0, 4); 更新后 e = [3, 2, 4]，ne = [2, 0, -1]，head = 1，idx = 3。 操作 D 2： 1remove(1); 更新后 ne = [2, -1, -1]。 操作 H 1： 1add_to_head(1); 更新后 e = [3, 2, 4, 1]，ne = [2, -1, -1, 1]，head = 3，idx = 4。 遍历并输出链表： 1for (int i = head; i != -1; i = ne[i]) cout &lt;&lt; e[i] &lt;&lt; ' '; 从头指针 head = 3 开始遍历，输出结果为： 11 2 总结通过这个例子，可以看到如何按照输入操作动态地更新链表，并最终输出链表的内容。每个操作都按照代码中的逻辑逐步进行，链表结构在每一步都进行了相应的更新和调整。","link":"/2024/06/04/%E5%8D%95%E9%93%BE%E8%A1%A8/"},{"title":"单调栈","text":"单调栈实现单调栈是一种常用的数据结构，用于解决一类特殊的栈问题。本文将介绍如何使用C++实现单调栈。 问题描述给定一个长度为 n 的数组，找出每个元素左边第一个比它小的数。如果不存在这样的元素，则输出 -1。 代码实现以下是一个实现单调栈的完整C++代码示例： 123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;const int N = 100010;int st[N], tt;int main(){ int n; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) { int x; cin &gt;&gt; x; while(tt &amp;&amp; st[tt] &gt;= x) tt--; if(tt) cout &lt;&lt; st[tt] &lt;&lt; &quot; &quot;; else cout &lt;&lt; -1 &lt;&lt; &quot; &quot;; st[++tt] = x; } return 0;} 示例输入输出以下是一些示例输入和对应的输出，帮助理解代码的工作原理。 示例 1输入： 1252 4 3 1 5 输出： 1-1 2 2 -1 1 示例 2输入： 1261 2 3 4 5 6 输出： 1-1 1 2 3 4 5 示例 3输入： 1266 5 4 3 2 1 输出： 1-1 -1 -1 -1 -1 -1 代码说明初始化单调栈： 定义数组 st 存储栈中的元素，tt 为栈顶指针。 处理输入数据： 读取输入的整数 n，表示数组的长度。 遍历输入的每个元素 x，维护一个单调递增的栈，输出每个元素左边第一个小于它的元素。 主函数逻辑： 初始化栈，读取输入数据，并按照单调栈的规则处理和输出结果。","link":"/2024/06/05/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"title":"栈","text":"","link":"/2024/06/04/%E6%A0%88/"},{"title":"滑动窗口","text":"滑动窗口实现滑动窗口是一种常用的算法技巧，用于在数组或列表上进行高效的区间操作。本文将介绍如何使用C++实现滑动窗口。 问题描述给定一个长度为 n 的数组和一个整数 k，找出每个长度为 k 的子数组的最小值和最大值。 代码实现以下是一个实现滑动窗口的完整C++代码示例： 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;const int N = 100010;int n, k;int a[N], q[N];int main(){ scanf(&quot;%d%d&quot;, &amp;n, &amp;k); for(int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;a[i]); int hh = 0, tt = -1; for(int i = 0; i &lt; n; i++) { // 判断队头是否已经滑出窗口 if(hh &lt;= tt &amp;&amp; i - k + 1 &gt; q[hh]) hh++; while(hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt--; q[++tt] = i; if(i &gt;= k - 1) printf(&quot;%d &quot;, a[q[hh]]); } puts(&quot;&quot;); hh = 0, tt = -1; for(int i = 0; i &lt; n; i++) { // 判断队头是否已经滑出窗口 if(hh &lt;= tt &amp;&amp; i - k + 1 &gt; q[hh]) hh++; while(hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i]) tt--; q[++tt] = i; if(i &gt;= k - 1) printf(&quot;%d &quot;, a[q[hh]]); } puts(&quot;&quot;); return 0;} 示例输入输出以下是一些示例输入和对应的输出，帮助理解代码的工作原理。 示例 1输入： 128 31 3 -1 -3 5 3 6 7 输出： 12-1 -3 -3 -3 3 33 3 5 5 6 7 示例 2输入： 125 22 1 2 4 3 输出： 121 1 2 32 2 4 4 示例 3输入： 126 49 3 5 1 6 7 输出： 121 1 19 6 6 代码说明初始化滑动窗口： 定义数组 a 存储输入的数组，q 用作滑动窗口的队列。 读取数组长度 n 和窗口大小 k。 处理输入数据： 读取输入的数组元素，维护两个滑动窗口，分别用于求最小值和最大值。 主函数逻辑： 初始化队列，处理输入数据，并按照滑动窗口的规则输出每个子数组的最小值和最大值。","link":"/2024/06/06/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"title":"KMP字符串匹配","text":"KMP匹配算法实现KMP（Knuth-Morris-Pratt）算法是一种用于在文本中查找模式的高效字符串匹配算法。本文将介绍如何使用C++实现KMP算法。 问题描述给定一个文本字符串和一个模式字符串，找出模式字符串在文本字符串中的所有出现位置。 代码实现以下是一个实现KMP匹配算法的完整C++代码示例： 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;const int N = 100010, M = 100010;int n, m;char p[N], s[M];int ne[N];int main(){ cin &gt;&gt; n &gt;&gt; p + 1 &gt;&gt; m &gt;&gt; s + 1; // 求 next 数组的过程 for(int i = 2, j = 0; i &lt;= n; i++){ while(j &amp;&amp; p[i] != p[j + 1]) j = ne[j]; if(p[i] == p[j + 1]) j++; ne[i] = j; } // KMP 匹配算法 for(int i = 1, j = 0; i &lt;= m; i++) { while(j &amp;&amp; s[i] != p[j + 1]) j = ne[j]; if(s[i] == p[j + 1]) j++; if(j == n) { printf(&quot;%d &quot;, i - n); j = ne[j]; } } return 0;} 示例输入输出以下是一些示例输入和对应的输出，帮助理解代码的工作原理。 示例 1输入： 15 ababa 9 abababababa 输出： 10 2 4 示例 2输入： 13 abc 10 abcabcabcabc 输出： 10 3 6 9 示例 3输入： 12 aa 6 aaaaaa 输出： 10 1 2 3 4 代码说明计算 next 数组： 通过遍历模式字符串 p，计算每个位置的最长公共前缀和后缀的长度，存储在数组 ne 中。 KMP 匹配算法： 遍历文本字符串 s，使用 ne 数组进行模式匹配，找到所有出现位置并输出。 主函数逻辑： 读取输入数据，计算 ne 数组，并使用 KMP 算法进行字符串匹配，输出所有匹配位置。 我们用一个具体的例子来解释KMP算法的实现过程，并展示详细的计算过程。 例子输入 模式串：ABCDABD 文本串：ABC ABCDAB ABCDABCDABDE 我们需要找到模式串在文本串中的所有出现位置。 计算过程1. 计算 next 数组模式串：ABCDABD长度：n = 7 初始化： 1ne[1] = 0; 计算next数组： i = 2, j = 0: p[2] != p[1]，保持 j = 0 ne[2] = j = 0 i = 3, j = 0: p[3] != p[1]，保持 j = 0 ne[3] = j = 0 i = 4, j = 0: p[4] != p[1]，保持 j = 0 ne[4] = j = 0 i = 5, j = 0: p[5] == p[1]，增加 j++ ne[5] = j = 1 i = 6, j = 1: p[6] != p[2]，回退 j = ne[1] = 0 p[6] != p[1]，保持 j = 0 ne[6] = j = 0 i = 7, j = 0: p[7] == p[1]，增加 j++ ne[7] = j = 1 最终的 next 数组： 1ne = [0, 0, 0, 0, 1, 0, 1] 2. KMP匹配过程文本串：ABC ABCDAB ABCDABCDABDE长度：m = 23 初始化： 1j = 0; 进行匹配： i = 1, j = 0: s[1] == p[1]，增加 j++ j = 1 i = 2, j = 1: s[2] == p[2]，增加 j++ j = 2 i = 3, j = 2: s[3] == p[3]，增加 j++ j = 3 i = 4, j = 3: s[4] == p[4]，增加 j++ j = 4 i = 5, j = 4: s[5] != p[5]，回退 j = ne[4] = 0 s[5] == p[1]，增加 j++ j = 1 i = 6, j = 1: s[6] == p[2]，增加 j++ j = 2 i = 7, j = 2: s[7] == p[3]，增加 j++ j = 3 i = 8, j = 3: s[8] == p[4]，增加 j++ j = 4 i = 9, j = 4: s[9] == p[5]，增加 j++ j = 5 i = 10, j = 5: s[10] == p[6]，增加 j++ j = 6 i = 11, j = 6: s[11] != p[7]，回退 j = ne[6] = 1 s[11] != p[2]，回退 j = ne[1] = 0 i = 12, j = 0: s[12] == p[1]，增加 j++ j = 1 i = 13, j = 1: s[13] == p[2]，增加 j++ j = 2 i = 14, j = 2: s[14] == p[3]，增加 j++ j = 3 i = 15, j = 3: s[15] == p[4]，增加 j++ j = 4 i = 16, j = 4: s[16] == p[5]，增加 j++ j = 5 i = 17, j = 5: s[17] == p[6]，增加 j++ j = 6 i = 18, j = 6: s[18] == p[7]，增加 j++ j = 7 匹配成功，输出 i - n = 18 - 7 = 11。回退 j = ne[7] = 1。 i = 19, j = 1: s[19] == p[2]，增加 j++ j = 2 i = 20, j = 2: s[20] == p[3]，增加 j++ j = 3 i = 21, j = 3: s[21] == p[4]，增加 j++ j = 4 i = 22, j = 4: s[22] == p[5]，增加 j++ j = 5 i = 23, j = 5: s[23] == p[6]，增加 j++ j = 6 匹配失败，结束匹配。 总结最终匹配输出位置为 11。","link":"/2024/06/06/KMP%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"},{"title":"队列","text":"","link":"/2024/06/06/%E9%98%9F%E5%88%97/"}],"tags":[{"name":"Computer","slug":"Computer","link":"/tags/Computer/"},{"name":"日常","slug":"日常","link":"/tags/%E6%97%A5%E5%B8%B8/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"字符串","slug":"字符串","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"categories":[],"pages":[]}