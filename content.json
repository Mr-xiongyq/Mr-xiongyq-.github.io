{"posts":[{"title":"First_blog","text":"你好，这是我的第一条博客","link":"/2024/03/17/First-blog/"},{"title":"KMP字符串匹配","text":"KMP匹配算法实现KMP（Knuth-Morris-Pratt）算法是一种用于在文本中查找模式的高效字符串匹配算法。本文将介绍如何使用C++实现KMP算法。 问题描述给定一个文本字符串和一个模式字符串，找出模式字符串在文本字符串中的所有出现位置。 代码实现以下是一个实现KMP匹配算法的完整C++代码示例： 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;const int N = 100010, M = 100010;int n, m;char p[N], s[M];int ne[N];int main(){ cin &gt;&gt; n &gt;&gt; p + 1 &gt;&gt; m &gt;&gt; s + 1; // 求 next 数组的过程 for(int i = 2, j = 0; i &lt;= n; i++){ while(j &amp;&amp; p[i] != p[j + 1]) j = ne[j]; if(p[i] == p[j + 1]) j++; ne[i] = j; } // KMP 匹配算法 for(int i = 1, j = 0; i &lt;= m; i++) { while(j &amp;&amp; s[i] != p[j + 1]) j = ne[j]; if(s[i] == p[j + 1]) j++; if(j == n) { printf(&quot;%d &quot;, i - n); j = ne[j]; } } return 0;} 示例输入输出以下是一些示例输入和对应的输出，帮助理解代码的工作原理。 示例 1输入： 15 ababa 9 abababababa 输出： 10 2 4 示例 2输入： 13 abc 10 abcabcabcabc 输出： 10 3 6 9 示例 3输入： 12 aa 6 aaaaaa 输出： 10 1 2 3 4 代码说明计算 next 数组： 通过遍历模式字符串 p，计算每个位置的最长公共前缀和后缀的长度，存储在数组 ne 中。 KMP 匹配算法： 遍历文本字符串 s，使用 ne 数组进行模式匹配，找到所有出现位置并输出。 主函数逻辑： 读取输入数据，计算 ne 数组，并使用 KMP 算法进行字符串匹配，输出所有匹配位置。 我们用一个具体的例子来解释KMP算法的实现过程，并展示详细的计算过程。 例子输入 模式串：ABCDABD 文本串：ABC ABCDAB ABCDABCDABDE 我们需要找到模式串在文本串中的所有出现位置。 计算过程1. 计算 next 数组模式串：ABCDABD长度：n = 7 初始化： 1ne[1] = 0; 计算next数组： i = 2, j = 0: p[2] != p[1]，保持 j = 0 ne[2] = j = 0 i = 3, j = 0: p[3] != p[1]，保持 j = 0 ne[3] = j = 0 i = 4, j = 0: p[4] != p[1]，保持 j = 0 ne[4] = j = 0 i = 5, j = 0: p[5] == p[1]，增加 j++ ne[5] = j = 1 i = 6, j = 1: p[6] != p[2]，回退 j = ne[1] = 0 p[6] != p[1]，保持 j = 0 ne[6] = j = 0 i = 7, j = 0: p[7] == p[1]，增加 j++ ne[7] = j = 1 最终的 next 数组： 1ne = [0, 0, 0, 0, 1, 0, 1] 2. KMP匹配过程文本串：ABC ABCDAB ABCDABCDABDE长度：m = 23 初始化： 1j = 0; 进行匹配： i = 1, j = 0: s[1] == p[1]，增加 j++ j = 1 i = 2, j = 1: s[2] == p[2]，增加 j++ j = 2 i = 3, j = 2: s[3] == p[3]，增加 j++ j = 3 i = 4, j = 3: s[4] == p[4]，增加 j++ j = 4 i = 5, j = 4: s[5] != p[5]，回退 j = ne[4] = 0 s[5] == p[1]，增加 j++ j = 1 i = 6, j = 1: s[6] == p[2]，增加 j++ j = 2 i = 7, j = 2: s[7] == p[3]，增加 j++ j = 3 i = 8, j = 3: s[8] == p[4]，增加 j++ j = 4 i = 9, j = 4: s[9] == p[5]，增加 j++ j = 5 i = 10, j = 5: s[10] == p[6]，增加 j++ j = 6 i = 11, j = 6: s[11] != p[7]，回退 j = ne[6] = 1 s[11] != p[2]，回退 j = ne[1] = 0 i = 12, j = 0: s[12] == p[1]，增加 j++ j = 1 i = 13, j = 1: s[13] == p[2]，增加 j++ j = 2 i = 14, j = 2: s[14] == p[3]，增加 j++ j = 3 i = 15, j = 3: s[15] == p[4]，增加 j++ j = 4 i = 16, j = 4: s[16] == p[5]，增加 j++ j = 5 i = 17, j = 5: s[17] == p[6]，增加 j++ j = 6 i = 18, j = 6: s[18] == p[7]，增加 j++ j = 7 匹配成功，输出 i - n = 18 - 7 = 11。回退 j = ne[7] = 1。 i = 19, j = 1: s[19] == p[2]，增加 j++ j = 2 i = 20, j = 2: s[20] == p[3]，增加 j++ j = 3 i = 21, j = 3: s[21] == p[4]，增加 j++ j = 4 i = 22, j = 4: s[22] == p[5]，增加 j++ j = 5 i = 23, j = 5: s[23] == p[6]，增加 j++ j = 6 匹配失败，结束匹配。 总结最终匹配输出位置为 11。","link":"/2024/06/06/KMP%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"},{"title":"快速排序(quick_sort)","text":"题目描述给定你一个长度为 n 的整数数列。请你使用快速排序对这个数列按照从小到大进行排序，并将排好序的数列按顺序输出。 输入格式输入共两行，第一行包含整数 n。第二行包含 n 个整数（所有整数均在 1∼109 范围内），表示整个数列。 输出格式输出共一行，包含 n 个整数，表示排好序的数列。 数据范围1 ≤ n ≤ 100000 样例输入样例：1253 1 2 4 5 输出样例：11 2 3 4 5 C++ 代码算法1：使用手写快速排序123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;#define N 100005int q[N], n;void quick_sort(int l, int r) { if(l &gt;= r) return ; int i = l - 1, j = r + 1; int x = q[l + r &gt;&gt; 1]; while(i &lt; j) { do ++i; while(q[i] &lt; x); do --j; while(q[j] &gt; x); if(i &lt; j) swap(q[i], q[j]); } quick_sort(l, j); quick_sort(j + 1, r);}int main() { scanf(&quot;%d&quot;,&amp;n); for(int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;,q+i); quick_sort(1, n); for(int i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;,q[i]); return 0;} 算法2：(c++STL) O(nlogn) 用algorithm库的sort函数1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;#define N 100005int q[N], n;int main() { scanf(&quot;%d&quot;,&amp;n); for(int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;,q+i); sort(q + 1, q + 1 + n); // STL yyds!!! for(int i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;,q[i]); return 0;}","link":"/2024/05/27/quick-sort/"},{"title":"高级前缀和","text":"高级前缀和实现在处理大范围坐标的区间求和时，可以使用离散化技术和前缀和结合来提高效率。本文将介绍如何使用C++实现这一方法。 题目假定有一个无限长的数轴，数轴上每个坐标都是0。现在，我们首先进行n次操作，每次操作将某一位置x上的数加c。接下来，进行m次询问，每个询问包含两个整数l和r，你需要求出在区间[l,r]之间所有数的和。 输入格式第一行包含两个整数n、m。接下来n行，每行包括两个整数x和c。再接下来里m行，每行包括两个整数l和r。 输出格式共m行，每行输入一个询问中所求得区间内数字和。 代码实现以下是一个实现高级前缀和的完整C++代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;iostream&gt;using namespace std;#define ios ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)#include&lt;vector&gt;#include&lt;algorithm&gt;typedef pair&lt;int,int&gt; PII; const int N=300010;int a[N]; // 离散化后的数组，用于存储离散化坐标对应的值int s[N]; // 前缀和数组，用于快速查询区间和vector&lt;int&gt; alls; // 用于存储所有需要离散化的坐标vector&lt;PII&gt; add, question; // add存储添加操作，question存储查询操作int find(int x) // 二分查找函数，找到x在alls中的位置（离散化后的坐标）{ int l=0, r=alls.size()-1; while(l &lt; r) { int mid = (l + r) &gt;&gt; 1; if(alls[mid] &gt;= x) r = mid; else l = mid + 1; } return r + 1; // 返回离散化后的坐标索引}int main(){ ios; // 优化输入输出 int m, n; cin &gt;&gt; m &gt;&gt; n; // 读取操作的数量，m是添加操作的数量，n是查询操作的数量 // 读取添加操作 for(int i = 0; i &lt; m; i++) { int b, c; cin &gt;&gt; b &gt;&gt; c; // 读取添加操作的坐标和值 alls.push_back(b); // 将坐标存入alls中 add.push_back({b, c}); // 将操作存入add中 } // 读取查询操作 for(int i = 0; i &lt; n; i++) { int b, c; cin &gt;&gt; b &gt;&gt; c; // 读取查询操作的区间起点和终点 alls.push_back(b); // 将查询区间的两个坐标都存入alls中 alls.push_back(c); question.push_back({b, c}); // 将查询操作存入question中 } // 离散化：对所有的坐标进行排序，并去重 sort(alls.begin(), alls.end()); alls.erase(unique(alls.begin(), alls.end()), alls.end()); // 离散化并执行添加操作 for(auto x : add) { int h = find(x.first); // 找到离散化后的坐标索引 a[h] += x.second; // 在离散化后的数组中进行添加操作 } // 构造前缀和数组 for(int i = 1; i &lt;= alls.size(); i++) s[i] = s[i - 1] + a[i]; // 处理查询操作 for(auto x : question) { int h = find(x.first); // 找到查询区间起点的离散化坐标 int t = find(x.second); // 找到查询区间终点的离散化坐标 cout &lt;&lt; s[t] - s[h - 1] &lt;&lt; &quot;&quot;; // 输出查询结果，即区间和 } return 0;} 示例输入输出以下是一些示例输入和对应的输出，帮助理解代码的工作原理。 示例 1输入： 1234563 21 22 34 51 22 4 输出： 1258 示例 2输入： 123456784 31 12 23 34 41 32 41 4 输出： 1236910 示例 3输入： 123452 2100 1200 2100 200150 250 输出： 1232 代码说明输入处理： 使用 cin 函数读取操作数 m 和查询数 n。 读取操作和查询的坐标，存储在对应的向量中，并记录所有需要的坐标。 离散化和前缀和实现： 通过排序和去重对坐标进行离散化。 使用离散化后的坐标构造前缀和数组。 主函数逻辑： 读取输入数据并进行离散化处理。 构造前缀和数组，并处理每个查询，输出对应的区间和。 当然可以。下面是一个具体的例子以及按照代码处理流程的解释： 输入示例假设输入如下： 1234563 21 52 63 71 32 3 输入解释 第1行：3 2 表示有3个添加操作和2个查询操作。 第2-4行：1 5，2 6，3 7 是3个添加操作，表示在坐标1加上5，在坐标2加上6，在坐标3加上7。 第5-6行：1 3，2 3 是2个查询操作，分别查询区间 [1, 3] 和 [2, 3] 的和。 按照代码处理流程 读取输入并存储操作： 12int m, n;cin &gt;&gt; m &gt;&gt; n; m = 3，n = 2。 123456for (int i = 0; i &lt; m; i++) { int b, c; cin &gt;&gt; b &gt;&gt; c; alls.push_back(b); add.push_back({b, c});} 处理添加操作，将坐标 b 存入 alls，并将操作 (b, c) 存入 add。 alls = [1, 2, 3]， add = [(1, 5), (2, 6), (3, 7)]。 1234567for (int i = 0; i &lt; n; i++) { int b, c; cin &gt;&gt; b &gt;&gt; c; alls.push_back(b); alls.push_back(c); question.push_back({b, c});} 处理查询操作，将区间起点和终点 b, c 存入 alls，并将操作 (b, c) 存入 question。 alls = [1, 2, 3, 1, 3, 2, 3]， question = [(1, 3), (2, 3)]。 离散化处理： 12sort(alls.begin(), alls.end());alls.erase(unique(alls.begin(), alls.end()), alls.end()); 对 alls 进行排序和去重。 alls = [1, 2, 3]。 执行添加操作： 1234for (auto x : add) { int h = find(x.first); a[h] += x.second;} 将添加操作应用到离散化后的数组 a 中。 find(1) = 1，find(2) = 2，find(3) = 3。 更新后 a 数组的变化： a = [0, 5, 6, 7]。 构建前缀和数组： 12for (int i = 1; i &lt;= alls.size(); i++) s[i] = s[i - 1] + a[i]; 构建前缀和数组 s。 前缀和数组 s： s = [0, 5, 11, 18]。 处理查询操作并输出结果： 12345for (auto x : question) { int h = find(x.first); int t = find(x.second); cout &lt;&lt; s[t] - s[h - 1] &lt;&lt; &quot; &quot;;} 处理查询操作并输出结果。 查询区间 [1, 3]： find(1) = 1，find(3) = 3， 结果：s[3] - s[0] = 18 - 0 = 18。 查询区间 [2, 3]： find(2) = 2，find(3) = 3， 结果：s[3] - s[1] = 18 - 5 = 13。 最终输出118 13 总结通过这个例子，我们可以看到代码是如何处理添加和查询操作的。代码通过离散化技术将原始坐标映射到较小的连续整数范围，从而在固定大小的数组上执行操作，这显著提高了处理效率。","link":"/2024/06/02/%E5%89%8D%E7%BC%80%E5%92%8C-1/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2024/03/17/hello-world/"},{"title":"双指针基础-字符串处理实现","text":"字符串处理实现在处理字符串时，可以使用C++中的字符串操作库进行各种处理。本文将介绍如何使用C++实现简单的字符串处理。 代码实现以下是一个实现字符串处理的完整C++代码示例： 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;cstring&gt; // 包含c字符串操作库using namespace std;int main(){ char str[1000]; cin.getline(str, 1000); // 使用cin.getline替代gets int n = strlen(str); for (int i = 0; i &lt; n; i++) { int j = i; while (j &lt; n &amp;&amp; str[j] != ' ') j++; for (int k = i; k &lt; j; k++) cout &lt;&lt; str[k]; cout &lt;&lt; endl; i = j; } return 0;} 示例输入输出以下是一些示例输入和对应的输出，帮助理解代码的工作原理。 示例 1输入： 1hello world 输出： 12helloworld 示例 2输入： 1this is a test 输出： 1234thisisatest 示例 3输入： 1C++ string processing example 输出： 1234C++stringprocessingexample 代码说明输入处理： 使用 cin.getline 函数读取整行输入字符串，避免使用不安全的 gets 函数。 使用 strlen 函数获取字符串长度。 字符串处理实现： 遍历输入字符串，找到每个单词，并逐个输出。 主函数逻辑： 读取输入字符串并获取其长度。 遍历字符串，通过空格分隔单词，并逐行输出每个单词。","link":"/2024/06/01/%E5%8F%8C%E6%8C%87%E9%92%88%E5%9F%BA%E7%A1%80/"},{"title":"单调栈","text":"单调栈实现单调栈是一种常用的数据结构，用于解决一类特殊的栈问题。本文将介绍如何使用C++实现单调栈。 问题描述给定一个长度为 n 的数组，找出每个元素左边第一个比它小的数。如果不存在这样的元素，则输出 -1。 代码实现以下是一个实现单调栈的完整C++代码示例： 123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;const int N = 100010;int st[N], tt;int main(){ int n; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) { int x; cin &gt;&gt; x; while(tt &amp;&amp; st[tt] &gt;= x) tt--; if(tt) cout &lt;&lt; st[tt] &lt;&lt; &quot; &quot;; else cout &lt;&lt; -1 &lt;&lt; &quot; &quot;; st[++tt] = x; } return 0;} 示例输入输出以下是一些示例输入和对应的输出，帮助理解代码的工作原理。 示例 1输入： 1252 4 3 1 5 输出： 1-1 2 2 -1 1 示例 2输入： 1261 2 3 4 5 6 输出： 1-1 1 2 3 4 5 示例 3输入： 1266 5 4 3 2 1 输出： 1-1 -1 -1 -1 -1 -1 代码说明初始化单调栈： 定义数组 st 存储栈中的元素，tt 为栈顶指针。 处理输入数据： 读取输入的整数 n，表示数组的长度。 遍历输入的每个元素 x，维护一个单调递增的栈，输出每个元素左边第一个小于它的元素。 主函数逻辑： 初始化栈，读取输入数据，并按照单调栈的规则处理和输出结果。","link":"/2024/06/05/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"title":"单链表","text":"题目：单链表的基本操作题目描述实现一个单链表，并支持以下三种操作： 将一个元素插入到链表的头部。 将一个元素插入到链表中指定元素的后面。 删除链表中指定元素的后一个元素。 链表初始为空。每个操作保证合法，且不会删除链表中不存在的元素。 输入格式第一行包含一个整数 m，表示操作的次数。 接下来 m 行，每行包含一个操作指令，具体形式如下： H x：将整数 x 插入到链表的头部。 D k：删除链表中第 k 个元素的后一个元素（k 从 1 开始）。 I k x：将整数 x 插入到链表中第 k 个元素的后面（k 从 1 开始）。 输出格式输出一行，表示最终链表中的所有元素，按顺序用空格隔开。 输入输出示例示例1输入 1234565H 1H 2I 2 3D 1I 1 4 输出 12 4 3 示例2输入 123454H 10H 20I 1 30D 2 输出 120 10 题目分析我们使用一个数组 e 存储链表的元素，数组 ne 存储每个节点的下一个节点的下标。head 存储链表头部节点的下标，idx 表示当前插入元素的下标。具体实现包括初始化链表、在头部插入元素、在指定位置插入元素，以及删除指定位置后的元素。 通过解析输入的操作指令，我们对链表进行相应的操作，最终输出链表中的所有元素。这段代码实现了一个简单的单链表操作，包括在头部插入节点、在某个节点后插入节点、删除某个节点后的节点以及遍历链表。 代码解释 定义常量和变量： 12const int N = 100010;int head, e[N], ne[N], idx; N 是数组的最大大小。 head 是链表的头指针。 e 数组存储节点的值。 ne 数组存储每个节点的下一个节点的索引。 idx 是当前节点的索引。 初始化函数： 1234void init() { head = -1; idx = 0;} 初始化链表，将 head 设为 -1 表示链表为空，idx 设为 0。 在头部插入节点： 123456void add_to_head(int x) { e[idx] = x; ne[idx] = head; head = idx; idx++;} 将值 x 插入到头部节点，更新头指针和 idx。 在节点 k 后插入节点： 123456void add(int k, int x) { e[idx] = x; ne[idx] = ne[k]; ne[k] = idx; idx++;} 在节点 k 后插入值 x 的新节点。 删除节点 k 后的节点： 123void remove(int k) { ne[k] = ne[ne[k]];} 删除节点 k 后的节点。 主函数： 123456789101112131415161718192021222324int main() { int m; cin &gt;&gt; m; init(); while (m--) { int k, x; char op; cin &gt;&gt; op; if (op == 'H') { cin &gt;&gt; x; add_to_head(x); } else if (op == 'D') { cin &gt;&gt; k; if (!k) head = ne[head]; remove(k - 1); } else { cin &gt;&gt; k &gt;&gt; x; add(k - 1, x); } } for (int i = head; i != -1; i = ne[i]) cout &lt;&lt; e[i] &lt;&lt; ' '; cout &lt;&lt; endl; return 0;} 读取操作数量 m。 初始化链表。 循环处理每个操作，根据操作类型执行相应的链表操作。 最后遍历并输出链表中的所有节点值。 处理流程示例假设输入如下： 1234565H 3H 2I 1 4D 2H 1 输入解释 第1行：5 表示有5个操作。 第2行：H 3 在头部插入值为3的节点。 第3行：H 2 在头部插入值为2的节点。 第4行：I 1 4 在第1个节点后插入值为4的节点。 第5行：D 2 删除第2个节点后的节点。 第6行：H 1 在头部插入值为1的节点。 按照代码处理流程 初始化链表： 12head = -1;idx = 0; 执行操作： 操作 H 3： 1add_to_head(3); 更新后 e = [3]，ne = [-1]，head = 0，idx = 1。 操作 H 2： 1add_to_head(2); 更新后 e = [3, 2]，ne = [-1, 0]，head = 1，idx = 2。 操作 I 1 4： 1add(0, 4); 更新后 e = [3, 2, 4]，ne = [2, 0, -1]，head = 1，idx = 3。 操作 D 2： 1remove(1); 更新后 ne = [2, -1, -1]。 操作 H 1： 1add_to_head(1); 更新后 e = [3, 2, 4, 1]，ne = [2, -1, -1, 1]，head = 3，idx = 4。 遍历并输出链表： 1for (int i = head; i != -1; i = ne[i]) cout &lt;&lt; e[i] &lt;&lt; ' '; 从头指针 head = 3 开始遍历，输出结果为： 11 2 总结通过这个例子，可以看到如何按照输入操作动态地更新链表，并最终输出链表的内容。每个操作都按照代码中的逻辑逐步进行，链表结构在每一步都进行了相应的更新和调整。","link":"/2024/06/04/%E5%8D%95%E9%93%BE%E8%A1%A8/"},{"title":"归并排序(merge_sort)","text":"题目描述给定你一个长度为 n 的整数数列。请你使用归并排序对这个数列按照从小到大进行排序，并将排好序的数列按顺序输出。 输入格式输入共两行，第一行包含整数 n。第二行包含 n 个整数（所有整数均在 1∼109 范围内），表示整个数列。 输出格式输出共一行，包含 n 个整数，表示排好序的数列。 数据范围1 ≤ n ≤ 100000 样例输入样例：1253 1 2 4 5 输出样例：11 2 3 4 5 算法1 (排序) O(nlogn)归并排序板子，先分组，再组合（merge） C++ 代码1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;#define N 100005int n, q[N];void merge_sort(int q[], int l, int r) { if (l &gt;= r) return; int mid = (l + r) &gt;&gt; 1; merge_sort(q, l, mid); merge_sort(q, mid + 1, r); int temp[N]; int k = 0; int x = l, y = mid + 1; while (x &lt;= mid &amp;&amp; y &lt;= r) { if (q[x] &lt;= q[y]) temp[++k] = q[x++]; else temp[++k] = q[y++]; } while (x &lt;= mid) temp[++k] = q[x++]; while (y &lt;= r) temp[++k] = q[y++]; for (int i = 1, j = l; j &lt;= r; ++i, ++j) q[j] = temp[i];}int main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, q + i); merge_sort(q, 1, n); for (int i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;, q[i]); return 0;}","link":"/2024/05/27/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-merge-sort/"},{"title":"前缀和","text":"前缀和实现在处理数组区间求和时，可以使用前缀和技术来提高效率。本文将介绍如何使用C++实现前缀和。 代码实现以下是一个实现前缀和的完整C++代码示例： 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;#define N 100010long long f[N];int n, m, t, x, y;int main() { scanf(&quot;%d %d&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= n; ++i) { scanf(&quot;%d&quot;, &amp;t); f[i] = f[i - 1] + t; } while(m--) { scanf(&quot;%d %d&quot;, &amp;x, &amp;y); printf(&quot;%lld&quot;, f[y] - f[x - 1]); } return 0;} 示例输入输出以下是一些示例输入和对应的输出，帮助理解代码的工作原理。 示例 1输入： 123455 31 2 3 4 51 32 41 5 输出： 1236915 示例 2输入： 12346 21 1 1 1 1 11 63 5 输出： 1263 示例 3输入： 1234 110 20 30 402 3 输出： 150 代码说明输入处理： 使用 scanf 函数读取数组长度 n 和查询次数 m。 读取数组元素，并计算前缀和存储在数组 f 中。 前缀和实现： 通过累加前缀和数组 f，使 f[i] 表示前 i 个元素的和。 对于每个查询，计算并输出区间和 f[y] - f[x - 1]。 主函数逻辑： 读取输入数据并计算前缀和数组。 处理每个查询，输出对应的区间和。","link":"/2024/06/01/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"title":"整数二分(besearch)","text":"题目描述给定一个按照升序排列的长度为 n 的整数数组，以及 q 个查询。对于每个查询，返回一个元素 k 的起始位置和终止位置（位置从 0 开始计数）。如果数组中不存在该元素，则返回 -1 -1。 输入格式 第一行包含整数 n 和 q，表示数组长度和询问个数。 第二行包含 n 个整数（均在 1∼10000 范围内），表示完整数组。 接下来 q 行，每行包含一个整数 k，表示一个询问元素。 输出格式共 q 行，每行包含两个整数，表示所求元素的起始位置和终止位置。如果数组中不存在该元素，则返回 -1 -1。 数据范围 1≤n≤100000 1≤q≤10000 1≤k≤10000 样例输入样例：123456 31 2 2 3 3 4345 输出样例：1233 45 5-1 -1 算法1(二分) O(nlogn)枚举左端点和右端点 C++ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;using namespace std;#define N 1000010int n, k, q, a[N];// 查找元素q在数组a中的首次和最后一次出现的位置void bearch(int q) { // leftans和rightans用于存储结果，初始化为最大值和最小值 int leftans = INT_MAX, rightans = INT_MIN; int l = 0, r = n - 1; // 找到元素q的首次出现位置 while (l &lt; r) { int mid = (l + r) &gt;&gt; 1; // 等价于 (l + r) / 2 if (a[mid] &gt;= q) r = mid; else l = mid + 1; } // 如果在数组a中没有找到元素q，输出-1 -1 if (a[l] != q) { printf(&quot;-1 -1\\n&quot;); return; } // 输出元素q的首次出现位置 printf(&quot;%d &quot;, l); // 重置左右边界，准备查找最后一次出现位置 l = 0, r = n - 1; // 找到元素q的最后一次出现位置 while (l &lt; r) { int mid = (l + r + 1) &gt;&gt; 1; // 等价于 (l + r + 1) / 2 if (a[mid] &lt;= q) l = mid; else r = mid - 1; } // 输出元素q的最后一次出现位置 printf(&quot;%d\\n&quot;, l); return;}int main() { // 输入数组长度n和查询次数k scanf(&quot;%d %d&quot;, &amp;n, &amp;k); // 输入数组元素 for (int i = 0; i &lt; n; ++i) scanf(&quot;%d&quot;, a + i); // 对每个查询执行bearch函数 while (k--) { scanf(&quot;%d&quot;, &amp;q); bearch(q); } return 0;} 算法2(upperbound 和 lowerbound) O(nlogn)STL 大法好！！！ 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;#define N 1000010int n, k, q, a[N];int main() { scanf(&quot;%d %d&quot;, &amp;n, &amp;k); for (int i = 0; i &lt; n; ++i) scanf(&quot;%d&quot;,a + i); while (k--) { scanf(&quot;%d&quot;, &amp;q); int t = lower_bound(a, a + n, q) - a; if (t == n || a[t] != q) { puts(&quot;-1 -1&quot;); continue; } printf(&quot;%d &quot;, t); t = upper_bound(a, a + n, q) - a; printf(&quot;%d\\n&quot;, t - 1); } return 0;}","link":"/2024/05/28/%E6%95%B4%E6%95%B0%E4%BA%8C%E5%88%86/"},{"title":"数的三次方根","text":"题目描述给定一个浮点数 n，求它的三次方根。 输入格式共一行，包含一个浮点数 n。 输出格式共一行，包含一个浮点数，表示问题的解。 注意，结果保留 6 位小数。 数据范围 −10000≤n≤10000 样例输入样例：11000.00 输出样例：110.000000 算法1(二分) O(logn)小数二分 C++ 代码123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;double x;double bsearch(double x) { double l = -1e3, r = 1e3; while(r - l &gt; 1e-8) { //取保留位数多2位,如:保留一位小数,写1e-3 double mid = (l + r) / 2; if(mid * mid * mid &gt;= x) r = mid; else l = mid; } return l;}int main() { cin &gt;&gt; x; printf(&quot;%.6lf&quot;,bsearch(x)); return 0;}","link":"/2024/05/28/%E6%95%B0%E7%9A%84%E4%B8%89%E6%AC%A1%E6%96%B9%E6%A0%B9/"},{"title":"栈","text":"","link":"/2024/06/04/%E6%A0%88/"},{"title":"滑动窗口","text":"滑动窗口实现滑动窗口是一种常用的算法技巧，用于在数组或列表上进行高效的区间操作。本文将介绍如何使用C++实现滑动窗口。 问题描述给定一个长度为 n 的数组和一个整数 k，找出每个长度为 k 的子数组的最小值和最大值。 代码实现以下是一个实现滑动窗口的完整C++代码示例： 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;const int N = 100010;int n, k;int a[N], q[N];int main(){ scanf(&quot;%d%d&quot;, &amp;n, &amp;k); for(int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;a[i]); int hh = 0, tt = -1; for(int i = 0; i &lt; n; i++) { // 判断队头是否已经滑出窗口 if(hh &lt;= tt &amp;&amp; i - k + 1 &gt; q[hh]) hh++; while(hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt--; q[++tt] = i; if(i &gt;= k - 1) printf(&quot;%d &quot;, a[q[hh]]); } puts(&quot;&quot;); hh = 0, tt = -1; for(int i = 0; i &lt; n; i++) { // 判断队头是否已经滑出窗口 if(hh &lt;= tt &amp;&amp; i - k + 1 &gt; q[hh]) hh++; while(hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i]) tt--; q[++tt] = i; if(i &gt;= k - 1) printf(&quot;%d &quot;, a[q[hh]]); } puts(&quot;&quot;); return 0;} 示例输入输出以下是一些示例输入和对应的输出，帮助理解代码的工作原理。 示例 1输入： 128 31 3 -1 -3 5 3 6 7 输出： 12-1 -3 -3 -3 3 33 3 5 5 6 7 示例 2输入： 125 22 1 2 4 3 输出： 121 1 2 32 2 4 4 示例 3输入： 126 49 3 5 1 6 7 输出： 121 1 19 6 6 代码说明初始化滑动窗口： 定义数组 a 存储输入的数组，q 用作滑动窗口的队列。 读取数组长度 n 和窗口大小 k。 处理输入数据： 读取输入的数组元素，维护两个滑动窗口，分别用于求最小值和最大值。 主函数逻辑： 初始化队列，处理输入数据，并按照滑动窗口的规则输出每个子数组的最小值和最大值。","link":"/2024/06/06/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"title":"队列","text":"","link":"/2024/06/06/%E9%98%9F%E5%88%97/"},{"title":"面经","text":"1. Transformer模型的结构Transformer模型是由Vaswani等人在2017年提出的一种深度学习模型，主要用于自然语言处理任务，如翻译、文本生成等。Transformer模型的核心架构由编码器（Encoder）和解码器（Decoder）组成。以下是Transformer模型的详细结构： 1. 编码器（Encoder）编码器部分由N个相同的编码器层（Encoder Layer）堆叠而成。每个编码器层包括两个子层： a. 多头自注意力机制（Multi-Head Self-Attention Mechanism） 输入：一组向量表示（如单词的词嵌入）。 输出：对输入向量进行加权求和，以捕捉全局依赖关系。 多头机制：通过多个注意力头（Attention Heads）来捕捉不同子空间的特征。 b. 前馈神经网络（Feed-Forward Neural Network） 包含两个线性变换层和一个激活函数（通常是ReLU）。 输入：经过多头自注意力机制后的输出。 输出：经过非线性变换后的表示。 每个子层后都有一个残差连接（Residual Connection）和层归一化（Layer Normalization）。 2. 解码器（Decoder）解码器部分也由N个相同的解码器层（Decoder Layer）堆叠而成。每个解码器层包括三个子层： a. 多头自注意力机制（Masked Multi-Head Self-Attention Mechanism） 类似于编码器中的多头自注意力机制，但这里的自注意力是被掩盖的，以确保解码过程中当前词只能关注到之前的词。 b. 编码器-解码器注意力机制（Encoder-Decoder Attention Mechanism） 输入：编码器的输出和解码器自注意力的输出。 输出：结合编码器信息和当前解码步骤信息的表示。 c. 前馈神经网络（Feed-Forward Neural Network） 与编码器中的前馈神经网络类似。 每个子层后也有残差连接和层归一化。 3. 位置编码（Positional Encoding）由于Transformer没有卷积和循环结构，它使用位置编码来注入关于序列顺序的信息。这些位置编码是添加到输入向量中的。 4. 全局架构 编码器：将输入序列编码为一组隐层表示。 解码器：基于编码器的表示和之前生成的词，生成输出序列。 注意力机制（Attention Mechanism）Transformer的核心是注意力机制，特别是自注意力机制。以下是其关键步骤： 计算注意力分数（Scores）： 其中，( Q ) 是查询矩阵，( K ) 是键矩阵，( V ) 是值矩阵，( d_k ) 是键向量的维度。 多头注意力（Multi-Head Attention）：通过并行的多个注意力头来学习不同的特征表示：每个头的计算方法类似，但使用不同的参数。 总结Transformer模型通过并行化的多头自注意力机制和前馈神经网络，极大地提高了序列到序列任务的效率和性能。它在许多自然语言处理任务中都取得了显著的成功，并成为了现代自然语言处理的基石。 2. 为什么要用 SwimTransformer 而不用cnnSwin Transformer 和 CNN（卷积神经网络）在架构和处理图像的方式上有显著的区别。以下是对这两者的详细比较以及Swin Transformer的优势： 1. 架构区别CNN（卷积神经网络） 基本单元：卷积层（Convolutional Layer），通过卷积核（filter）提取局部特征。 特征提取方式：局部感受野（Local Receptive Field），在输入图像的局部区域内滑动卷积核进行特征提取。 池化层（Pooling Layer）：用于下采样，减小特征图尺寸，通常使用最大池化（Max Pooling）或平均池化（Average Pooling）。 层次结构：通常由多个卷积层、池化层和全连接层（Fully Connected Layer）堆叠而成。 Swin Transformer（滑动窗口Transformer） 基本单元：Transformer编码器层（Transformer Encoder Layer），采用自注意力机制（Self-Attention Mechanism）。 特征提取方式：通过滑动窗口（Sliding Window）进行局部注意力计算，划分图像为不重叠的窗口，在每个窗口内计算自注意力。 分层结构：包括多层Swin Transformer块，每个块包含局部注意力机制、跨窗口连接和前馈网络。 多尺度表示：通过分层设计实现多尺度特征提取，类似于CNN中的层次结构，但更灵活。 2. 优势比较CNN 的优势 计算效率高：卷积操作在计算和内存上都非常高效，特别适合在图像处理中应用。 局部特征提取：擅长提取局部特征，如边缘、纹理等，适用于大多数图像识别任务。 结构简单：卷积层和池化层的设计简单明了，易于理解和实现。 Swin Transformer 的优势 全局建模能力：通过自注意力机制，能够在整个图像范围内建立全局上下文关系，而不仅仅局限于局部区域。 灵活的窗口设计：滑动窗口机制结合了局部和全局特征提取的优势，通过窗口内和跨窗口的注意力计算，能够更好地捕捉多尺度信息。 适应性强：可以通过改变窗口大小和层数，灵活调整模型以适应不同规模和复杂度的任务。 统一架构：Transformer架构在自然语言处理和计算机视觉任务中的成功应用，表明其在处理不同类型数据上的强大适应性。 为什么使用 Swin Transformer 而不是 CNN 全局特征提取：Swin Transformer的自注意力机制可以在整个图像上建模长距离依赖关系，适合处理需要全局上下文信息的任务，如目标检测和语义分割。 多尺度特征：通过滑动窗口和分层设计，Swin Transformer能够更好地捕捉不同尺度的特征，这在多尺度特征非常重要的任务中表现出色。 灵活性和扩展性：Swin Transformer具有很强的灵活性，可以方便地扩展和调整以适应不同的任务和数据规模。而CNN的结构较为固定，适应性相对较差。 一致性和统一性：Transformer在不同任务中的成功应用，使其成为一种通用的架构，便于在不同任务之间共享和转移学习，而不需要设计不同的模型。 总结虽然CNN在计算效率和局部特征提取方面具有优势，但Swin Transformer通过结合自注意力机制和滑动窗口设计，实现了更强的全局建模能力和多尺度特征提取能力，适应性更强，尤其在处理复杂图像任务时表现出色。因此，在需要全局上下文信息和多尺度特征的任务中，使用Swin Transformer往往能够获得更好的效果。 3.为什么transformer 需要mask（掩码）Transformer中的mask（掩码）在不同的阶段和子模块中有不同的用途，主要是为了控制注意力机制的范围和确保模型生成输出时的正确性。以下是Transformer中不同类型mask的详细说明及其原因： 1. 自注意力中的Mask（Self-Attention Mask）a. Padding Mask（填充掩码） 用途：用于忽略填充部分的影响。 位置：在输入序列中。 原因：在处理变长序列时，输入序列通常被填充到相同长度。填充部分（通常是零）不应该影响注意力机制的计算，因此使用填充掩码来忽略这些位置。 实现：将填充位置的注意力分数设为负无穷大，以确保softmax后的注意力权重为零。 b. Look-Ahead Mask（前瞻掩码，也称为Causal Mask/未来掩码） 用途：确保在解码阶段，每个位置只能看到当前及之前的位置，不能看到未来的位置。 位置：在解码器中的自注意力层。 原因：在序列生成任务中（如语言模型或翻译），当前步骤的输出不能依赖未来的输入，因此需要前瞻掩码来阻止模型在当前时间步关注到未来时间步的信息。 实现：通过一个上三角矩阵来掩盖未来位置，将未来位置的注意力分数设为负无穷大。 2. 编码器-解码器注意力中的Maska. Padding Mask 用途：在编码器-解码器注意力中，解码器需要关注编码器的输出，因此也需要忽略填充部分的影响。 位置：在解码器的编码器-解码器注意力层。 原因：类似于自注意力中的填充掩码，确保解码器不会在注意力计算中考虑编码器输出中的填充位置。 实现：与自注意力中的填充掩码相同，将填充位置的注意力分数设为负无穷大。 3. 总结为什么需要Mask？ 处理变长输入：保证填充部分不会影响注意力机制的计算，确保模型只关注实际输入部分。 保证因果性：在序列生成任务中，保证生成的每一步只依赖于当前及之前的信息，而不泄露未来的信息。 提高模型性能：通过适当的掩码操作，可以提高模型训练的有效性和稳定性，避免无意义的注意力计算。 实际例子自注意力中的Look-Ahead Mask假设我们有一个输入序列[A, B, C, D]，在生成时，模型不应该在生成B时看到C和D。 生成Look-Ahead Mask的矩阵如下： 123456[ [0, -inf, -inf, -inf], [0, 0, -inf, -inf], [0, 0, 0, -inf], [0, 0, 0, 0]] 在这个矩阵中，0表示可以关注，-inf表示掩盖。 Padding Mask假设输入序列[A, B, PAD, PAD]，PAD表示填充位置。 生成的Padding Mask如下： 123[ [1, 1, 0, 0]] 在这个向量中，1表示实际输入位置，0表示填充位置。 结论Mask在Transformer中起到了重要的作用，通过控制注意力机制的范围，确保模型在训练和推理过程中关注正确的信息，提高模型的性能和稳定性。","link":"/2024/06/27/%E9%9D%A2%E7%BB%8F/"},{"title":"高精度乘法","text":"高精度乘法实现在处理大整数运算时，直接使用内置的数据类型可能会导致溢出，因此需要使用字符串或数组来存储大整数，并逐位进行运算。本文将介绍如何使用C++实现高精度乘法。 代码实现以下是一个实现高精度乘法的完整C++代码示例： 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; mul(vector&lt;int&gt; a, int b) { vector&lt;int&gt; c; int t = 0; for (int i = 0; i &lt; a.size(); i++) { t += a[i] * b; c.push_back(t % 10); t = t / 10; } while (t) { c.push_back(t % 10); t = t / 10; } return c;}int main() { string a; int b; cin &gt;&gt; a &gt;&gt; b; vector&lt;int&gt; A; for (int i = a.size() - 1; i &gt;= 0; i--) { A.push_back(a[i] - '0'); } auto C = mul(A, b); for (int i = C.size() - 1; i &gt;= 0; i--) { printf(&quot;%d&quot;, C[i]); } return 0;} 示例输入输出以下是一些示例输入和对应的输出，帮助理解代码的工作原理。 示例 1输入： 12123456789012345678909 输出： 1111111110111111110010 示例 2输入： 12987654321098765432108 输出： 1790123456879012345680 示例 3输入： 12999999999999999999995 输出： 1499999999999999999995 代码说明输入处理： 使用字符串 a 存储输入的大整数。 将字符串转换为倒序存储的整数数组 A。 乘法实现： 函数 mul 实现大整数与单个整数的逐位乘法，并处理进位。 主函数逻辑： 将字符串转换为整数数组，并进行逐位乘法计算。 逆序输出结果。","link":"/2024/05/30/%E9%AB%98%E7%B2%BE%E5%BA%A6%E4%B9%98%E6%B3%95/"},{"title":"面经2-attention(注意力机制)","text":"1.通俗的解释什么是attention注意力机制（Attention Mechanism）是深度学习中一种非常重要的技术，它帮助模型更好地“关注”输入数据中的重要部分。为了更通俗地解释，我们可以用一个简单的类比来帮助理解。 类比：读书做笔记假设你在阅读一本书，并且需要在阅读过程中做一些笔记。书中的内容非常多，但你不能也不需要记住每一个字。那么你会怎么做呢？你会重点关注那些对你来说重要的信息。注意力机制就像你在读书时选择性地关注重要内容一样。 具体步骤 输入信息： 你有一本书（输入数据），每一页上有很多文字（输入序列）。 关键内容： 你要做笔记，所以你需要找到哪些内容是最重要的，比如关键的段落、句子或单词。 注意力权重： 你给每个句子或段落分配一个重要性分数（权重）。更重要的内容分数更高，不太重要的内容分数更低。 加权求和： 你根据这些分数来决定每段内容在你笔记中的重要性。重要性高的内容，你会详细记下（加权求和后保留更多信息），重要性低的内容，你会略过或简要记下。 在深度学习中的应用在深度学习中，注意力机制通过以下步骤工作： 输入序列： 模型接收一段输入序列，比如一句话的每个单词的表示（向量）。 计算注意力分数： 模型计算每个单词对当前处理单词的重要性，类似于你给每段内容分配一个重要性分数。 生成注意力权重： 使用这些分数通过一个softmax函数转化为注意力权重，这些权重和分数可以理解为“关注度”。 加权求和： 对输入序列中的所有单词的表示进行加权求和，权重高的单词对最终表示的影响更大。 例子假设你在翻译一个句子：”The cat sat on the mat.” 在翻译时，模型需要决定哪些单词对当前正在翻译的单词最重要。例如，在翻译“sat”时，模型可能会发现“cat”和“mat”也很重要，因为它们在语义上相关。这时，注意力机制会给“cat”和“mat”更高的权重，而给其他不太相关的单词更低的权重。 总结注意力机制帮助模型在处理大量信息时，更加高效地聚焦于最相关和重要的部分。这不仅提高了模型的性能，也使得模型在处理复杂任务时更加灵活和精确。就像你在读书时会重点标记和记住重要的部分一样，注意力机制使得模型在处理数据时能够有效地“注意”到关键信息。 2.注意力机制的计算注意力机制（Attention Mechanism）在深度学习中的计算方法主要包括三个步骤：计算注意力分数、生成注意力权重、加权求和。以下是详细的计算过程，以自注意力（Self-Attention）为例进行解释。 1. 输入表示假设我们有一个输入序列，可以表示为矩阵 \\(X\\)，其中每一行代表序列中一个词的向量表示。对于一个长度为 \\(n\\) 的序列，每个词的向量维度为 \\(d\\)，因此输入矩阵 \\(X\\) 的形状为 \\(n \\times d\\)。 2. 计算查询（Query）、键（Key）和值（Value）首先，我们需要为每个输入向量计算查询（Query）、键（Key）和值（Value）向量。这是通过三个不同的线性变换完成的。假设 \\(W_Q\\)、\\(W_K\\) 和 \\(W_V\\) 分别是查询、键和值的权重矩阵，它们的形状都是 \\(d \\times d_k\\)。 $$ Q = XW_Q $$$$ K = XW_K $$$$ V = XW_V $$ 其中，\\(Q\\)、\\(K\\) 和 \\(V\\) 分别是查询、键和值的矩阵，它们的形状都是 \\(n \\times d_k\\)。 3. 计算注意力分数（Attention Scores）接下来，我们计算查询和键的点积来得到注意力分数。注意力分数表示每个词对其他词的重要性。 $$ \\text{scores} = QK^T $$ 这里，\\(\\text{scores}\\) 的形状是 \\(n \\times n\\)，表示每个词对其他所有词的注意力分数。 4. 生成注意力权重（Attention Weights）为了使得注意力分数更稳定，我们会对其进行缩放，除以 \\(\\sqrt{d_k}\\)。接下来，应用softmax函数将注意力分数转化为注意力权重，这些权重表示每个词对其他词的注意力分配。 $$ \\text{scaled_scores} = \\frac{QK^T}{\\sqrt{d_k}} $$$$ \\text{weights} = \\text{softmax}(\\text{scaled_scores}) $$ 注意力权重矩阵 \\(\\text{weights}\\) 的形状也是 \\(n \\times n\\)。 5. 加权求和（Weighted Sum）最后，使用注意力权重对值\\（Value\\）向量进行加权求和，得到最终的输出。 $$ \\text{output} = \\text{weights}V $$ 输出矩阵 \\(\\text{output}\\) 的形状是 \\(n \\times d_k\\)。 总结注意力机制的计算过程可以总结为以下几个步骤： 计算查询、键和值：$$ Q = XW_Q, \\quad K = XW_K, \\quad V = XW_V $$ 计算注意力分数：$$ \\text{scores} = QK^T $$ 缩放注意力分数并应用softmax：$$ \\text{scaled_scores} = \\frac{\\text{scores}}{\\sqrt{d_k}}, \\quad \\text{weights} = \\text{softmax}(\\text{scaled_scores}) $$ 计算加权求和：$$ \\text{output} = \\text{weights}V $$ 这个过程实现了从输入序列到输出序列的自适应权重计算，使得模型能够关注到输入序列中的重要部分。这种机制在各种任务（如机器翻译、文本生成、图像处理等）中都表现出了强大的性能。 3.注意力机制的k,q相似度计算都有哪些方法，各自有什么优缺点在注意力机制中，查询（Query，Q）和键（Key，K）之间的相似度计算是核心步骤，用于确定注意力权重。不同的相似度计算方法有不同的优缺点。以下是几种常见的方法及其优缺点： 1. 点积相似度（Dot-Product Similarity）计算方法$$ \\text{score}(Q, K) = Q \\cdot K^T $$ 优点 计算简单：点积相似度计算非常高效，尤其是在硬件加速（如GPU）上可以充分利用矩阵乘法的优化。 常用方法：点积相似度是Transformer模型中的默认选择，被广泛使用和验证。 缺点 维度影响：随着向量维度增加，点积值可能会变得很大，导致softmax函数的梯度过小。为此，通常需要缩放因子（如 \\(\\sqrt{d_k}\\)）来稳定计算。 2. 缩放点积相似度（Scaled Dot-Product Similarity）计算方法$$ \\text{score}(Q, K) = \\frac{Q \\cdot K^T}{\\sqrt{d_k}} $$ 优点 稳定梯度：通过缩放因子 \\(\\sqrt{d_k}\\) 减少了随着维度增加而导致的梯度消失问题。 广泛应用：在Transformer模型中被默认使用，性能稳定。 缺点 需要缩放：虽然解决了梯度问题，但增加了一步额外的缩放计算。 3. 余弦相似度（Cosine Similarity）计算方法$$ \\text{score}(Q, K) = \\frac{Q \\cdot K^T}{|Q| |K|} $$ 优点 归一化相似度：将向量的相似度归一化到[-1, 1]之间，消除了向量长度对相似度的影响。 可解释性强：余弦相似度在各种应用中都有较好的解释性。 缺点 计算复杂度：需要计算向量的范数，增加了计算复杂度。 性能问题：在某些场景下，余弦相似度的效果可能不如点积相似度。 4. 加性注意力（Additive Attention 或 Bahdanau Attention）计算方法$$ \\text{score}(Q, K) = w^T \\tanh(W_Q Q + W_K K + b) $$其中，\\(w\\)、\\(W_Q\\)、\\(W_K\\) 和 \\(b\\) 是可训练的参数。 优点 灵活性高：通过可训练参数，可以更灵活地学习不同类型的相似度。 广泛应用：特别是在早期的Seq2Seq模型中应用广泛。 缺点 计算开销大：涉及更多的参数和非线性操作（tanh），计算开销较大。 复杂度高：相比点积相似度，计算更复杂。 5. 高斯注意力（Gaussian Attention）计算方法$$ \\text{score}(Q, K) = \\exp\\left(-\\frac{|Q - K|^2}{2\\sigma^2}\\right) $$ 优点 平滑注意力分布：使用高斯函数计算相似度，可以产生更加平滑的注意力分布。 与距离相关：自然地反映了向量之间的欧氏距离。 缺点 参数选择：需要选择合适的 \\(\\sigma\\) 值，参数选择不当可能导致效果不佳。 计算开销大：计算欧氏距离和指数函数增加了计算开销。 总结每种相似度计算方法都有其特定的优缺点，选择哪种方法通常取决于具体应用场景和需求： 点积相似度和缩放点积相似度：计算简单高效，适用于大多数Transformer模型。 余弦相似度：适用于需要归一化相似度的场景，但计算复杂度较高。 加性注意力：灵活性高，但计算开销大，适用于需要灵活相似度计算的应用。 高斯注意力：平滑分布和距离相关，但计算复杂度和参数选择是挑战。 实际应用中，缩放点积相似度是最常用和有效的方法，尤其是在Transformer架构中。 4.attention的计算中为什么要除以根号dk在注意力机制的计算中，将点积相似度除以 \\(\\sqrt{d_k}\\) 是为了稳定计算过程，防止数值溢出。这一步骤通常称为缩放点积相似度（Scaled Dot-Product Attention）。以下是详细的原因和解释： 原因和解释1. 避免数值不稳定 高维点积值过大： 在高维空间中，向量的点积值随着维度的增加会变得很大。这是因为点积的结果是多个元素乘积的累加，维度越高，累加的值越大。假设两个向量 \\(Q\\) 和 \\(K\\) 的每个元素都是均值为零、方差为1的独立随机变量，那么它们的点积 \\(\\sum_{i=1}^{d_k} Q_i K_i\\) 的方差是 \\(d_k\\)。随着 \\(d_k\\) 增加，点积的值会越来越大。 softmax梯度消失： 在计算注意力权重时，点积相似度值作为输入会被传递到softmax函数中。如果这些值很大，softmax函数的输出会变得极端，即接近0或1。这会导致梯度消失问题，使得模型在训练过程中难以有效更新参数。 2. 缩放稳定计算 **缩放因子 \\(\\sqrt{d_k}\\)**： 为了避免上述问题，我们在计算点积相似度后，除以 \\(\\sqrt{d_k}\\)。这一缩放因子将点积相似度值缩小到一个更合理的范围，防止值过大。 具体地，缩放后的值更接近于均值为0、方差为1的标准正态分布。这使得softmax函数的输入值不会太大，从而生成的注意力权重更加平滑，梯度更新也更稳定。 数学解释假设 \\(Q\\) 和 \\(K\\) 是维度为 \\(d_k\\) 的向量：$$ \\text{score}(Q, K) = Q \\cdot K^T = \\sum_{i=1}^{d_k} Q_i K_i $$ 如果 \\(Q_i\\) 和 \\(K_i\\) 的元素是均值为0、方差为1的随机变量，那么点积的结果的期望值为0，但方差为 \\(d_k\\)：$$ \\text{Var}(Q \\cdot K^T) = d_k $$ 为了使得点积相似度的方差不随\\(d_k\\) 增加，我们将其除以 \\(\\sqrt{d_k}\\)：$$ \\text{scaled_score}(Q, K) = \\frac{Q \\cdot K^T}{\\sqrt{d_k}} $$ 这将点积的方差标准化为1，输入到softmax函数的值范围更加稳定。 例子和效果例如，在维度 \\(d_k = 64\\) 的情况下，如果不进行缩放，点积的值可能会变得很大（例如，在0到64之间）。经过softmax后，权重会极端化，导致某些注意力权重接近1，而其他接近0。这种极端的权重分布会使模型的学习变得困难。而通过缩放因子 \\(\\sqrt{64} = 8\\)，点积值会被缩小到一个更合理的范围（例如，在0到8之间），使得softmax输出的权重更平滑，梯度更稳定。 总结将点积相似度除以 \\(\\sqrt{d_k}\\) 的目的是为了： 防止高维向量点积值过大导致的数值不稳定问题。 生成更平滑的注意力权重分布，避免softmax输出的极端化，稳定梯度更新过程。 这一步骤是Transformer模型中的一个重要细节，确保了注意力机制在高维情况下的有效性和稳定性。","link":"/2024/06/27/%E9%9D%A2%E7%BB%8F2-attention-%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/"},{"title":"算法总结","text":"目录 一、基础算法 3 快速排序算法模板 3 归并排序算法模板 4 逆序对数量 5 整数二分算法模板 6 浮点数二分算法模板 7 高精度加法 7 高精度减法 8 高精度比大小（cmp函数） 8 高精度乘低精度 8 高精度乘高精度 9 高精度除低精度 9 高精度除高精度 10 一维前缀和 11 二维前缀和 11 一维差分 12 二维差分 13 位运算 14 双指针算法 14 离散化 14 区间合并 16 二、数据结构 17 单链表 17 双链表 18 栈 19 队列 20 循环队列 21 单调栈 22 单调队列 23 KMP字符串匹配 24 二叉树的存储与遍历 25 Trie树 28 并查集 29 堆 32 一般hash 33 字符串哈希 34 三、搜索与图论 37 树与图的存储 38 邻接矩阵 38 邻接表 38 树与图的遍历 38 应用：数字全排列 39 应用：树的重心 39 应用：n-皇后问题 41 宽度优先遍历 42 应用：走迷宫 42 应用：八数码 43 拓扑排序 44 Dijkstra算法 46 Bellman-Ford算法 49 SPFA算法（队列优化的Bellman-Ford算法） 52 floyd算法 55 最短路算法总结 57 prim算法 57 Kruskal算法 59 染色法判别二分图 62 匈牙利算法 64 四、数学知识 67 试除法判定质数 68 试除法分解质因数 68 埃氏筛法求质数 68 线性筛法求质数 69 试除法求所有约数 69 约数个数 69 约数之和 70 欧几里得算法(求最大公约数) 71 最小公倍数 72 求欧拉函数 72 线性筛法求欧拉函数 73 快速幂 74 扩展欧几里得算法 74 中国剩余定理 75 扩展中国剩余定理 76 高斯消元法 76 求组合数 79 Lucas定理求组合数 81 分解质因数法求组合数 83 容斥原理应用 87 博弈论 88 五、动态规划 91 闫式dp分析法.jpg 91 背包问题 91 区间DP 100 计数类DP 102 数位统计DP 102 状态压缩DP 104 树形DP 106 记忆化搜索 108 六、贪心 109 区间问题 109 区间选点 109 区间分组 111 排序不等式 112 排队打水 112 一、基础算法快速排序算法模板void quick_sort(int q[], int l, int r) { //递归的终止情况 if (l &gt;= r) return; //选取分界线。这里选数组中间那个数 int i = l - 1, j = r + 1, x = q[l + r &gt;&gt; 1]; //划分成左右两个部分 while (i &lt; j) { do i ++ ; while (q[i] &lt; x); do j -- ; while (q[j] &gt; x); if (i &lt; j) swap(q[i], q[j]); } //对左右部分排序 quick_sort(q, l, j), quick_sort(q, j + 1, r); } 边界问题：因为边界问题只有这两种组合，不能随意搭配 1.x不能取q[l]和q[l+r&gt;&gt;1]; quick_sort(q,l,i-1),quick_sort(q,i,r); 2.x不能取q[r]和q[(l+r+1)&gt;&gt;1]; quick_sort(q,l,j),quick_sort(q,j+1,r); 归并排序算法模板void merge_sort(int q[], int l, int r) { //递归的终止情况 if (l &gt;= r) return; //第一步：分成子问题 int mid = l + r &gt;&gt; 1; //第二步：递归处理子问题 merge_sort(q, l, mid); merge_sort(q, mid + 1, r); //第三步：合并子问题 int k = 0, i = l, j = mid + 1; while (i &lt;= mid &amp;&amp; j &lt;= r) if (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ]; else tmp[k ++ ] = q[j ++ ]; while (i &lt;= mid) tmp[k ++ ] = q[i ++ ]; while (j &lt;= r) tmp[k ++ ] = q[j ++ ]; //第四步：复制回原数组 for (i = l, j = 0; i &lt;= r; i ++, j ++ ) q[i] = tmp[j]; } 逆序对数量在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。 思路：归并排序 举个例子： 在合并 {4 ,5} {1 , 2} 的时候，首先我们判断 1 &lt; 4，我们即可统计出逆序对为2，为什么呢？这利用了数组的部分有序性。因为我们知道 {4 ,5} 这个数组必然是有序的，因为是合并上来的。此时当 1比4小的时候，证明4以后的数也都比1大，此时就构成了从4开始到 {4,5}这个数组结束，这么多个逆序对（2个），此时利用一个临时数组，将1存放起来，接着比较2和4的大小，同样可以得到有2个逆序对，于是将2也放进临时数组中，此时右边数组已经完全没有元素了，则将左边剩余的元素全部放进临时元素中，最后将临时数组中的元素放进原数组对应的位置。 最后接着向上合并~ 逆序对数量.png 归并排序求逆序对.gif using namespace std; typedef long long LL; const int N = 100010; int n; int q[N], tmp[N]; LL merge_sort(int l, int r) { if (l &gt;= r)return 0; int mid = (l + r) &gt;&gt; 1; LL res = merge_sort(l, mid) + merge_sort(mid + 1, r); // 归并的过程 int k = 0, i = l, j = mid + 1; while (i &lt;= mid &amp;&amp; j &lt;= r) if (q[i] &lt;= q[j])tmp[k++] = q[i++]; else { tmp[k++] = q[j++]; res += mid - i + 1; } //扫尾 while (i &lt;= mid)tmp[k++] = q[i++]; while (j &lt;= r)tmp[k++] = q[j++]; //物归原主 for (i = l, j = 0; i &lt;= r; j++, i++)q[i] = tmp[j]; return res; } int main() { cin &gt;&gt; n; for (int i = 0; i &lt; n; i++)cin &gt;&gt; q[i]; cout &lt;&lt; merge_sort(0, n - 1) &lt;&lt; endl; return 0; } 整数二分算法模板对lower_bound来说，它寻找的就是第一个满足条件“值大于等于x”的元素的位置；对upper_bound函数来说，它寻找的是第一个满足“值大于 x”的元素的位置。 bool check(int x) {/* … */} // 检查x是否满足某种性质 // 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用： int bsearch_1(int l, int r) { while (l &lt; r) { int mid = l + r &gt;&gt; 1; if (check(mid)) r = mid; // check()判断mid是否满足性质 else l = mid + 1;//左加右减 } return l; } // 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用： int bsearch_2(int l, int r) { while (l &lt; r) { int mid = l + r + 1 &gt;&gt; 1;//如果下方else后面是l则这里加1 if (check(mid)) l = mid; else r = mid - 1;//左加右减 } return l; } 浮点数二分算法模板bool check(double x) {/* … */} // 检查x是否满足某种性质 double bsearch_3(double l, double r) { const double eps = 1e-6; // eps 表示精度，取决于题目对精度的要求 while (r - l &gt; eps) { double mid = (l + r) / 2; if (check(mid)) r = mid; else l = mid; } return l; } 高精度加法// C = A + B, A &gt;= 0, B &gt;= 0 vector add(vector &amp;a,vector &amp;b){ //c为答案 vector&lt;int&gt; c; //t为进位 int t=0; for(int i=0;i&lt;a.size()||i&lt;b.size();i++){ //不超过a的范围添加a[i] if(i&lt;a.size())t+=a[i]; //不超过b的范围添加b[i] if(i&lt;b.size())t+=b[i]; //取当前位的答案 c.push_back(t%10); //是否进位 t/=10; } //如果t!=0的话向后添加1 if(t)c.push_back(1); return c; } 高精度减法// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0 vector sub(vector &amp;A, vector &amp;B) { //答案 vector&lt;int&gt; C; //遍历最大的数 for (int i = 0, t = 0; i &lt; A.size(); i ++ ) { //t为进位 t = A[i] - t; //不超过B的范围t=A[i]-B[i]-t; if (i &lt; B.size()) t -= B[i]; //合二为一，取当前位的答案 C.push_back((t + 10) % 10); //t&lt;0则t=1 if (t &lt; 0) t = 1; //t&gt;=0则t=0 else t = 0; } //去除前导零 while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); return C; } 高精度比大小（cmp函数）//高精度比大小 bool cmp(vector &amp;A, vector &amp;B) { if (A.size() != B.size()) return A.size() &gt; B.size(); for (int i = A.size() - 1; i &gt;= 0; i -- ) if (A[i] != B[i]) return A[i] &gt; B[i]; return true; } 高精度乘低精度// C = A * b, A &gt;= 0, b &gt;= 0 vector mul(vector &amp;A, int b) { //类似于高精度加法 vector&lt;int&gt; C; //t为进位 int t = 0; for (int i = 0; i &lt; A.size() || t; i ++ ) { //不超过A的范围t=t+A[i]*b if (i &lt; A.size()) t += A[i] * b; //取当前位的答案 C.push_back(t % 10); //进位 t /= 10; } //去除前导零 while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); return C; } 高精度乘高精度高精度加减乘除：https://www.bilibili.com/video/BV1LA411v7mt/ vector mul(vector &amp;A, vector &amp;B) { vector&lt;int&gt; C(A.size() + B.size()); // 初始化为 0，C的size可以大一点 for (int i = 0; i &lt; A.size(); i++) for (int j = 0; j &lt; B.size(); j++) C[i + j] += A[i] * B[j]; for (int i = 0, t = 0; i &lt; C.size(); i++) { // i = C.size() - 1时 t 一定小于 10 t += C[i]; C[i] = t % 10; t /= 10; } while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); // 必须要去前导 0，因为最高位很可能是 0 return C; } 高精度除低精度// A / b = C … r, A &gt;= 0, b &gt; 0 vector div(vector &amp;A, int b, int &amp;r)//高精度A，低精度b，余数r { vector&lt;int&gt; C;//答案 r = 0; for (int i = A.size() - 1; i &gt;= 0; i -- ) { r = r * 10 + A[i];//补全r&gt;=b C.push_back(r / b);//取当前位的答案 r %= b;//r%b为下一次计算 } reverse(C.begin(), C.end());//倒序为答案 while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();//去除前导零 return C; } 高精度除高精度高精度加减乘除：https://www.bilibili.com/video/BV1LA411v7mt/ vector div(vector &amp;A, vector &amp;B, vector &amp;r) { vector&lt;int&gt; C; if (!cmp(A, B)) { C.push_back(0); r.assign(A.begin(), A.end()); return C; } int j = B.size(); r.assign(A.end() - j, A.end()); while (j &lt;= A.size()) { int k = 0; while (cmp(r, B)) { r = sub(r, B); k ++; } C.push_back(k); if (j &lt; A.size()) r.insert(r.begin(), A[A.size() - j - 1]); if (r.size() &gt; 1 &amp;&amp; r.back() == 0) r.pop_back(); j++; } reverse(C.begin(), C.end()); while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); return C; } 一维前缀和前缀和可以用于快速计算一个序列的区间和，也有很多问题里不是直接用前缀和，但是借用了前缀和的思想。 预处理:s[i]=a[i]+a[i-1] 求区间[l,r]:sum=s[r]-s[l-1] “前缀和数组”和”原数组”可以合二为一 应用 const int N=100010; int a[N]; int main(){ int n,m; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1;i&lt;=n;i++)a[i]=a[i-1]+a[i]; scanf(&quot;%d&quot;,&amp;m); while(m--){ int l,r; scanf(&quot;%d%d&quot;,&amp;l,&amp;r); printf(&quot;%d\\n&quot;,a[r]-a[l-1]); } return 0; } 二维前缀和计算矩阵的前缀和：s[x][y] = s[x - 1][y] + s[x][y -1] - s[x-1][y-1] + a[x][y] 以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为： 计算子矩阵的和：s = s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 -1] 应用 int s[1010][1010]; int n,m,q; int main(){ scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;q); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) scanf(&quot;%d&quot;,&amp;s[i][j]); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) s[i][j]+=s[i-1][j]+s[i][j-1]-s[i-1][j-1]; while(q--){ int x1,y1,x2,y2; scanf(&quot;%d%d%d%d&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2); printf(&quot;%d\\n&quot;,s[x2][y2]-s[x2][y1-1]-s[x1-1][y2]+s[x1-1][y1-1]); } return 0; } 一维差分差分是前缀和的逆运算，对于一个数组a，其差分数组b的每一项都是a [ i ]和前一项a [ i − 1 ]的差。 注意：差分数组和原数组必须分开存放！！！！ 给区间[l, r]中的每个数加上c：B[l] += c, B[r + 1] -= c 应用 using namespace std; int a[100010],s[100010]; int main(){ int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i]; for(int i=1;i&lt;=n;i++)s[i]=a[i]-a[i-1];// 读入并计算差分数组 while(m--){ int l,r,c; cin&gt;&gt;l&gt;&gt;r&gt;&gt;c; s[l]+=c; s[r+1]-=c;// 在原数组中将区间[l, r]加上c } for(int i=1;i&lt;=n;i++){ s[i]+=s[i-1]; cout&lt;&lt;s[i]&lt;&lt;' '; }// 给差分数组计算前缀和，就求出了原数组 return 0; } 二维差分给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c： S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c 应用 const int N = 1e3 + 10; int a[N][N], b[N][N]; void insert(int x1, int y1, int x2, int y2, int c) { b[x1][y1] += c; b[x2 + 1][y1] -= c; b[x1][y2 + 1] -= c; b[x2 + 1][y2 + 1] += c; } int main() { int n, m, q; cin &gt;&gt; n &gt;&gt; m &gt;&gt; q; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) cin &gt;&gt; a[i][j]; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { insert(i, j, i, j, a[i][j]); //构建差分数组 } } while (q--) { int x1, y1, x2, y2, c; cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c; insert(x1, y1, x2, y2, c);//加c } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { b[i][j] += b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1]; //二维前缀和 } } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { printf(&quot;%d &quot;, b[i][j]); } printf(&quot;\\n&quot;); } return 0; } 关于前缀和与差分的相关博客链接：https://blog.csdn.net/qq_39757593/article/details/129219491 位运算求n的第k位数字: n &gt;&gt; k &amp; 1 返回n的最后一位1：lowbit(n) = n &amp; -n 双指针算法for (int i = 0, j = 0; i &lt; n; i ++ ) { while (j &lt; i &amp;&amp; check(i, j)) j ++ ; // 具体问题的逻辑 } 常见问题分类： (1) 对于一个序列，用两个指针维护一段区间 (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作 离散化离散化的本质是建立了一段数列到自然数之间的映射关系（value -&gt; index)，通过建立新索引，来缩小目标区间，使得可以进行一系列连续数组可以进行的操作比如二分，前缀和等… 离散化首先需要排序去重： 1.排序：sort(alls.begin(),alls.end()) 2.去重：alls.earse(unique(alls.begin(),alls.end()),alls.end()); vector alls; // 存储所有待离散化的值 sort(alls.begin(), alls.end()); // 将所有值排序 alls.erase(unique(alls.begin(), alls.end()), alls.end()); // 去掉重复元素 // 二分求出x对应的离散化的值 int find(int x) // 找到第一个大于等于x的位置 { int l = 0, r = alls.size() - 1; while (l &lt; r) { int mid = l + r &gt;&gt; 1; if (alls[mid] &gt;= x) r = mid; else l = mid + 1; } return r + 1; // 映射到1, 2, ...n } 应用 typedef pair&lt;int, int&gt; PII; const int N = 300010; int n, m; int a[N], s[N]; vector alls;//存入下标容器 vector add, query;//add增加容器，存入对应下标和增加的值的大小 //query存入需要计算下标区间和的容器 int find(int x) { int l = 0, r = alls.size() - 1; while (l &lt; r)//查找大于等于x的最小的值的下标 { int mid = l + r &gt;&gt; 1; if (alls[mid] &gt;= x) r = mid; else l = mid + 1; } return r + 1;//因为使用前缀和，其下标要+1可以不考虑边界问题 } int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i ++ ) { int x, c; cin &gt;&gt; x &gt;&gt; c; add.push_back({x, c});//存入下标即对应的数值c alls.push_back(x);//存入数组下标x=add.first } for (int i = 0; i &lt; m; i ++ ) { int l, r; cin &gt;&gt; l &gt;&gt; r; query.push_back({l, r});//存入要求的区间 alls.push_back(l);//存入区间左右下标 alls.push_back(r); } // 区间去重 sort(alls.begin(), alls.end()); alls.erase(unique(alls.begin(), alls.end()), alls.end()); // 处理插入 for (auto item : add) { int x = find(item.first);//将add容器的add.secend值存入数组a[]当中， a[x] += item.second;//在去重之后的下标集合alls内寻找对应的下标并添加数值 } // 预处理前缀和 for (int i = 1; i &lt;= alls.size(); i ++ ) s[i] = s[i - 1] + a[i]; // 处理询问 for (auto item : query) { int l = find(item.first), r = find(item.second);//在下标容器中查找对应的左右两端[l~r]下标，然后通过下标得到前缀和相减再得到区间a[l~r]的和 cout &lt;&lt; s[r] - s[l - 1] &lt;&lt; endl; } return 0; } 区间合并// 将所有存在交集的区间合并 void merge(vector &amp;segs) { vector&lt;PII&gt; res; sort(segs.begin(), segs.end()); int st = -2e9, ed = -2e9; for (auto seg : segs) if (ed &lt; seg.first) { if (st != -2e9) res.push_back({st, ed}); st = seg.first, ed = seg.second; } else ed = max(ed, seg.second); if (st != -2e9) res.push_back({st, ed}); segs = res; } 二、数据结构单链表const int N=100010; int head,e[N],ne[N],idx; //初始化 void init(){ head=-1; idx=0; } //在链表头部添加节点 void add_to_head(int x){ e[idx]=x,ne[idx]=head,head=idx++; } //在位置k添加节点x void add(int k,int x){ e[idx]=x,ne[idx]=ne[k],ne[k]=idx++; } //删除位置k的节点 void remove(int k){ ne[k]=ne[ne[k]]; } 应用 int main(){ int m; init(); cin&gt;&gt;m; while(m--){ int k,x; char op; cin&gt;&gt;op; if(op=='H'){ cin&gt;&gt;x; add_to_head(x); }else if(op=='D'){ cin&gt;&gt;k; if(!k)head=ne[head]; remove(k-1); }else { cin&gt;&gt;k&gt;&gt;x; add(k-1,x); } } for(int i=head;i!=-1;i=ne[i])cout&lt;&lt;e[i]&lt;&lt;' '; cout&lt;&lt;endl; return 0; } 双链表const int N=100010; int e[N],l[N],r[N],idx; //初始化 void init(){ l[1]=0; r[0]=1; idx=2; } //在节点a的右边插入一个数x void insert(int a,int x){ e[idx]=x; l[idx]=a,r[idx]=r[a]; l[r[a]]=idx,r[a]=idx++; } //删除节点a void remove(int a){ l[r[a]]=l[a]; r[l[a]]=r[a]; } 应用 int main(){ int m; cin&gt;&gt;m; init(); while(m--){ string op; cin&gt;&gt;op; int k,x; if(op==&quot;L&quot;){//在最左端插入数x cin&gt;&gt;x; insert(0,x); }else if(op==&quot;R&quot;){//在最右端插入数x cin&gt;&gt;x; insert(l[1],x); }else if(op==&quot;D&quot;){//删除第k个插入的数 cin&gt;&gt;k; remove(k+1); }else if(op==&quot;IL&quot;){//在第k个位置的左侧插入一个数 cin&gt;&gt;k&gt;&gt;x; insert(l[k+1],x); }else if(op==&quot;LR&quot;){//在第k个位置的右侧插入一个数 cin&gt;&gt;k&gt;&gt;x; insert(k+1,x); } } for(int i=r[0];i!=1;i=r[i])printf(&quot;%d &quot;,e[i]); cout&lt;&lt;endl; return 0; } 栈// tt表示栈顶 int stk[N], tt = 0; // 向栈顶插入一个数 stk[ ++ tt] = x; // 从栈顶弹出一个数 tt – ; // 栈顶的值 stk[tt]; // 判断栈是否为空，如果 tt &gt; 0，则表示不为空 if (tt &gt; 0) { } 应用 const int N=100010; int stk[N],tt; int main(){ int m; cin&gt;&gt;m; while(m--){ string op; int x; cin&gt;&gt;op; if(op==&quot;push&quot;){ cin&gt;&gt;x; stk[tt++]=x; }else if(op==&quot;pop&quot;){ tt--; }else if(op==&quot;query&quot;){ cout&lt;&lt;stk[tt-1]&lt;&lt;endl; }else{ if(!tt)cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; } } return 0; } 队列普通队列 // hh 表示队头，tt表示队尾 int q[N], hh = 0, tt = -1; // 向队尾插入一个数 q[ ++ tt] = x; // 从队头弹出一个数 hh ++ ; // 队头的值 q[hh]; // 判断队列是否为空，如果 hh &lt;= tt，则表示不为空 if (hh &lt;= tt) { } 应用 int const N=100010; int que[N],hh,tt=-1; int main(){ int m; cin&gt;&gt;m; while(m--){ string op; int x; cin&gt;&gt;op; if(op==&quot;push&quot;){ cin&gt;&gt;x; que[++tt]=x; }else if(op==&quot;query&quot;){ cout&lt;&lt;que[hh]&lt;&lt;endl; }else if(op==&quot;pop&quot;){ hh++; }else{ if(hh&gt;tt)cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; } } return 0; } 循环队列// hh 表示队头，tt表示队尾的后一个位置 int q[N], hh = 0, tt = 0; // 向队尾插入一个数 q[tt ++ ] = x; if (tt == N) tt = 0; // 从队头弹出一个数 hh ++ ; if (hh == N) hh = 0; // 队头的值 q[hh]; // 判断队列是否为空，如果hh != tt，则表示不为空 if (hh != tt) { } 单调栈常见模型：找出每个数左边离它最近的比它大/小的数 int tt = 0; for (int i = 1; i &lt;= n; i ++ ) { while (tt &amp;&amp; check(stk[tt], i)) tt -- ; stk[ ++ tt] = i; } 应用 找出每个数左边离它最近的比它大/小的数 stack stk; int main(){ int n; cin &gt;&gt; n; stk.push(-1); for (int i = 0; i &lt; n; i ++){ int x; cin &gt;&gt; x; while (stk.size() &amp;&amp; stk.top() &gt;= x) stk.pop(); cout &lt;&lt; stk.top() &lt;&lt; &quot; &quot;; stk.push(x); } return 0; } 单调队列常见模型：找出滑动窗口中的最大值/最小值 int hh = 0, tt = -1; for (int i = 0; i &lt; n; i ++ ) { while (hh &lt;= tt &amp;&amp; check_out(q[hh])) hh ++ ; // 判断队头是否滑出窗口 while (hh &lt;= tt &amp;&amp; check(q[tt], i)) tt -- ; q[ ++ tt] = i; } const int N = 1000010; int a[N]; int main() { int n, k; cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; a[i];//读入数据 deque&lt;int&gt; q; for(int i = 1; i &lt;= n; i++) { while(q.size() &amp;&amp; q.back() &gt; a[i]) //新进入窗口的值小于队尾元素，则队尾出队列 q.pop_back(); q.push_back(a[i]);//将新进入的元素入队 if(i - k &gt;= 1 &amp;&amp; q.front() == a[i - k])//若队头是否滑出了窗口，队头出队 q.pop_front(); if(i &gt;= k)//当窗口形成，输出队头对应的值 cout &lt;&lt; q.front() &lt;&lt;&quot; &quot;; } q.clear(); cout &lt;&lt; endl; //最大值亦然 for(int i = 1; i &lt;= n; i++) { while(q.size() &amp;&amp; q.back() &lt; a[i]) q.pop_back(); q.push_back(a[i]); if(i - k &gt;= 1 &amp;&amp; a[i - k] == q.front()) q.pop_front(); if(i &gt;= k) cout &lt;&lt; q.front() &lt;&lt; &quot; &quot;; } } KMP字符串匹配视频讲解：[最浅显易懂的 KMP 算法讲解_哔哩哔哩_bilibili]：https://www.bilibili.com/video/BV1AY4y157yL 下标从1开始的kmp算法 const int N = 100010, M = 1000010; int n, m; int ne[N]; char s[M], p[N]; int main() { cin &gt;&gt; n &gt;&gt; p + 1 &gt;&gt; m &gt;&gt; s + 1; for (int i = 2, j = 0; i &lt;= n; i ++ ) { while (j &amp;&amp; p[i] != p[j + 1]) j = ne[j]; if (p[i] == p[j + 1]) j ++ ; ne[i] = j; }//处理ne数组 for (int i = 1, j = 0; i &lt;= m; i ++ ) { while (j &amp;&amp; s[i] != p[j + 1]) j = ne[j]; if (s[i] == p[j + 1]) j ++ ; if (j == n) { printf(&quot;%d &quot;, i - n); j = ne[j]; } }//匹配算法 return 0; } // s[]是长文本，p[]是模式串，n是s的长度，m是p的长度 求模式串的Next数组： for (int i = 2, j = 0; i &lt;= m; i ++ ) { while (j &amp;&amp; p[i] != p[j + 1]) j = ne[j]; if (p[i] == p[j + 1]) j ++ ; ne[i] = j; } // 匹配 for (int i = 1, j = 0; i &lt;= n; i ++ ) { while (j &amp;&amp; s[i] != p[j + 1]) j = ne[j]; if (s[i] == p[j + 1]) j ++ ; if (j == m) { j = ne[j]; // 匹配成功后的逻辑 } } 下标从0开始的kmp算法 const int N = 1000010; int n, m; char s[N], p[N]; int ne[N]; int main() { cin &gt;&gt; m &gt;&gt; p &gt;&gt; n &gt;&gt; s; ne[0] = -1; for (int i = 1, j = -1; i &lt; m; i ++ ) { while (j &gt;= 0 &amp;&amp; p[j + 1] != p[i]) j = ne[j]; if (p[j + 1] == p[i]) j ++ ; ne[i] = j; } for (int i = 0, j = -1; i &lt; n; i ++ ) { while (j != -1 &amp;&amp; s[i] != p[j + 1]) j = ne[j]; if (s[i] == p[j + 1]) j ++ ; if (j == m - 1) { cout &lt;&lt; i - j &lt;&lt; ' '; j = ne[j]; } } return 0; } 二叉树的存储与遍历const int N = 1e6 + 10; // 二叉树的存储,l数组为左节点,r数组为右结点 int l[N], r[N]; // 存储节点的数据 char w[N]; // 节点的下标指针 int idx = 0; // 先序创建 int pre_create(int n) { cin &gt;&gt; w[n]; if (w[n] == '#') return -1; l[n] = pre_create(++idx); r[n] = pre_create(++idx); return n; } // 中序创建 int in_create(int n) { if (w[n] == '#') return -1; l[n] = in_create(++idx); cin &gt;&gt; w[n]; r[n] = in_create(++idx); return n; } // 后序创建 int back_create(int n) { if (w[n] == '#') return -1; l[n] = back_create(++idx); r[n] = back_create(++idx); cin &gt;&gt; w[n]; return n; } // 先序遍历 void pre_print(int n){ if (w[n] != '#') cout &lt;&lt; w[n] &lt;&lt; ' '; if (l[n] &gt; 0) pre_print(l[n]); if (r[n] &gt; 0) pre_print(r[n]); } // 中序遍历 void in_print(int n){ if (l[n] &gt; 0) in_print(l[n]); if (w[n] != '#') cout &lt;&lt; w[n] &lt;&lt; ' '; if (r[n] &gt; 0) in_print(r[n]); } // 后序遍历 void back_print(int n){ if (l[n] &gt; 0) back_print(l[n]); if (r[n] &gt; 0) back_print(r[n]); if (w[n] != '#') cout &lt;&lt; w[n] &lt;&lt; ' '; } // 层序遍历 void bfs(int root){ queue&lt;int&gt; que; que.push(root); while (!que.empty()) { int t = que.front(); cout &lt;&lt; w[t] &lt;&lt; ' '; que.pop(); if (l[t] &gt; 0 &amp;&amp; w[l[t]] != '#') que.push(l[t]); if (r[t] &gt; 0 &amp;&amp; w[r[t]] != '#') que.push(r[t]); } } 应用 int main(){ // 先序创建 pre_create(++idx); // 中序创建 // in_create(++idx); // 后序创建 // back_create(++idx); // 先序遍历 pre_print(1); // 中序遍历 in_print(1); // 后序遍历 back_print(1); // 层序遍历 bfs(1); // 测试数据abc##de#g##f### // 输出如下： // a b c d e g f // c b e g d f a // c g e f d b a // a b c d e f g return 0; } Trie树Trie 树是一种多叉树的结构，每个节点保存一个字符，一条路径表示一个字符串。 相关链接：https://www.acwing.com/solution/content/27771/ int son[N][26], cnt[N], idx; // 0号点既是根节点，又是空节点 // son[][]存储树中每个节点的子节点 // cnt[]存储以每个节点结尾的单词数量 // 插入一个字符串 void insert(char *str) { int p = 0; for (int i = 0; str[i]; i ++ ) { int u = str[i] - 'a'; if (!son[p][u]) son[p][u] = ++ idx; p = son[p][u]; } cnt[p] ++ ; } // 查询字符串出现的次数 int query(char *str) { int p = 0; for (int i = 0; str[i]; i ++ ) { int u = str[i] - 'a'; if (!son[p][u]) return 0; p = son[p][u]; } return cnt[p]; } const int N = 100010; int son[N][26], cnt[N], idx; char str[N]; void insert(char *str) { int p = 0; for (int i = 0; str[i]; i ++ ) { int u = str[i] - 'a'; if (!son[p][u]) son[p][u] = ++ idx; p = son[p][u]; } cnt[p] ++ ; }//插入 int query(char *str) { int p = 0; for (int i = 0; str[i]; i ++ ) { int u = str[i] - 'a'; if (!son[p][u]) return 0; p = son[p][u]; } return cnt[p]; }//查询 int main() { int n; scanf(&quot;%d&quot;, &amp;n); while (n -- ) { char op[2]; scanf(&quot;%s%s&quot;, op, str); if (*op == 'I') insert(str); else printf(&quot;%d\\n&quot;, query(str)); } return 0; } 并查集(1)朴素并查集： int p[N]; //存储每个点的祖宗节点 // 返回x的祖宗节点 int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } // 初始化，假定节点编号是1~n for (int i = 1; i &lt;= n; i ++ ) p[i] = i; // 合并a和b所在的两个集合： p[find(a)] = find(b); (2)维护size的并查集： int p[N], size[N]; //p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量 // 返回x的祖宗节点 int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } // 初始化，假定节点编号是1~n for (int i = 1; i &lt;= n; i ++ ) { p[i] = i; size[i] = 1; } // 合并a和b所在的两个集合： size[find(b)] += size[find(a)]; p[find(a)] = find(b); (3)维护到祖宗节点距离的并查集： int p[N], d[N]; //p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离 // 返回x的祖宗节点 int find(int x) { if (p[x] != x) { int u = find(p[x]); d[x] += d[p[x]]; p[x] = u; } return p[x]; } // 初始化，假定节点编号是1~n for (int i = 1; i &lt;= n; i ++ ) { p[i] = i; d[i] = 0; } // 合并a和b所在的两个集合： p[find(a)] = find(b); d[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量 应用 const int N=100010; int p[N],n,m; int find(int x){//找到祖宗节点+路径压缩 if(p[x]!=x)p[x]=find(p[x]); return p[x]; } int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)p[i]=i; while(m--){ char op[2]; int a,b; scanf(&quot;%s%d%d&quot;,op,&amp;a,&amp;b); if(op[0]=='M')p[find(a)]=find(b); else { if(find(a)==find(b))puts(&quot;Yes&quot;); else puts(&quot;No&quot;); } } return 0; } 堆// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1 // ph[k]存储第k个插入的点在堆中的位置 // hp[k]存储堆中下标是k的点是第几个插入的 int h[N], ph[N], hp[N], size; // 交换两个点，及其映射关系 void heap_swap(int a, int b) { swap(ph[hp[a]],ph[hp[b]]); swap(hp[a], hp[b]); swap(h[a], h[b]); } void down(int u) { int t = u; if (u * 2 &lt;= size &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2; if (u * 2 + 1 &lt;= size &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1; if (u != t) { heap_swap(u, t); down(t); } } void up(int u) { while (u / 2 &amp;&amp; h[u] &lt; h[u / 2]) { heap_swap(u, u / 2); u &gt;&gt;= 1; } } // O(n)建堆 for (int i = n / 2; i; i – ) down(i); 应用：堆排序 const int N=100010; int heap[N],cnt; void down(int u){ int t=u; if(u*2&lt;=cnt&amp;&amp;heap[u*2]&lt;=heap[t])t=u*2; if(u*2+1&lt;=cnt&amp;&amp;heap[u*2+1]&lt;=heap[t])t=u*2+1; if(t!=u){ swap(heap[t],heap[u]); down(t); } }//down操作 void up(int u){ while(u/2&amp;&amp;heap[u/2]&gt;heap[u]){ swap(heap[u/2],heap[u]); u&gt;&gt;=1; } }//up操作 int main(){ int n,m; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;heap[i]); cnt=n; for(int i=n/2;i;i--)down(i); while(m--){ printf(&quot;%d &quot;,heap[1]); heap[1]=heap[cnt--]; down(1); } return 0; } 一般hash(1) 拉链法 int h[N], e[N], ne[N], idx; // 向哈希表中插入一个数 void insert(int x) { int k = (x % N + N) % N; e[idx] = x; ne[idx] = h[k]; h[k] = idx ++ ; } // 在哈希表中查询某个数是否存在 bool find(int x) { int k = (x % N + N) % N; for (int i = h[k]; i != -1; i = ne[i]) if (e[i] == x) return true; return false; } (2) 开放寻址法 int h[N]; // 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置 int find(int x) { int t = (x % N + N) % N; while (h[t] != null &amp;&amp; h[t] != x) { t ++ ; if (t == N) t = 0; } return t; } 字符串哈希核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低 小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果 typedef unsigned long long ULL; ULL h[N], p[N]; // h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64 // 初始化 p[0] = 1; for (int i = 1; i &lt;= n; i ++ ) { h[i] = h[i - 1] * P + str[i]; p[i] = p[i - 1] * P; } // 计算子串 str[l ~ r] 的哈希值 ULL get(int l, int r) { return h[r] - h[l - 1] * p[r - l + 1]; } STLSTL容器.png 视频讲解：[100 STL 容器_哔哩哔哩_bilibili]：https://www.bilibili.com/video/BV1tF411G73c/ vector, 变长数组，倍增的思想 size() 返回元素个数 empty() 返回是否为空 clear() 清空 front()/back() push_back()/pop_back() begin()/end() [] 支持比较运算，按字典序 pair&lt;int, int&gt; first, 第一个元素 second, 第二个元素 支持比较运算，以first为第一关键字，以second为第二关键字（字典序） string，字符串 size()/length() 返回字符串长度 empty() clear() substr(起始下标，(子串长度)) 返回子串 c_str() 返回字符串所在字符数组的起始地址 queue, 队列 size() empty() push() 向队尾插入一个元素 front() 返回队头元素 back() 返回队尾元素 pop() 弹出队头元素 priority_queue, 优先队列，默认是大根堆 size() empty() push() 插入一个元素 top() 返回堆顶元素 pop() 弹出堆顶元素 定义成小根堆的方式：priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q; stack, 栈 size() empty() push() 向栈顶插入一个元素 top() 返回栈顶元素 pop() 弹出栈顶元素 deque, 双端队列 size() empty() clear() front()/back() push_back()/pop_back() push_front()/pop_front() begin()/end() [] set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列 size() empty() clear() begin()/end() ++, -- 返回前驱和后继，时间复杂度 O(logn) set/multiset insert() 插入一个数 find() 查找一个数 count() 返回某一个数的个数 erase() (1) 输入是一个数x，删除所有x O(k + logn) (2) 输入一个迭代器，删除这个迭代器 lower_bound()/upper_bound() lower_bound(x) 返回大于等于x的最小的数的迭代器 upper_bound(x) 返回大于x的最小的数的迭代器 map/multimap insert() 插入的数是一个pair erase() 输入的参数是pair或者迭代器 find() [] 注意multimap不支持此操作。 时间复杂度是 O(logn) lower_bound()/upper_bound() unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表 和上面类似，增删改查的时间复杂度是 O(1) 不支持 lower_bound()/upper_bound()， 迭代器的++，-- bitset, 圧位 bitset&lt;10000&gt; s; ~, &amp;, |, ^ &gt;&gt;, &lt;&lt; ==, != [] count() 返回有多少个1 any() 判断是否至少有一个1 none() 判断是否全为0 set() 把所有位置成1 set(k, v) 将第k位变成v reset() 把所有位变成0 flip() 等价于~ flip(k) 把第k位取反 三、搜索与图论树与图的存储树是一种特殊的图，与图的存储方式相同。 对于无向图中的边ab，存储两条有向边a-&gt;b, b-&gt;a。 因此我们可以只考虑有向图的存储。 邻接矩阵邻接矩阵：g[a][b] 存储边a-&gt;b的距离 邻接表// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点 int h[N], e[N], ne[N], idx; // 添加一条边a-&gt;b void add(int a, int b) { //存下b的值，b下一个指向a的下个一节点，a的下一个节点指向b e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ; } // 初始化 idx = 0; memset(h, -1, sizeof h); 树与图的遍历时间复杂度O(n+m)，n表示点数，m表示边数 深度优先遍历 int dfs(int u) { st[u] = true; // st[u] 表示点u已经被遍历过 for (int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j]) dfs(j); } } 应用：数字全排列#include using namespace std; int res[10],b[10],n; void dfs(int k){ if(k==n){//k==n则输出n个数字 for(int i=0;i&lt;n;i++)printf(&quot;%d &quot;,res[i]); cout&lt;&lt;endl; } for(int i=1;i&lt;=n;i++){ if(!b[i]){//判断是否被用过 res[k]=i;//当前k位存入位置 b[i]=1;//表示被占用 dfs(k+1); b[i]=0;//恢复现场 } } } int main(){ cin&gt;&gt;n; dfs(0);//从0开始枚举 return 0; } 应用：树的重心#include #include #include #include using namespace std; const int N = 100010, M = N * 2;//无向图n条边时，最多2n个idx，因为每条边在邻接表中会出现两次 int n;//n个结点,n-1条边 int h[N], e[M], ne[M], idx;//n个链表头，e每一个结点的值，ne每一个结点的next指针 int ans = N;//最小的最大值 bool st[N];//状态数组，防止子节点搜索父节点 void add(int a, int b)//a-&gt;b {//e记录当前点的值(地址-&gt;值),ne下一点的地址(地址-&gt;地址)，h记录指向的第一个点的地址(值-&gt;地址) e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ; }//头插法 int dfs(int u)//通过h数组找到子结点的向 { st[u] = true;//st标记当前点被搜过 int size = 0, sum = 0; //size删掉元素后各个子连通块的最大值 //sum当前子树大小，遍历叶节点时，返回1 for (int i = h[u]; i != -1; i = ne[i])//遍历单链表，链表末端初始化为-1 { int j=e[i]; if(st[j])continue;//此处防逆向dfs int s = dfs(j);//s各个子连通块的大小 size = max(size, s);//size删掉元素后各个连通块的最大值 sum += s;//各个连通块大小之和 } size = max(size, n - sum - 1);//判断最大子连通块与父连通块的最大值 ans = min(ans, size);//全局变量ans存最小的最大值 //注意：本题若求最大的最大值，则只需去除任意叶节点即可，即n-1 return sum + 1;//各个子连通块，当前结点之和 } int main() { scanf(&quot;%d&quot;, &amp;n); memset(h, -1, sizeof h);//n个头节点全部指向-1 for (int i = 0; i &lt; n - 1; i ++ )//n个结点，n-1条边 { int a, b; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); add(a, b), add(b, a);//不知道子节点还是父节点，所以需要建两条边可以双向查找 } dfs(1);//结点编号为1~n且可能只有一个结点，则参数只能为1 printf(&quot;%d\\n&quot;, ans); return 0; } 应用：n-皇后问题n皇后搜索图示 using namespace std; const int N = 11; char q[N][N];//存储棋盘 bool dg[N * 2], udg[N * 2], cor[N];//点对应的两个斜线以及列上是否有皇后 int n; void dfs(int r) { if(r == n)//放满了棋盘，输出棋盘 { for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) cout &lt;&lt; q[i][j]; cout &lt;&lt; endl; } cout &lt;&lt; endl; return; } for(int i = 0; i &lt; n; i++)//第 r 行，第 i 列 是否放皇后 { if(!cor[i] &amp;&amp; !dg[i + r] &amp;&amp; !udg[n - i + r])//不冲突，放皇后 { q[r][i] = 'Q'; cor[i] = dg[i + r] = udg[n - i + r] = 1;//对应的 列， 斜线 状态改变 dfs(r + 1);//处理下一行 cor[i] = dg[i + r] = udg[n - i + r] = 0;//恢复现场 q[r][i] = '.'; } } } int main() { cin &gt;&gt; n; for (int i = 0; i &lt; n; i ++ ) for (int j = 0; j &lt; n; j ++ ) q[i][j] = '.'; dfs(0); return 0; } 宽度优先遍历queue q; st[1] = true; // 表示1号点已经被遍历过 q.push(1); while (q.size()) { int t = q.front(); q.pop(); for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j]) { st[j] = true; // 表示点j已经被遍历过 q.push(j); } } } 应用：走迷宫typedef pair&lt;int,int&gt; PII;//声明pair时候必须要在代码前面写上using namespace std; const int N=110; int g[N][N],f[N][N],n,m; int bfs(int x,int y){ queue&lt;PII&gt; que; que.push({x,y}); int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0}; while(!que.empty()){ PII t=que.front(); que.pop(); g[t.first][t.second]=1; for(int i=0;i&lt;4;i++){ int a=t.first+dx[i],b=t.second+dy[i]; if(a&gt;=0&amp;&amp;b&gt;=0&amp;&amp;a&lt;n&amp;&amp;b&lt;m&amp;&amp;!g[a][b]){ g[a][b]=1; f[a][b]=f[t.first][t.second]+1; que.push({a,b}); } } } return f[n-1][m-1]; } int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) scanf(&quot;%d&quot;,&amp;g[i][j]); cout&lt;&lt;bfs(0,0)&lt;&lt;endl; return 0; } 应用：八数码using namespace std; int bfs(string state) { queue&lt;string&gt; q; unordered_map&lt;string, int&gt; d; int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1}; string ed = &quot;12345678x&quot;; q.push(state); d[state] = 0; while (q.size()) { auto t = q.front(); q.pop(); if (t == ed)//等于结果就输出步数 return d[t]; int distance = d[t]; int k = t.find('x');//寻找x int x = k / 3, y = k % 3;//计算下标 for (int i = 0; i &lt; 4; i ++ ) { int a = x + dx[i], b = y + dy[i]; if (a &gt;= 0 &amp;&amp; a &lt; 3 &amp;&amp; b &gt;= 0 &amp;&amp; b &lt; 3) { swap(t[a * 3 + b], t[k]);//交换 if (!d.count(t)) {//不存在就入队 d[t] = distance + 1; q.push(t); } swap(t[a * 3 + b], t[k]);//还原 } } } return -1; } int main() { char s[2]; string state; for (int i = 0; i &lt; 9; i ++ ) { cin &gt;&gt; s; state += *s; } cout&lt;&lt;bfs(state)&lt;&lt;endl; return 0; } 拓扑排序啥是拓扑排序？ 一个有向图，如果图中有入度为 0 的点，就把这个点删掉，同时也删掉这个点所连的边。 一直进行上面出处理，如果所有点都能被删掉，则这个图可以进行拓扑排序。 纯净版bool topsort() { int hh = 0, tt = -1; // d[i] 存储点i的入度 for (int i = 1; i &lt;= n; i ++ ) if (!d[i]) q[ ++ tt] = i; while (hh &lt;= tt) { int t = q[hh ++ ]; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (-- d[j] == 0) q[ ++ tt] = j; } } // 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。 return tt == n - 1; } 解说版using namespace std; const int N = 100010; int e[N], ne[N], idx; //邻接表存储图 int h[N];//邻接表的每个头链表 int q[N], hh = 0, tt = -1; //队列保存入度为0的点，也就是能够输出的点 int n, m; //保存图的点数和边数 int d[N];//保存各个点的入度 void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx++; } void topsort() { for (int i = 1; i &lt;= n; i++) {//遍历一遍顶点的入度。 if (!d[i])//如果入度为0，则可以入队列 q[++tt] = i; } while (tt &gt;= hh) { //循环处理队列中点的 int a = q[hh++]; for (int i = h[a]; i != -1; i = ne[i]) { int b = e[i]; //a 有一条边指向b d[b]--;//删除边后，b的入度减1 if (!d[b])//如果b的入度减为 0,则 b 可以输出，入队列 q[++tt] = b; } } if (tt == n - 1) {//如果队列中的点的个数与图中点的个数相同，则可以进行拓扑排序 for (int i = 0; i &lt; n; i++)//队列中保存了所有入度为0的点，依次输出 printf(&quot;%d &quot;, q[i]); } else//如果队列中的点的个数与图中点的个数不相同，则可以进行拓扑排序 cout &lt;&lt; -1; } int main() { cin &gt;&gt; n &gt;&gt; m; //保存点的个数和边的个数 memset(h, -1, sizeof h); //初始化领接矩阵 while (m--) { //依次读入边 int a, b; cin &gt;&gt; a &gt;&gt; b; d[b]++;//顶点b的入度+1 add(a, b); //添加到邻接矩阵 } topsort();//进行拓扑排序 return 0; } Dijkstra算法朴素版时间复杂是O(n2+m) ，n表示点数，m表示边数 int g[N][N]; // 存储每条边 int dist[N]; // 存储1号点到每个点的最短距离 bool st[N]; // 存储每个点的最短路是否已经确定 // 求1号点到n号点的最短路，如果不存在则返回-1 int dijkstra() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; for (int i = 0; i &lt; n - 1; i ++ ) { int t = -1; // 在还未确定最短路的点中，寻找距离最小的点 for (int j = 1; j &lt;= n; j ++ ) if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j])) t = j; // 用t更新其他点的距离 for (int j = 1; j &lt;= n; j ++ ) dist[j] = min(dist[j], dist[t] + g[t][j]); st[t] = true; } if (dist[n] == 0x3f3f3f3f) return -1; return dist[n]; } 应用const int N = 510, M = 100010; int h[N], e[M], ne[M], w[M], idx;//邻接表存储图 int state[N];//state 记录是否找到了源点到该节点的最短距离 int dist[N];//dist 数组保存源点到其余各个节点的距离 int n, m;//图的节点个数和边数 void add(int a, int b, int c)//插入边 { e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++; } void Dijkstra() { memset(dist, 0x3f, sizeof(dist));//dist 数组的各个元素为无穷大 dist[1] = 0;//源点到源点的距离为置为 0 for (int i = 0; i &lt; n; i++) { int t = -1; for (int j = 1; j &lt;= n; j++)//遍历 dist 数组，找到没有确定最短路径的节点中距离源点最近的点t { if (!state[j] &amp;&amp; (t == -1 || dist[j] &lt; dist[t])) t = j; } state[t] = 1;//state[i] 置为 1。 for (int j = h[t]; j != -1; j = ne[j])//遍历 t 所有可以到达的节点 i { int i = e[j]; dist[i] = min(dist[i], dist[t] + w[j]);//更新 dist[j] } } } int main() { memset(h, -1, sizeof(h));//邻接表初始化 cin &gt;&gt; n &gt;&gt; m; while (m--)//读入 m 条边 { int a, b, w; cin &gt;&gt; a &gt;&gt; b &gt;&gt; w; add(a, b, w); } Dijkstra(); if (dist[n] != 0x3f3f3f3f)//如果dist[n]被更新了，则存在路径 cout &lt;&lt; dist[n]; else cout &lt;&lt; &quot;-1&quot;; } 堆优化版时间复杂度O(mlogn) ，n表示点数，m表示边数 typedef pair&lt;int, int&gt; PII; int n; // 点的数量 int h[N], w[N], e[N], ne[N], idx; // 邻接表存储所有边 int dist[N]; // 存储所有点到1号点的距离 bool st[N]; // 存储每个点的最短距离是否已确定 // 求1号点到n号点的最短距离，如果不存在，则返回-1 int dijkstra(){ memset(dist,0x3f,sizeof dist);//距离初始化为无穷大 dist[1]=0;//1-&gt;1的节点距离为0 priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt; heap;//小根堆 heap.push({0,1});//插入距离和节点编号 while(heap.size()){ auto t=heap.top();//取距离源点最近的点 heap.pop(); int ver=t.second,distance=t.first;//ver：节点编号，distance源点距离ver if(st[ver])continue;//如果距离已经确定，则跳过该点 st[ver]=true; for(int i=h[ver];i!=-1;i=ne[i])//更新ver所指向的节点距离 { int j=e[i]; if(dist[j]&gt;dist[ver]+w[i]){ dist[j]=dist[ver]+w[i]; heap.push({dist[j],j});//距离变小，则入堆 } } } if(dist[n]==0x3f3f3f3f)return -1; return dist[n]; } 关于Dijkstra的相关博客链接：[AcWing 849. Dijkstra求最短路 I：图解 详细代码（图解） - AcWing：https://www.acwing.com/solution/content/38318/ [AcWing 850. Dijkstra求最短路 II：详解+代码注释 - AcWing]：https://www.acwing.com/solution/content/38323/ Bellman-Ford算法时间复杂度O(nm)，n表示点数，m表示边数 注意在模板题中需要对下面的模板稍作修改，加上备份数组，详情见模板题。 Bellman-ford算法动态规划图示.png 上图为Bellman-ford草稿图 int n, m; // n表示点数，m表示边数 int dist[N],backup[N]; // dist[x]存储1到x的最短路距离 struct Edge // 边，a表示出点，b表示入点，w表示边的权重 { int a, b, w; }edges[M]; // 求1到n的最短路距离，如果无法从1走到n，则返回-1。 int bellman_ford() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; // 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。 for (int i = 0; i &lt; n; i ++ ) { memcpy(back,dist,sizeof dist); for (int j = 0; j &lt; m; j ++ ) { int a = edges[j].a, b = edges[j].b, w = edges[j].w; if (dist[b] &gt; backup[a] + w) dist[b] = backup[a] + w; } } if (dist[n] &gt; 0x3f3f3f3f / 2) return -1; return dist[n]; } 应用int n,m,k; const int N=512,M=10012; struct Edge{ int a,b,w; }e[M]; int dist[N]; int back[N]; void bellman_ford(){ memset(dist,0x3f,sizeof dist); dist[1]=0; for(int i=0;i&lt;k;i++){ memcpy(back,dist,sizeof dist); for(int j=0;j&lt;m;j++){ int a=e[j].a,b=e[j].b,c=e[j].w; dist[b]=min(dist[b],back[a]+c); } } } int main(){ scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k); for(int i=0;i&lt;m;i++){ int a,b,w; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;w); e[i]={a,b,w}; } bellman_ford(); if(dist[n]&gt;0x3f3f3f3f/2)cout&lt;&lt;&quot;impossible&quot;&lt;&lt;endl; else cout&lt;&lt;dist[n]&lt;&lt;endl; return 0; } 问题：为什么把每一条边用不等式刷k次就是k条件下的值？ 你可以想象这个图是1-&gt;2-&gt;3-&gt;4….-&gt;n这样一条直线。比如说第一次迭代，为什么只有与原点相连的点才能被更新dist呢？因为原点的dist是0，其他点的dist是+∞，满足dist[2] &gt; dist[1]+c，而+∞并不&gt;+∞+c，所以第一次迭代结束就是不超过一条边走到i节点最短路的距离，依次类推，第二次迭代，只有3会被更新，因为只有1、2的dist不是+∞，第二次迭代就是不超过2条边走到i节点的最短距离。这就是为什么k次迭代最多是走了k条边，同时也是为什么一共只用迭代n-1次，因为n个点的有向图，如果能走到，原点到n号点的最短距离最多是n-1次，也就是1-&gt;2-&gt;…-&gt;n直线这种。 SPFA算法（队列优化的Bellman-Ford算法）时间复杂度平均情况下O(m)，最坏情况下O(nm)，n表示点数，m表示边数 模板 int n; // 总点数 int h[N], w[N], e[N], ne[N], idx; // 邻接表存储所有边 int dist[N]; // 存储每个点到1号点的最短距离 bool st[N]; // 存储每个点是否在队列中 // 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1 int spfa() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; queue&lt;int&gt; q; q.push(1); st[1] = true; while (q.size()) { auto t = q.front(); q.pop(); st[t] = false; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] &gt; dist[t] + w[i]) { dist[j] = dist[t] + w[i]; if (!st[j]) // 如果队列中已存在j，则不需要将j重复插入 { q.push(j); st[j] = true; } } } } if (dist[n] == 0x3f3f3f3f) return -1; return dist[n]; } 应用const int N = 1e6 + 10; int n, m;//节点数量和边数 int h[N], w[N], e[N], ne[N], idx;//邻接矩阵存储图 int dist[N];//存储距离 bool st[N];//存储状态 void add(int a, int b, int c) { e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ; } int spfa() { memset(dist, 0x3f, sizeof dist);//距离初始化为无穷大 dist[1] = 0;//初始化1到1的距离为0 queue&lt;int&gt; que;//队列 que.push(1);//1入队 while (que.size())//判断是否存在 { int t=que.front(); que.pop();//获取第一个并出队 st[t]=false;//第一个取消占用 for(int i=h[t];i!=-1;i=ne[i]){//遍历第一个可以到达的结点 int j=e[i]; if(dist[j]&gt;dist[t]+w[i]){//1号点可到达的节点距离是否大于上次的距离距离加上当前的距离 dist[j]=dist[t]+w[i];//赋值给可到达的节点 if(!st[j]){//如果可到达的节点未被占用 que.push(j);//则入队 st[j]=true;//占用 } } } } return dist[n]; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); memset(h, -1, sizeof h); while (m -- ) { int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); add(a, b, c); } int t=spfa(); if(t==0x3f3f3f3f)cout&lt;&lt;&quot;impossible&quot;&lt;&lt;endl; else printf(&quot;%d\\n&quot;,t); return 0; } 应用：spfa判断图中是否存在负权int n; // 总点数 int h[N], w[N], e[N], ne[N], idx; // 邻接表存储所有边 int dist[N], cnt[N]; // dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数 bool st[N]; // 存储每个点是否在队列中 // 如果存在负环，则返回true，否则返回false。 bool spfa() { // 不需要初始化dist数组 // 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。 queue&lt;int&gt; q; for (int i = 1; i &lt;= n; i ++ ) { q.push(i); st[i] = true; } while (q.size()) { auto t = q.front(); q.pop(); st[t] = false; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] &gt; dist[t] + w[i]) { dist[j] = dist[t] + w[i]; cnt[j] = cnt[t] + 1; if (cnt[j] &gt;= n) return true; // 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环 if (!st[j]) { q.push(j); st[j] = true; } } } } return false; } floyd算法时间复杂度O(n3)，n表示点数 视频讲解：https://www.bilibili.com/video/BV14R4y1x7GB/ 模板 初始化： for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= n; j ++ ) if (i == j) d[i][j] = 0; else d[i][j] = INF; // 算法结束后，d[a][b]表示a到b的最短距离 void floyd() { for (int k = 1; k &lt;= n; k ++ )//k为中转节点 for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= n; j ++ ) d[i][j] = min(d[i][j], d[i][k] + d[k][j]); } 应用 using namespace std; const int N = 210, INF = 1e9; int n, m, Q; int d[N][N]; void floyd() { for (int k = 1; k &lt;= n; k ++ )//k为中转节点 for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= n; j ++ ) d[i][j] = min(d[i][j], d[i][k] + d[k][j]); } int main() { scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;Q); for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= n; j ++ ) if (i == j) d[i][j] = 0; else d[i][j] = INF; while (m -- ) { int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); d[a][b] = min(d[a][b], c); } floyd(); while (Q -- ) { int a, b; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); int t = d[a][b]; if (t &gt; INF / 2) puts(&quot;impossible&quot;); else printf(&quot;%d\\n&quot;, t); } return 0; } 最短路算法总结最短路 单源最短路：给定V中的一个顶点，称为源。要计算从源到其他所有各顶点的最短路径长度。这里的长度就是指路上各边权之和。这个问题通常称为单源最短路径 问题。 所有边权都是正数： 朴素Dijkstra算法 O(n^2) 适合稠密图，贪心思想 堆优化版的Dijkstra算法 O(mlogn)适合稀疏图，贪心思想 ​ 存在负权边： ​ Bellman-ford O(nm)，动态规划思想 ​ SPFA 一般：O(m)，最坏O(nm) 多源汇最短路：任意两点最短路径被称为多源最短路径，即给定任意两个点，一个出发点，一个到达点，求这两个点的之间的最短路径，就是任意两点最短路径问题 Floyd算法 O(n^3) prim算法时间复杂度是O(n2+m)，n表示点数，m表示边数 int n; // n表示点数 int g[N][N]; // 邻接矩阵，存储所有边 int dist[N]; // 存储其他点到当前最小生成树的距离 bool st[N]; // 存储每个点是否已经在生成树中 // 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和 int prim() { memset(dist, 0x3f, sizeof dist); int res = 0; for (int i = 0; i &lt; n; i ++ ) { int t = -1; for (int j = 1; j &lt;= n; j ++ ) if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j])) t = j; if (i &amp;&amp; dist[t] == INF) return INF; if (i) res += dist[t]; st[t] = true; for (int j = 1; j &lt;= n; j ++ ) dist[j] = min(dist[j], g[t][j]); } return res; } 应用 const int N = 510, INF = 0x3f3f3f3f; int n, m; int g[N][N]; int dist[N]; bool st[N]; int prim() { memset(dist, 0x3f, sizeof dist); int res = 0; for (int i = 0; i &lt; n; i ++ ) { int t = -1; for (int j = 1; j &lt;= n; j ++ ) if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j])) t = j; if (i &amp;&amp; dist[t] == INF) return INF; if (i) res += dist[t]; st[t] = true; for (int j = 1; j &lt;= n; j ++ ) dist[j] = min(dist[j], g[t][j]); } return res; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); memset(g, 0x3f, sizeof g); while (m -- ) { int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); g[a][b] = g[b][a] = min(g[a][b], c); } int t = prim(); if (t == INF) puts(&quot;impossible&quot;); else printf(&quot;%d\\n&quot;, t); return 0; } Kruskal算法时间复杂度O(mlogm)，n表示点数，m表示边数 int n, m; // n是点数，m是边数 int p[N]; // 并查集的父节点数组 struct Edge // 存储边 { int a, b, w; bool operator&lt; (const Edge &amp;W)const { return w &lt; W.w; } }edges[M]; int find(int x) // 并查集核心操作 { if (p[x] != x) p[x] = find(p[x]); return p[x]; } int kruskal() { sort(edges, edges + m); for (int i = 1; i &lt;= n; i ++ ) p[i] = i; // 初始化并查集 int res = 0, cnt = 0; for (int i = 0; i &lt; m; i ++ ) { int a = edges[i].a, b = edges[i].b, w = edges[i].w; a = find(a), b = find(b); if (a != b) // 如果两个连通块不连通，则将这两个连通块合并 { p[a] = b; res += w; cnt ++ ; } } if (cnt &lt; n - 1) return INF; return res; } 应用 #include #include #include using namespace std; const int N = 100010, M = 200010, INF = 0x3f3f3f3f; int n, m; int p[N]; struct Edge { int a, b, w; bool operator&lt; (const Edge &amp;W)const { return w &lt; W.w; } }edges[M]; int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } int kruskal() { sort(edges, edges + m); for (int i = 1; i &lt;= n; i ++ ) p[i] = i; // 初始化并查集 int res = 0, cnt = 0; for (int i = 0; i &lt; m; i ++ ) { int a = edges[i].a, b = edges[i].b, w = edges[i].w; a = find(a), b = find(b); if (a != b) { p[a] = b; res += w; cnt ++ ; } } if (cnt &lt; n - 1) return INF; return res; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 0; i &lt; m; i ++ ) { int a, b, w; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;w); edges[i] = {a, b, w}; } int t = kruskal(); if (t == INF) puts(&quot;impossible&quot;); else printf(&quot;%d\\n&quot;, t); return 0; } 染色法判别二分图什么叫二分图 有两顶点集且图中每条边的的两个顶点分别位于两个顶点集中，每个顶点集中没有边直接相连接！ 说人话的定义：图中点通过移动能分成左右两部分，左侧的点只和右侧的点相连，右侧的点只和左侧的点相连。 下图就是个二分图： 时间复杂度是O(n+m)，n表示点数，m表示边数 int n; // n表示点数 int h[N], e[M], ne[M], idx; // 邻接表存储图 int color[N]; // 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色 // 参数：u表示当前节点，c表示当前点的颜色 bool dfs(int u, int c) { color[u] = c; for (int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if (color[j] == -1) { if (!dfs(j, !c)) return false; } else if (color[j] == c) return false; } return true; } bool check() { memset(color, -1, sizeof color); bool flag = true; for (int i = 1; i &lt;= n; i ++ ) if (color[i] == -1) if (!dfs(i, 0)) { flag = false; break; } return flag; } 应用using namespace std; const int N = 100010, M = 200010;// 由于是无向图, 顶点数最大是N，那么边数M最大是顶点数的2倍 int n, m; int h[N], e[M], ne[M], idx; int color[N]; void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ; } bool dfs(int u, int c) { color[u] = c; for (int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if (!color[j]) { if (!dfs(j, 3 - c)) return false; } else if (color[j] == c) return false; } return true; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); memset(h, -1, sizeof h); while (m -- ) { int a, b; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); add(a, b), add(b, a);// 无向图，a-&gt;b, b-&gt;a } bool flag = true; for (int i = 1; i &lt;= n; i ++ ) if (!color[i]) { if (!dfs(i, 1)) { flag = false; break; } } if (flag) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); return 0; } 匈牙利算法要了解匈牙利算法必须先理解下面的概念： 匹配：在图论中，一个「匹配」是一个边的集合，其中任意两条边都没有公共顶点。 最大匹配：一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配。 下面是一些补充概念： 完美匹配：如果一个图的某个匹配中，所有的顶点都是匹配点，那么它就是一个完美匹配。 交替路：从一个未匹配点出发，依次经过非匹配边、匹配边、非匹配边…形成的路径叫交替路。 增广路：从一个未匹配点出发，走交替路，如果途径另一个未匹配点（出发的点不算），则这条交替 路称为增广路（agumenting path）。 时间复杂度O(nm)，n表示点数，m表示边数 //遍历自己喜欢的女孩int n1, n2; // n1表示第一个集合中的点数，n2表示第二个集合中的点数 int h[N], e[M], ne[M], idx; // 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边 int match[N]; // 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个 bool st[N]; // 表示第二个集合中的每个点是否已经被遍历过 void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ; } bool find(int x) { //遍历自己喜欢的女孩 for (int i = h[x]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j])//如果在这一轮模拟匹配中,这个女孩尚未被预定 { st[j] = true;//那x就预定这个女孩了 //如果女孩j没有男朋友，或者她原来的男朋友能够预定其它喜欢的女孩。配对成功 if (match[j] == 0 || find(match[j])) { match[j] = x; return true; } } } //自己中意的全部都被预定了。配对失败。 return false; } // 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点 int res = 0; for (int i = 1; i &lt;= n1; i ++ ) { memset(st, false, sizeof st); if (find(i)) res ++ ; } 应用：二分图的最大匹配 匈牙利算法图示化 相关题解：[AcWing 861. 二分图的最大匹配—-图解 - AcWing]：https://www.acwing.com/solution/content/179030/ using namespace std; const int N = 510, M = 100010; int n1, n2, m; int h[N], e[M], ne[M], idx; int match[N]; bool st[N]; void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ; } bool find(int x) { // 和各个点尝试能否匹配 for (int i = h[x]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j])//打标记 { st[j] = true; // 当前尝试点没有被匹配或者和当前尝试点匹配的那个点可以换另一个匹配 if (match[j] == 0 || find(match[j])) { // 和当前尝试点匹配在一起 match[j] = x; return true; } } } return false; } int main() { scanf(&quot;%d%d%d&quot;, &amp;n1, &amp;n2, &amp;m); memset(h, -1, sizeof h); // 保存图，因为只从一遍找另一边，所以该无向图只需要存储一个方向 while (m -- ) { int a, b; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); add(a, b); } int res = 0; //为各个点找匹配 for (int i = 1; i &lt;= n1; i ++ ) { memset(st, false, sizeof st); //找到匹配 if (find(i)) res ++ ; } printf(&quot;%d\\n&quot;, res); return 0; } 四、数学知识算法的数学知识定理证明可以在这里查阅：[数学部分简介 - OI Wiki (oi-wiki.org)]：https://oi-wiki.org/math/ 试除法判定质数bool is_prime(int x) { if (x &lt; 2) return false; for (int i = 2; i &lt;= x / i; i ++ ) if (x % i == 0) return false; return true; } 试除法分解质因数void divide(int x) { for (int i = 2; i &lt;= x / i; i ++ ) if (x % i == 0)//i 一定是质数 { int s = 0; while (x % i == 0) x /= i, s ++ ; cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; s &lt;&lt; endl; } if (x &gt; 1) cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; 1 &lt;&lt; endl; cout &lt;&lt; endl; } 埃氏筛法求质数int primes[N], cnt; // primes[]存储所有素数 bool st[N]; // st[x]存储x是否被筛掉 void get_primes(int n) { for (int i = 2; i &lt;= n; i ++ ) { if (st[i]) continue; primes[cnt ++ ] = i; for (int j = i + i; j &lt;= n; j += i) st[j] = true; } } 线性筛法求质数算法动画讲解：https://www.bilibili.com/video/BV1LR4y1Z7pm int primes[N], cnt; // primes[]存储所有素数 bool st[N]; // st[x]存储x是否被筛掉 void get_primes(int n) { for (int i = 2; i &lt;= n; i ++ ) { if (!st[i]) primes[cnt ++ ] = i; for (int j = 0; primes[j] &lt;= n / i; j ++ ) { st[primes[j] * i] = true; if (i % primes[j] == 0) break; } } } 试除法求所有约数vector get_divisors(int x) { vector&lt;int&gt; res; for (int i = 1; i &lt;= x / i; i ++ ) if (x % i == 0) { res.push_back(i); if (i != x / i) res.push_back(x / i); } sort(res.begin(), res.end()); return res; } 约数个数约数个数定理和约数和定理公式推导：https://www.bilibili.com/video/BV13R4y1o777 约数个数定理推导：https://www.bilibili.com/video/BV1NY41187GM 约数个数.png using namespace std; typedef long long LL; const int N = 110, mod = 1e9 + 7; int main() { int n; cin &gt;&gt; n; unordered_map&lt;int, int&gt; primes; while (n -- ) { int x; cin &gt;&gt; x; for (int i = 2; i &lt;= x / i; i ++ ) while (x % i == 0) { x /= i; primes[i] ++ ; } if (x &gt; 1) primes[x] ++ ; } LL res = 1; for (auto p : primes) res = res * (p.second + 1) % mod; cout &lt;&lt; res &lt;&lt; endl; return 0; } 约数之和约数个数定理和约数和定理公式推导：https://www.bilibili.com/video/BV13R4y1o777 约数之和.png using namespace std; typedef long long LL; const int N = 110, mod = 1e9 + 7; int main() { int n; cin &gt;&gt; n; unordered_map&lt;int, int&gt; primes; while (n -- ) { int x; cin &gt;&gt; x; for (int i = 2; i &lt;= x / i; i ++ ) while (x % i == 0) { x /= i; primes[i] ++ ; } if (x &gt; 1) primes[x] ++ ; } LL res = 1; for (auto p : primes) { LL a = p.first, b = p.second; LL t = 1; while (b -- ) t = (t * a + 1) % mod;//遍历b次后得到t=p^b+p^(b-1)+...+p+1 res = res * t % mod; } cout &lt;&lt; res &lt;&lt; endl; return 0; } 代码第26行解释： 约数之和小公式推导.png 欧几里得算法(求最大公约数)int gcd(int a, int b) { return b ? gcd(b, a % b) : a; } 最小公倍数int lcm(int a, int b) { return abs(a * b) / gcd(a, b); } 求欧拉函数前置知识 互质：互质是公约数只有1的两个整数，叫做互质整数。 欧拉函数定义 1∼N−1 中与N互质的数的个数被称为欧拉函数，记为ϕ(N)。 若在算数基本定理中，N=pa11pa22…pamm，则： ϕ(N)=N⋅p1−1p1⋅p2−1p2⋅…⋅pm−1pm 欧拉函数推导 首先我们要知道1,2,3…N−1,N与N互质的个数是1∼N数列去除N的质因子的倍数。 例如N=10,即1,2,3,4,5,6,7,8,9,10去除N的质因子的倍数, 则1,\\bcancel2,3,\\bcancel4,\\bcancel5,\\bcancel6,7,\\bcancel8,9,\\bcancel10. 显然，1,3,7,9与10互质。 由上方结论使用容斥原理进行数学推导如下： 代码模板int phi(int x) { int res = x; for (int i = 2; i &lt;= x / i; i ++ ) if (x % i == 0) { res = res / i * (i - 1); while (x % i == 0) x /= i; } if (x &gt; 1) res = res / x * (x - 1); return res; } 线性筛法求欧拉函数int primes[N], cnt; // primes[]存储所有素数 int euler[N]; // 存储每个数的欧拉函数 bool st[N]; // st[x]存储x是否被筛掉 void get_eulers(int n) // 线性筛法求1~n的欧拉函数 { euler[1] = 1; for (int i = 2; i &lt;= n; i ++ ) { if (!st[i]) { primes[cnt ++ ] = i; euler[i] = i - 1; } for (int j = 0; primes[j] &lt;= n / i; j ++ ) { int t = primes[j] * i; st[t] = true; if (i % primes[j] == 0) { euler[t] = euler[i] * primes[j]; break; } euler[t] = euler[i] * (primes[j] - 1); } } } 快速幂快速幂公式证明：[快速幂 - OI Wiki (oi-wiki.org)]：https://oi-wiki.org/math/binary-exponentiation/ // 求 m^k mod p，时间复杂度 O(logk)。 // m为底数，k为幂 int qmi(int m, int k, int p) { int res = 1 % p, t = m; while (k) { if (k&amp;1) res = res * t % p; t = t * t % p; k &gt;&gt;= 1; } return res; } 扩展欧几里得算法扩展欧几里得算法讲解：https://www.bilibili.com/video/BV1KU4y1a7E2/ 优秀题解：https://www.acwing.com/solution/content/1393 优秀博客：https://blog.csdn.net/mango114514/article/details/121048335 x的第一个正解就是(x%k+k)%k 其中，k=b/gcd(a,b) // 求x, y，使得ax + by = gcd(a, b) int exgcd(int a, int b, int &amp;x, int &amp;y) { if (!b) { x = 1, y = 0; return a; } int d = exgcd(b, a % b, y, x); y -= (a/b) * x; return d; } 中国剩余定理中国剩余定理讲解：https://www.bilibili.com/video/BV1AN4y1N7Su/ 中国剩余定理.png LL exgcd(LL a,LL b,LL &amp;x,LL &amp;y){ if(b==0){ x=1,y=0; return a; } LL d=exgcd(b,a%b,y,x); y -= (a/b) * x; return d; } LL CRT(LL m[],LL r[]){ LL m=1,ans=0; for(int i=1;i&lt;=n;i++)M*=m[i]; for(int i=1;i&lt;=n;i++){ LL c=M/m[i],x,y; exgcd(c,m[i],x,y); ans=(ans+r[i]*c*x%M)%M; } return (ans%M+M)%M; } 扩展中国剩余定理扩展中国剩余定理讲解：https://www.bilibili.com/video/BV1Ut4y1F7HG/ 扩展中国剩余定理.png LL exgcd(LL a,LL b,LL &amp;x,LL &amp;y){ if(b==0){ x=1,y=0; return a; } LL d=exgcd(b,a%b,y,x); y -= (a/b) * x; return d; } LL EXCRT(LL m[],LL r[]){ LL m1,m2,r1,r2,p,q; m1=m[1],r1=r[1]; for(int i=2;i&lt;=n;i++){ m2=m[i],r2=r[i]; LL d = exgcd(m1,m2,p,q); if((r2-r1)%d){ return -1; } p=p*(r2-r1)/d;//特解 p=(p%(m2/d)+m2/d)%(m2/d); r1=m1*p+r1; m1=m1*m2/d; } return (r1%m1+m1)%m1; } 高斯消元法高斯消元 O(n3) 求解例如下面方程组 ⎧⎩⎨⎪⎪⎪⎪⎪⎪a11x1+a12x2+…+a1nxn=b1a21x1+a22x2+…+a2nxn=b2⋮⋮⋮⋮an1x1+an2x2+…+annxn=bn 高斯消元讲解：https://www.bilibili.com/video/BV1Kd4y127vZ/ 模板// a[N][N]是增广矩阵 int gauss() { int c, r; for (c = 0, r = 0; c &lt; n; c ++ ) { int t = r; for (int i = r; i &lt; n; i ++ ) // 找到绝对值最大的行 if (fabs(a[i][c]) &gt; fabs(a[t][c])) t = i; if (fabs(a[t][c]) &lt; eps) continue; for (int i = c; i &lt;= n; i ++ ) swap(a[t][i], a[r][i]); // 将绝对值最大的行换到最顶端 for (int i = n; i &gt;= c; i -- ) a[r][i] /= a[r][c]; // 将当前行的首位变成1 for (int i = r + 1; i &lt; n; i ++ ) // 用当前行将下面所有的列消成0 if (fabs(a[i][c]) &gt; eps) for (int j = n; j &gt;= c; j -- ) a[i][j] -= a[r][j] * a[i][c]; r ++ ; } if (r &lt; n) { for (int i = r; i &lt; n; i ++ ) if (fabs(a[i][n]) &gt; eps) return 2; // 无解 return 1; // 有无穷多组解 } for (int i = n - 1; i &gt;= 0; i -- ) for (int j = i + 1; j &lt; n; j ++ ) a[i][n] -= a[i][j] * a[j][n]; return 0; // 有唯一解 } 应用using namespace std; const int N = 110; const double eps = 1e-6; int n; double a[N][N]; int gauss() { int c, r;// c 代表 列 col ， r 代表 行 row for (c = 0, r = 0; c &lt; n; c ++ ) { int t = r;// 先找到当前这一列，绝对值最大的一个数字所在的行号 for (int i = r; i &lt; n; i ++ ) if (fabs(a[i][c]) &gt; fabs(a[t][c])) t = i; if (fabs(a[t][c]) &lt; eps) continue;// 如果当前这一列的最大数都是 0 ，那么所有数都是 0，就没必要去算了，因为它的约束方程，可能在上面几行 for (int i = c; i &lt; n + 1; i ++ ) swap(a[t][i], a[r][i]);//// 把当前这一行，换到最上面（不是第一行，是第 r 行）去 for (int i = n; i &gt;= c; i -- ) a[r][i] /= a[r][c];// 把当前这一行的第一个数，变成 1， 方程两边同时除以 第一个数，必须要到着算，不然第一个数直接变1，系数就被篡改，后面的数字没法算 for (int i = r + 1; i &lt; n; i ++ )// 把当前列下面的所有数，全部消成 0 if (fabs(a[i][c]) &gt; eps)// 如果非0 再操作，已经是 0就没必要操作了 for (int j = n; j &gt;= c; j -- )// 从后往前，当前行的每个数字，都减去对应列 * 行首非0的数字，这样就能保证第一个数字是 a[i][0] -= 1*a[i][0]; a[i][j] -= a[r][j] * a[i][c]; r ++ ;// 这一行的工作做完，换下一行 } if (r &lt; n)// 说明剩下方程的个数是小于 n 的，说明不是唯一解，判断是无解还是无穷多解 {// 因为已经是阶梯型，所以 r ~ n-1 的值应该都为 0 for (int i = r; i &lt; n; i ++ )// if (fabs(a[i][n]) &gt; eps)// a[i][n] 代表 b_i ,即 左边=0，右边=b_i,0 != b_i, 所以无解。 return 2; return 1;// 否则， 0 = 0，就是r ~ n-1的方程都是多余方程 } // 唯一解 ↓，从下往上回代，得到方程的解 for (int i = n - 1; i &gt;= 0; i -- ) for (int j = i + 1; j &lt; n; j ++ ) a[i][n] -= a[j][n] * a[i][j];//因为只要得到解，所以只用对 b_i 进行操作，中间的值，可以不用操作，因为不用输出 return 0; } int main() { cin &gt;&gt; n; for (int i = 0; i &lt; n; i ++ ) for (int j = 0; j &lt; n + 1; j ++ ) cin &gt;&gt; a[i][j]; int t = gauss(); if (t == 0) { for (int i = 0; i &lt; n; i ++ ) printf(&quot;%.2lf\\n&quot;, a[i][n]); } else if (t == 1) puts(&quot;Infinite group solutions&quot;); else puts(&quot;No solution&quot;); return 0; } 求组合数递推法求组合数排列组合详细讲解：https://www.bilibili.com/video/BV1e7411J7SC/ 杨辉三角.png 杨辉三角组合数.png // c[a][b] 表示从a个苹果中选b个的方案数 int c[N][N]; for (int i = 0; i &lt; N; i ++ ) for (int j = 0; j &lt;= i; j ++ ) if (!j) c[i][j] = 1; else c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod; //本质上杨辉三角 通过预处理逆元的方式求组合数模板// 首先预处理出所有阶乘取模的余数fact[N]，以及所有阶乘取模的逆元infact[N] // 如果取模的数是质数，可以用费马小定理求逆元 int qmi(int a, int k, int p) // 快速幂模板 { int res = 1; while (k) { if (k &amp; 1) res = (LL)res * a % p; a = (LL)a * a % p; k &gt;&gt;= 1; } return res; } // 预处理阶乘的余数和阶乘逆元的余数 fact[0] = infact[0] = 1; for (int i = 1; i &lt; N; i ++ ) { fact[i] = (LL)fact[i - 1] * i % mod; infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod; } 应用using namespace std; typedef long long LL; const int N = 100010,mod=1e9+7;//1e9+7是质数所以与[1,1e9+7)中的数互质 int fact[N],infact[N]; int qmi(int a,int k,int p){ int res=1; while(k){ if(k&amp;1)res=(LL)res*a%p; a=(LL)a*a%p; k&gt;&gt;=1; } return res; } int main() { fact[0]=infact[0]=1; for (int i = 1; i &lt;= N; i ++ ){ fact[i]=(LL)fact[i-1]*i%mod; infact[i]=(LL)infact[i-1]*qmi(i,mod-2,mod)%mod; } int n; scanf(&quot;%d&quot;,&amp;n); while (n -- ){ int a,b; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); printf(&quot;%d\\n&quot;,(LL)fact[a]*infact[b]%mod*infact[a-b]%mod); } return 0; } Lucas定理求组合数Lucas定理证明：https://blog.csdn.net/Qiuker_jl/article/details/109528164 模板// 若p是质数，则对于任意整数 1 &lt;= m &lt;= n，有： // C(n, m) = C(n % p, m % p) * C(n / p, m / p) (mod p) int qmi(int a, int k, int p) // 快速幂模板 { int res = 1 % p; while (k) { if (k &amp; 1) res = (LL)res * a % p; a = (LL)a * a % p; k &gt;&gt;= 1; } return res; } int C(int a, int b, int p) // 通过定理求组合数C(a, b) { if (a &lt; b) return 0; LL x = 1, y = 1; // x是分子，y是分母 for (int i = a, j = 1; j &lt;= b; i --, j ++ ) { x = (LL)x * i % p; y = (LL) y * j % p; } return x * (LL)qmi(y, p - 2, p) % p; } int lucas(LL a, LL b, int p) { if (a &lt; p &amp;&amp; b &lt; p) return C(a, b, p); return (LL)C(a % p, b % p, p) * lucas(a / p, b / p, p) % p; } 应用using namespace std; typedef long long LL; int qmi(int a,int k,int p) { int res = 1; while(k) { if(k&amp;1)res = (LL)res*a%p; a = (LL)a*a%p; k&gt;&gt;=1; } return res; } int C(int a,int b,int p)//自变量类型int { if(b&gt;a)return 0;//漏了边界条件 int res = 1; // a!/(b!(a-b)!) = (a-b+1)*...*a / b! 分子有b项 for(int i=1,j=a;i&lt;=b;i++,j--)//i&lt;=b而不是&lt; { res = (LL)res*j%p; res = (LL)res*qmi(i,p-2,p)%p; } return res; } //对公式敲 int lucas(LL a,LL b,int p) { if(a&lt;p &amp;&amp; b&lt;p)return C(a,b,p);//lucas递归终点是C_{bk}^{ak} return (LL)C(a%p,b%p,p)*lucas(a/p,b/p,p)%p;//a%p后肯定是&lt;p的,所以可以用C(),但a/p后不一定&lt;p 所以用lucas继续递归 } int main() { int n; cin &gt;&gt; n; while(n--) { LL a,b; int p; cin &gt;&gt; a &gt;&gt; b &gt;&gt; p; cout &lt;&lt; lucas(a,b,p) &lt;&lt; endl; } return 0; } 分解质因数法求组合数模板当我们需要求出组合数的真实值，而非对某个数的余数时，分解质因数的方式比较好用： 1. 筛法求出范围内的所有质数 2. 通过 C(a, b) = a! / b! / (a - b)! 这个公式求出每个质因子的次数。 n! 中p的次数是 n / p + n / p^2 + n / p^3 + ... 3. 用高精度乘法将所有质因子相乘 int primes[N], cnt; // 存储所有质数 int sum[N]; // 存储每个质数的次数 bool st[N]; // 存储每个数是否已被筛掉 void get_primes(int n) // 线性筛法求素数 { for (int i = 2; i &lt;= n; i ++ ) { if (!st[i]) primes[cnt ++ ] = i; for (int j = 0; primes[j] &lt;= n / i; j ++ ) { st[primes[j] * i] = true; if (i % primes[j] == 0) break; } } } int get(int n, int p) // 求n！中的次数 { int res = 0; while (n) { res += n / p; n /= p; } return res; } vector mul(vector a, int b) // 高精度乘低精度模板 { vector&lt;int&gt; c; int t = 0; for (int i = 0; i &lt; a.size(); i ++ ) { t += a[i] * b; c.push_back(t % 10); t /= 10; } while (t) { c.push_back(t % 10); t /= 10; } return c; } get_primes(a); // 预处理范围内的所有质数 for (int i = 0; i &lt; cnt; i ++ ) // 求每个质因数的次数 { int p = primes[i]; sum[i] = get(a, p) - get(b, p) - get(a - b, p); } vector res; res.push_back(1); for (int i = 0; i &lt; cnt; i ++ ) // 用高精度乘法将所有质因子相乘 for (int j = 0; j &lt; sum[i]; j ++ ) res = mul(res, primes[i]); 应用using namespace std; const int N = 5010; int primes[N],cnt=0; // v[i] 记录数字 i 为素数还是合数，v[i]=true时 i 为合数，否则 i 为素数 bool v[N]; // sum[i]=c 表示质数 i 的个数为 c int sum[N]; // 线性筛法 void get_primes(int n) { for(int i=2;i&lt;=n;++i) { // i为质数，则存在primes中 if(!v[i])primes[cnt++]=i; // 给当前数i乘上一个质因子pj for(int j=0;primes[j]&lt;=n/i;++j) { v[primes[j]*i]=true; if(i%primes[j]==0)break; } } } // 计算 n 里面含有质数 p 的个数，这里的计算是不重不漏的。 // p^k的倍数会被计算k次：第一次算p的倍数时，被加一次；第二次算p^2的倍数时，被加一次；第三次算p^3的倍数时，被加一次…第k次算p^k的倍数时，被加一次。总共被加了k次，是不重不漏的。 int get(int n,int p) { int res=0; while(n) { res+=n/p; n/=p; } return res; } // A * b：把 b 看成一个整体，然后与 A 中每一位相乘，A中的数字采用小端存储，即低位数字存储在数组的前面，高位数字存储在数组的后面 vector mul(const vector&amp; A,const int b) { if(b==0)return {0}; vector&lt;int&gt; res; // t 表示乘法进位，这里的进位不限于0 1，可以为任意数字 for(int i=0,t=0,n=A.size();i&lt;n||t&gt;0;++i) { // 获得当前位的乘积和 if(i&lt;n)t+=A[i]*b; // 添加个位数字 res.push_back(t%10); // 保留进位 t/=10; } // 如 1234 * 0 = 0000，需要删除前导0 while(res.size()&gt;1&amp;&amp;res.back()==0)res.pop_back(); return res; } int main() { int a,b;cin&gt;&gt;a&gt;&gt;b; // 将 a 分解质因数 get_primes(a); for(int i=0;i&lt;cnt;++i) { // 当前的质数为 p int p=primes[i]; // 用分子里面 p 的个数减去分母里面 p 的个数。这里的计算组合数的公式为a!/(b!*(a-b)!)，因此用 a 里面 p 的个数减去 b 里面 p 的个数和 (a-b) 里面 p 的个数。 sum[i]=get(a,p)-get(b,p)-get(a-b,p); } // 使用高精度乘法把所有质因子乘到一块去就好了 vector&lt;int&gt; res={1}; for(int i=0;i&lt;cnt;++i) // res*p^k，这里是k个p相乘，不是k*p，所以需要使用一个循环 for(int j=0;j&lt;sum[i];++j) res=mul(res,primes[i]); // 倒序打印 res 即可，由于采用小端存储，所以高位在后，从后往前打印即可 for(int i=res.size()-1;i&gt;=0;i--)printf(&quot;%d&quot;,res[i]); return 0; } 容斥原理应用经典例题：[890. 能被整除的数 - AcWing题库]：https://www.acwing.com/problem/content/892/ AC代码： using namespace std; typedef long long LL; const int N = 20; int p[N], n, m; int main() { cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; m; i++) cin &gt;&gt; p[i]; int res = 0; //枚举从1 到 1111…(m个1)的每一个集合状态, (至少选中一个集合) for(int i = 1; i &lt; 1 &lt;&lt; m; i++) { int t = 1; //选中集合对应质数的乘积 int s = 0; //选中的集合数量 //枚举当前状态的每一位 for(int j = 0; j &lt; m; j++){ //选中一个集合 if(i &gt;&gt; j &amp; 1){ //乘积大于n, 则n/t = 0, 跳出这轮循环 if((LL)t * p[j] &gt; n){ t = -1; break; } s++; //有一个1，集合数量+1 t *= p[j]; } } if(t == -1) continue; if(s &amp; 1) res += n / t; //选中奇数个集合, 则系数应该是1, n/t为当前这种状态的集合数量 else res -= n / t; //反之则为 -1 } cout &lt;&lt; res &lt;&lt; endl; return 0; } 详细题解：[AcWing 890. 能被整除的数 - AcWing]：https://www.acwing.com/solution/content/29702/ 博弈论NIM游戏定理1：必胜态的后继状态至少存在一个必败态 定理2：必败态的后继状态均为必胜态 NIM游戏科普：[尼姆游戏（学霸就是这样欺负人的）_哔哩哔哩_bilibili]：https://www.bilibili.com/video/BV1ek4y1q7JD/ [再看nim游戏_哔哩哔哩_bilibili]：https://www.bilibili.com/video/BV1nt4y1C7Sk/ 经典例题：[P2197 【模板】nim 游戏 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)]：https://www.luogu.com.cn/problem/P2197 AC代码： using namespace std; int T; int main() { cin &gt;&gt; T; while (T--) { int n; scanf(&quot;%d&quot;, &amp;n); int ans = 0; for (int i = 0; i &lt; n; i++) { int k; scanf(&quot;%d&quot;, &amp;k); ans ^= k; } if (ans) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); } return 0; } 结论： 若初态为必胜态(a1⊕a2⊕…⊕an≠0 ).则先手必胜 若初态为必败态(a1⊕a2⊕…⊕an=0 ).则先手必败 视频讲解：[581 尼姆（Nim）游戏【博弈论】_哔哩哔哩_bilibili]：https://www.bilibili.com/video/BV1ns4y1D7dg/ 台阶型NIM游戏 经典例题：[892. 台阶-Nim游戏 - AcWing题库]：https://www.acwing.com/problem/content/894/ AC代码： using namespace std; const int N = 100010; int main() { int n; scanf(&quot;%d&quot;, &amp;n); int res = 0; for (int i = 1; i &lt;= n; i ++ ) { int x; scanf(&quot;%d&quot;, &amp;x); if (i &amp; 1) res ^= x; } if (res) puts(&quot;Yes&quot;); else puts(“No”); return 0; } 结论：若奇数台阶上的a1⊕a3⊕a5⊕…≠0，则先手必胜，反之先手必败。 视频讲解：[582 台阶型 Nim游戏【博弈论】_哔哩哔哩_bilibili]：https://www.bilibili.com/video/BV18M411M7TC/ 集合型NIM游戏 经典例题：[893. 集合-Nim游戏 - AcWing题库]：https://www.acwing.com/problem/content/895/ AC代码： using namespace std; const int N=110,M=10010; int n,m; int f[M],s[N];//s存储的是可供选择的集合,f存储的是所有可能出现过的情况的sg值 int sg(int x) { if(f[x]!=-1) return f[x]; //因为取石子数目的集合是已经确定了的,所以每个数的sg值也都是确定的,如果存储过了,直接返回即可 unordered_set&lt;int&gt; S; //set代表的是有序集合(注:因为在函数内部定义,所以下一次递归中的S不与本次相同) for(int i=0;i&lt;m;i++) { int sum=s[i]; if(x&gt;=sum) S.insert(sg(x-sum)); //先延伸到终点的sg值后,再从后往前排查出所有数的sg值 } for(int i=0;;i++) //循环完之后可以进行选出最小的没有出现的自然数的操作 if(!S.count(i)) return f[x]=i; } int main() { cin&gt;&gt;m; for(int i=0;i&lt;m;i++) cin&gt;&gt;s[i]; cin&gt;&gt;n; memset(f,-1,sizeof(f));//初始化f均为-1,方便在sg函数中查看x是否被记录过 int res=0; for(int i=0;i&lt;n;i++) { int x; cin&gt;&gt;x; res^=sg(x); //观察异或值的变化,基本原理与Nim游戏相同 } if(res) printf(&quot;Yes&quot;); else printf(&quot;No&quot;); return 0; } 思路：转换成有向图游戏 视频讲解：[583 有向图游戏 SG函数【博弈论】_哔哩哔哩_bilibili]：https://www.bilibili.com/video/BV1eT411B7A8/ 五、动态规划动态规划三大特征：最优子结构、无后效性、重复子问题 闫式dp分析法.jpg 背包问题01背包每件物品只能装一次 完全背包每件物品可以装无限次 多重背包每件物品只能装有限次（多次） 分组背包每组只能选择一件物品装入（01背包升级） 相关链接：https://zhuanlan.zhihu.com/p/166439661 01背包问题 01背包每件物品只能装一次 视频讲解：[408 背包DP【模板】01背包_哔哩哔哩_bilibili]：https://www.bilibili.com/video/BV1kp4y1e794/ 01背包DP分析.png 01背包.png using namespace std; const int N=1010; int n,m; int v[N],w[N];//v代表体积，w代表价值 int f[N][N]; int main(){ cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++)cin&gt;&gt;v[i]&gt;&gt;w[i]; for(int i=1;i&lt;=n;i++)//i代表这n件物品 { for(int j=1;j&lt;=m;j++){//j代表背包容量 if(v[i]&gt;j)//如果v[i]的容量大于当前的背包容量则不装进行下一个 f[i][j]=f[i-1][j]; else f[i][j]=max(f[i-1][j],f[i-1][j-v[i]]+w[i]);//如果v[i]的容量小于当前背包容量则可以选择装与不装得到最大值 } } cout&lt;&lt;f[n][m]&lt;&lt;endl;//输出最后的一个一定是最大的 return 0; } 01背包，使用滚动数组，倒序遍历 using namespace std; const int N=1010; int n,m; int v[N],w[N];//v代表体积，w代表价值 int dp[N]; int main(){ cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++)//i代表这n件物品 { cin&gt;&gt;v[i]&gt;&gt;w[i];//在线算法 for(int j=m;j&gt;=v[i];j--){//j代表背包容量，滚动数组必须倒序遍历 dp[j]=max(dp[j],dp[j-v[i]]+w[i]);//滚动数组 } } cout&lt;&lt;dp[m]&lt;&lt;endl;//输出最后的一个一定是最大的 return 0; } 状态转移方程：dp[j]=max(dp[j],dp[j-v[i]]+w[i]); 完全背包问题完全背包每件物品可以装无限次 视频讲解：[409 背包DP 完全背包【动态规划】_哔哩哔哩_bilibili]：https://www.bilibili.com/video/BV15v411y7Qz/ using namespace std; int v[N],w[N]; int dp[N]; int main(){ int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++){//遍历物品 cin&gt;&gt;v[i]&gt;&gt;w[i];//在线算法 for(int j=v[i];j&lt;=m;j++){//正序遍历背包容量 dp[j]=max(dp[j],dp[j-v[i]]+w[i]);//滚动数组 } } cout&lt;&lt;dp[m]&lt;&lt;endl;//输出答案 return 0; } 完全背包问题和01背包优化版的区别在于第二重循环的v[i]和m做交换 状态转移方程：dp[j]=max(dp[j],dp[j-v[i]]+w[i]); 多重背包问题1多重背包每件物品只能装有限次（多次） using namespace std; int n,m; int v[N],w[N],s[N]; int dp[N][N]; int main(){ cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++)cin&gt;&gt;v[i]&gt;&gt;w[i]&gt;&gt;s[i]; for(int i=1;i&lt;=n;i++)//物品 for(int j=0;j&lt;=m;j++)//背包容量 for(int k=0;k&lt;=s[i]&amp;&amp;k*v[i]&lt;=j;k++) dp[i][j]=max(dp[i][j],dp[i-1][j-v[i]*k]+w[i]*k); cout&lt;&lt;dp[n][m]&lt;&lt;endl; return 0; } 状态转移方程：dp[i][j]=max(dp[i][j],dp[i-1][j-v[i]*k]+w[i]*k);k为第i个物品的个数 多重背包问题2(二进制优化)思路：转换成2进制，再用01背包求解 视频讲解：[410 背包DP 多重背包 二进制优化【动态规划】_哔哩哔哩_bilibili]：https://www.bilibili.com/video/BV1MA41177cg/ using namespace std; const int N = 12010, M = 2010; int n, m; int v[N], w[N]; int f[M]; int main() { cin &gt;&gt; n &gt;&gt; m; int cnt = 0; for (int i = 1; i &lt;= n; i ++ ) { int a, b, s; cin &gt;&gt; a &gt;&gt; b &gt;&gt; s; int k = 1; while (k &lt;= s) { cnt ++ ; v[cnt] = a * k; w[cnt] = b * k; s -= k; k *= 2; } if (s &gt; 0) { cnt ++ ; v[cnt] = a * s; w[cnt] = b * s; } }//二进制优化操作 n = cnt; for (int i = 1; i &lt;= n; i ++ ) for (int j = m; j &gt;= v[i]; j -- ) f[j] = max(f[j], f[j - v[i]] + w[i]); cout &lt;&lt; f[m] &lt;&lt; endl; return 0; } 分组背包问题分组背包每组只能选择一件物品装入 视频讲解：[416 背包DP 分组背包【动态规划】_哔哩哔哩_bilibili]：https://www.bilibili.com/video/BV16a411w77X/ using namespace std; const int N=110; int f[N]; int v[N][N],w[N][N],s[N]; int n,m,k; int main(){ cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++){ cin&gt;&gt;s[i]; for(int j=0;j&lt;s[i];j++){ cin&gt;&gt;v[i][j]&gt;&gt;w[i][j]; } } for(int i=0;i&lt;n;i++){ for(int j=m;j&gt;=0;j--){ for(int k=0;k&lt;s[i];k++){ //for(int k=s[i];k&gt;=1;k--)也可以 if(j&gt;=v[i][k]) f[j]=max(f[j],f[j-v[i][k]]+w[i][k]); } } } cout&lt;&lt;f[m]&lt;&lt;endl; } 状态转移方程：f[j]=max(f[j],f[j-v[i][k]]+w[i][k]); 线性DP 数字三角形 视频讲解：[402 线性DP 数字三角形【动态规划】_哔哩哔哩_bilibili]：https://www.bilibili.com/video/BV1Rk4y1173p/ 数字三角形DP分析.png using namespace std; const int N=510,INF=1e9; int n; int a[N][N]; int f[N][N]; int main(){ scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=i;j++){ scanf(&quot;%d&quot;,&amp;a[i][j]); } } for(int i=0;i&lt;=n;i++){ for(int j=0;j&lt;=i+1;j++){ f[i][j]=-INF; } } f[1][1]=a[1][1]; for(int i=2;i&lt;=n;i++) for(int j=1;j&lt;=i;j++) f[i][j]=max(f[i-1][j-1]+a[i][j],f[i-1][j]+a[i][j]);//状态转移方程 int res=-INF; for(int i=1;i&lt;=n;i++)res=max(res,f[n][i]); printf(&quot;%d&quot;,res); return 0; } 状态转移方程：f[i][j]=max(f[i-1][j-1]+a[i][j],f[i-1][j]+a[i][j]); 最长上升子序列1视频讲解：[403 线性DP 最长上升子序列【动态规划】_哔哩哔哩_bilibili]：https://www.bilibili.com/video/BV1KK4y1e7t7/ using namespace std; const int N = 1010; int n; int a[N],f[N]; int main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i ++ )scanf(&quot;%d&quot;,&amp;a[i]); for (int i = 1; i &lt;= n; i ++ ){ f[i]=1;//只有a[i]一个数 for (int j = 1; j &lt;= i; j ++ ) if(a[j]&lt;a[i]) f[i]=max(f[i],f[j]+1); } int res=0; for (int i = 1; i &lt;= n; i ++ )res=max(res,f[i]); printf(&quot;%d\\n&quot;,res); return 0; } 状态转移方程：if(a[j]&lt;a[i])f[i]=max(f[i],f[j]+1); 最长上升子序列2(二分优化)视频讲解：[404 线性DP 最长上升子序列 二分优化_哔哩哔哩_bilibili]：https://www.bilibili.com/video/BV1Kp4y1e77H/ using namespace std; const int N = 100010; int n; int a[N]; int q[N]; int main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i ++ ) scanf(&quot;%d&quot;, &amp;a[i]); int len = 0; for (int i = 0; i &lt; n; i ++ ) { int l = 0, r = len; while (l &lt; r) { int mid = l + r + 1 &gt;&gt; 1; if (q[mid] &lt; a[i]) l = mid; else r = mid - 1; } len = max(len, r + 1); q[r + 1] = a[i];//替换或添加 } printf(&quot;%d\\n&quot;, len); return 0; } 最长公共子序列视频讲解：[405 线性DP 最长公共子序列【动态规划】_哔哩哔哩_bilibili]：https://www.bilibili.com/video/BV1EK411K7Eb/ using namespace std; const int N=1010; int n,m; char a[N],b[N]; int f[N][N]; int main() { cin&gt;&gt;n&gt;&gt;m&gt;&gt;a+1&gt;&gt;b+1; for (int i = 1; i &lt;= n; i ++ ){ for (int j = 1; j &lt;= m; j ++ ){ f[i][j]=max(f[i-1][j],f[i][j-1]); if(a[i]==b[j])f[i][j]=max(f[i][j],f[i-1][j-1]+1); } } cout&lt;&lt;f[n][m]&lt;&lt;endl; return 0; } 状态转移方程： f[i][j]=max(f[i-1][j],f[i][j-1]); if(a[i]==b[j])f[i][j]=max(f[i][j],f[i-1][j-1]+1); 最短编辑距离给定两个字符串 A和 B，现在要将 A 经过若干操作变为 B，可进行的操作有： 删除–将字符串 A中的某个字符删除。 插入–在字符串 A 的某个位置插入某个字符。 替换–将字符串 A中的某个字符替换为另一个字符。 现在请你求出，将 A变为 B 至少需要进行多少次操作。 视频讲解：[407 线性DP 编辑距离【动态规划】_哔哩哔哩_bilibili]：https://www.bilibili.com/video/BV1gk4y1177j/ 闫氏DP分析法【最短编辑距离】.png using namespace std; const int N = 1010; int n,m; char a[N],b[N]; int f[N][N]; int main() { scanf(&quot;%d%s&quot;, &amp;n, a+1); scanf(&quot;%d%s&quot;, &amp;m, b+1); for (int i = 0; i &lt;= m; i ++ )f[0][i]=i; for (int i = 0; i &lt;= n; i ++ )f[i][0]=i;//初始化字符串的编辑操作 for (int i = 1; i &lt;= n; i ++ ){ for (int j = 1; j &lt;= m; j ++ ){ f[i][j]=min(f[i-1][j]+1,f[i][j-1]+1); if(a[i]==b[j])f[i][j]=min(f[i][j],f[i-1][j-1]); else f[i][j]=min(f[i][j],f[i-1][j-1]+1);//状态转移方程 } } printf(&quot;%d\\n&quot;,f[n][m]); return 0; } 状态转移方程: f[i][j]=min(f[i-1][j]+1,f[i][j-1]+1); if(a[i]==b[j])f[i][j]=min(f[i][j],f[i-1][j-1]); else f[i][j]=min(f[i][j],f[i-1][j-1]+1);//状态转移方程 区间DP石子合并每堆石子有一定的质量，可以用一个整数来描述，现在要将这 N堆石子合并成为一堆。 每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同。 视频讲解：[428 区间DP【模板】石子合并_哔哩哔哩_bilibili]：https://www.bilibili.com/video/BV1gz4y1y7Rv/ 闫氏DP分析法 using namespace std; const int N = 310; int n; int s[N]; int f[N][N];//状态表示：集合f[l][r]为[l,r]区间；属性：所堆成的最小值 int main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i ++ )scanf(&quot;%d&quot;,&amp;s[i]); for (int i = 1; i &lt;= n; i ++ )s[i]+=s[i-1];//前缀和用来求一段区间的和 for (int len = 2; len &lt;= n; len ++ )//区间长度为len//枚举长度 for (int i = 1; i+len-1 &lt;= n; i ++ ){//意思就是i在区间[1,n-len+1]中去//枚举区间 int l=i,r=i+len-1;//区间在[i,i+len-1]中间长度为len//设置l和r的区间 f[l][r]=1e9;//初始化最大值 for (int k = l; k &lt; r; k ++ )//枚举分界点//不取r f[l][r]=min(f[l][r],f[l][k]+f[k+1][r]+s[r]-s[l-1]);//找到最小值状态转移方程为f[l][k]+f[k+1][r]+s[r]-s[l-1]; } printf(&quot;%d\\n&quot;,f[1][n]);//输出区间[1,n]的最小值 return 0; } 状态转移方程找到最小值状态转移方程为f[l][r]=min(f[l][r],f[l][k]+f[k+1][r]+s[r]-s[l-1]) 计数类DP整数划分一个正整数 n 可以表示成若干个正整数之和，我们将这样的一种表示称为正整数 n 的一种划分。 现在给定一个正整数 n，请你求出 n共有多少种不同的划分方法。 完全背包写法 //完全背包的写法 using namespace std; const int M=1e9+7; int f[1010],n; int main() { cin&gt;&gt;n; f[0]=1; for (int i = 1; i &lt;= n; i ++ ) for (int j = i; j &lt;= n; j ++ ){ f[j]=(f[j-i]+f[j])%M; } cout&lt;&lt;f[n]&lt;&lt;endl; return 0; } 状态转移方程：f[j]=(f[j-i]+f[j]) 数位统计DP计数问题题目链接：[338. 计数问题 - AcWing题库]：https://www.acwing.com/problem/content/340/ 计数问题分类讨论.png using namespace std; //因为我们举的分类中，有需要求一串数字中某个区间的数字，例如abcdefg有一个分类需要求出efg+1 int get(vector num,int l,int r){ int res=0; for(int i=l;i&gt;=r;i--)res=res*10+num[i];//这里从小到大枚举的是因为下面count的时候读入数据是从最低为读到最高位，那么此时在num里，最高位存的就是数字的最低位，那么假如我们要求efg，那就是从2算到0 return res; } int power10(int i)//这里有power10是因为有一个分类需要求得十次方得值 { int res=1; while(i--)res*=10; return res; } int count(int n,int x){ if(!n)return 0;//n=0则返回0 vector&lt;int&gt; num;//num用来存储数中的每一位数字 while(n){ num.push_back(n%10); n/=10; } n=num.size();//得出它的长度 int res=0; for (int i = n-1-!x; i &gt;=0; i -- ) //这里需要注意，我们的长度需要减一，是因为num是从0开始存储，而长度是元素的个数，因此需要减1才能读到正确的数值，而!x出现的原因是因为我们不能让前导零出现，如果此时需要我们列举的是0得出现的次数，那么我们自然不能让他们出现第一位，而是从第二位开始枚举 { if(i&lt;n-1)//其实这里可以不同if判断，因为for循环里面实际上就已经达成了if得判断，但为了方便理解还是加上if来理解，这里i要小于n-1的原因是因为我们不能越界只有7位数就最高从七位数开始读起 { res+=get(num,n-1,i+1)*power10(i);//这里就是第一个分类，000~abc-1，那么此时情况个数就会是abc*103,这里的3取决于后面的efg的长度，假如他是efgh，那么就是4 //这里的n-1,i+1,自己将数组列出然后根据分类标准就可以得出为什么l是n-1,r=i+1 if(!x)res-=power10(i);//假如此时我们要列举的是0出现的次数，因为不能出现前导零，这样是不合法也不符合我们的分类情况，例如abcdefg我们列举d，那么他就得从001~abc-1，这样就不会直接到efg，而是会到0efg，因为前面不是前导零，自然就可以列举这个时候0出现的次数，所以要减掉1个power10 } if(num[i]==x)res+=get(num,i-1,0)+1; else if(num[i]&gt;x)res+=power10(i); } return res;//返回res，即出现次数 } int main() { int a,b; while(cin&gt;&gt;a&gt;&gt;b,a||b){ if(a&gt;b)swap(a,b);//a大于b则交换a，b使得变成合法参数 for(int i=0;i&lt;10;i++) cout&lt;&lt;count(b,i)-count(a-1,i)&lt;&lt;' ';//使用前缀和思想解决[a,b]的i出现的次数 cout&lt;&lt;endl; } return 0; } 状态压缩DP蒙德里安的梦想题目链接：[U204941 蒙德里安的梦想 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)]：https://www.luogu.com.cn/problem/U204941 视频讲解：[431 状态压缩DP 蒙德里安的梦想【动态规划】_哔哩哔哩_bilibili]：https://www.bilibili.com/video/BV1cv411b7EG/ using namespace std; const int N = 12,M=1&lt;&lt;N; int n,m; long long f[N][M]; bool st[M]; int main() { int n,m; while(cin&gt;&gt;n&gt;&gt;m,n||m){ memset(f, 0, sizeof f); //预处理：判断合并列的状态i是否合法 //如果合并列的某行是1表示横放，是0表示竖放 //如果合并列不存在连续的奇数个0，即为合法状态 for (int i = 0; i &lt; 1&lt;&lt;n; i ++ ){ st[i]=true; int cnt=0;//记录合并列中连续0的个数 for (int j = 0; j &lt; n; j ++ ){ if(i&gt;&gt;j&amp;1){//如果是1 if(cnt&amp;1){//如果连续0的个数是奇数 st[i]=false;//记录i不合法 break; } }else cnt++;//如果是0，记录0的个数 } if(cnt&amp;1)st[i]=false;//处理高位0的个数 } //状态计算 f[0][0]=1;//第0列不横放是一种合法的方案 for (int i = 1; i &lt;= m; i ++ )//阶段：枚举列 for (int j = 0; j &lt; 1&lt;&lt;n; j ++ )//状态：枚举i列的状态 for (int k = 0; k &lt; 1&lt;&lt;n; k ++ )//状态：枚举i-1列的状态 //两列状态兼容：不出现重叠的1，不出现连续奇数个0 if((j&amp;k)==0&amp;&amp;st[j|k]) f[i][j]+=f[i-1][k]; cout&lt;&lt;f[m][0]&lt;&lt;endl;//第m列不横放，既答案 } return 0; } 状态转移方程： if((j&amp;k)==0&amp;&amp;st[j|k]) f[i][j]+=f[i-1][k]; 最短Hamilton路径题目链接：[U122241 最短Hamilton路径 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)]：https://www.luogu.com.cn/problem/U122241 using namespace std; const int N = 20,M = 1 &lt;&lt; N; int n; int w[N][N]; int f[M][N];//第一维表示是否访问到该点的压缩状态，第二维是走到点j //f[i][j]表示状态为i并且到j的最短路径 int main(){ cin&gt;&gt;n; for (int i = 0; i &lt; n; i ++ ) for (int j = 0; j &lt; n; j ++ )//读入i到j的距离 cin&gt;&gt;w[i][j]; memset(f, 0x3f, sizeof f); f[1][0]=0; for (int i = 0; i &lt; 1 &lt;&lt; n; i ++ )//枚举压缩的状态 for (int j = 0; j &lt; n; j ++ )//枚举到0~j的点 if(i &gt;&gt; j &amp; 1)//该状态存在j点 for (int k = 0; k &lt; n; k ++ )//枚举从j倒数第二个点k if(i &gt;&gt; k &amp; 1)//倒数点k存在 f[i][j]=min(f[i][j],f[i-(1&lt;&lt;j)][k]+w[k][j]);//状态转移方程，在f[i][j]和状态去掉j的点f[i-(i&lt;&lt;j)][k]+w[k][j]取最小值 cout&lt;&lt;f[(1&lt;&lt;n)-1][n-1]&lt;&lt;endl;//输出状态全满也就是所有点都经过且到最后一个点的最短距离 return 0; } 状态转移方程： f[i][j]=min(f[i][j],f[i-(1&lt;&lt;j)][k]+w[k][j]); 树形DP没有上司的舞会题目：[P1352 没有上司的舞会 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)]：https://www.luogu.com.cn/problem/P1352 视频讲解：[417 树形DP 没有上司的舞会【动态规划】_哔哩哔哩_bilibili]：https://www.bilibili.com/video/BV1eK411N7Ly/ using namespace std; const int N = 6010; int n; int w[N];//每个节点的高兴度 int h[N], e[N], ne[N], idx;//邻接表存储树 bool st[N];//判断是否有父节点 int f[N][2]; void add(int a, int b) // 添加一条边a-&gt;b { e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ; } void dfs(int u){ f[u][0]=0; f[u][1]=w[u];//初始化f[u][1]，当第二维是0则不选该点即高兴度为0，同理f[u][1]=w[u]; for (int i = h[u]; i!=-1 ; i =ne[i] ){//遍历u的子节点进行深度优先遍历 int j=e[i]; dfs(j); //状态转移方程 f[u][0]+=max(f[j][0],f[j][1]);//f[u][0]表示不选择父节点u，所以在f[j][0]和f[j][1]取最大值 f[u][1]+=f[j][0];//f[u][1]表示选择根节点u，所以累加不选择子节点的f[j][0] } } int main() { cin&gt;&gt;n; for (int i = 1; i &lt;= n; i ++ )cin&gt;&gt;w[i]; memset(h, -1, sizeof h); for (int i = 0; i &lt; n-1; i ++ ){ int a,b; cin&gt;&gt;a&gt;&gt;b; add(b,a); st[a]=true;//存储是否存在父节点 } int root=1; while(st[root])root++;//判断是否是根节点 dfs(root);//dfs对f[i][j]进行状态转移计算 cout&lt;&lt;max(f[root][0],f[root][1])&lt;&lt;endl;//取选与不选根节点的最大值 return 0; } 状态转移方程： f[u][0]+=max(f[j][0],f[j][1]); f[u][1]+=f[j][0]; 记忆化搜索滑雪题目链接：[P1434 [SHOI2002] 滑雪 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)]：https://www.luogu.com.cn/problem/P1434 using namespace std; const int N = 310; int n,m; int h[N][N]; int f[N][N]; int dx[4]={-1,0,1,0},dy[4]={0,1,0,-1}; int dp(int x,int y){ int &amp;v=f[x][y]; if(v!=-1)return v;//记忆化搜索核心 v=1; for (int i = 0; i &lt; 4; i ++ ){ int a=x+dx[i],b=y+dy[i]; if(a&gt;=1&amp;&amp;a&lt;=n&amp;&amp;b&gt;=1&amp;&amp;b&lt;=m&amp;&amp;h[a][b]&lt;h[x][y])//判断是否越界且上一个经过的点的高度是否大于当前高度 v=max(v,dp(a,b)+1); } return v; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= m; j ++ ) scanf(&quot;%d&quot;, &amp;h[i][j]); memset(f, -1, sizeof f); int res=0; for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= m; j ++ ) res=max(res,dp(i,j)); printf(&quot;%d\\n&quot;,res); return 0; } 状态转移方程：v=max(v,dp(a,b)+1); 六、贪心一个贪心算法总是做出当前最好的选择，也就是说，它期望通过局部最优选择从而得到全局最优的解决方案。—《算法导论》 区间问题区间选点给定 N个闭区间[ai,bi]，请你在数轴上选择尽量少的点，使得每个区间内至少包含一个选出的点 输出选择的点的最小数量。 using namespace std; const int N = 100010; int n; struct Range{ int l,r; bool operator &lt;(const Range&amp; W)const{ return r&lt;W.r; }//重载小于号 }range[N]; int main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i ++ ){ int l,r; scanf(&quot;%d%d&quot;, &amp;l, &amp;r); range[i]={l,r};//读入l,r } sort(range,range+n);//按右端点进行排序 int res=0,ed=-2e9;//ed代表上一个点的右端点 for (int i = 0; i &lt; n; i ++ ){ if(range[i].l&gt;ed){ res++;//点的数量加一 ed=range[i].r; } } printf(&quot;%d\\n&quot;,res); return 0; } 最大不相交区间数量给定 N个闭区间 [ai,bi]，请你在数轴上选择若干区间，使得选中的区间之间互不相交（包括端点）。 输出可选取区间的最大数量。 结论：最大不相交区间数量=最少覆盖区间点数 为什么最大不相交区间数=最少覆盖区间点数呢？ 因为如果几个区间能被同一个点覆盖 说明他们相交了，所以有几个点就是有几个不相交区间 using namespace std; const int N = 100010; int n; struct Range{ int l,r; bool operator &lt;(const Range&amp; W)const{ return r&lt;W.r; } }range[N]; int main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i ++ ){ int l,r; scanf(&quot;%d%d&quot;, &amp;l, &amp;r); range[i]={l,r}; } sort(range,range+n); int res=0,ed=-2e9; for (int i = 0; i &lt; n; i ++ ){ if(range[i].l&gt;ed){ res++; ed=range[i].r; } } printf(&quot;%d\\n&quot;,res); return 0; } 区间分组区间分组.png using namespace std; const int N = 1e5+10; int n; struct Range{ int l,r; bool operator&lt;(const Range &amp;W)const{ return l&lt;W.l; }//按左端点排序 }range[N]; int main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i ++ ){ int l,r; scanf(&quot;%d%d&quot;, &amp;l, &amp;r); range[i]={l,r}; } sort(range,range+n);//sort排序 priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; heap;//小根堆维护所有组的右端点最小值 for (int i = 0; i &lt; n; i ++ ){//从左往右枚举 auto r=range[i];//选择当前区间 if(heap.empty()||heap.top()&gt;=r.l)heap.push(r.r); else{ heap.pop(); heap.push(r.r); } } printf(&quot;%d\\n&quot;,heap.size()); return 0; } 排序不等式排队打水有 n个人排队到 1 个水龙头处打水，第 i 个人装满水桶所需的时间是 ti，请问如何安排他们的打水顺序才能使所有人的等待时间之和最小？ t[i]从小到大排序： 计算公式：t[0]×(n−1)+t[1]×(n−2)+t[2]×(n−3)…+t[n]×0 using namespace std; typedef long long LL; const int N = 1e5 + 10; int t[N]; int main() { int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;t[i]); sort(t, t + n);//排序 LL ans = 0; for (int i = 0; i &lt; n; i++) { ans += t[i] * (n - i - 1);//计算 } printf(&quot;%lld&quot;, ans); return 0; }","link":"/2024/06/13/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"},{"title":"高精度减法","text":"高精度减法实现在处理大整数运算时，直接使用内置的数据类型可能会导致溢出，因此需要使用字符串或数组来存储大整数，并逐位进行运算。本文将介绍如何使用C++实现高精度减法。 代码实现以下是一个实现高精度减法的完整C++代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; a, b; // 存储大整数string s1, s2; // 存储输入的两个大整数字符串int t;vector&lt;int&gt; sub(vector&lt;int&gt; a, vector&lt;int&gt; b) { vector&lt;int&gt; c; int t = 0; for(int i = 0; i &lt; a.size(); ++i) { a[i] -= t; if(i &lt; b.size()) a[i] -= b[i]; if(a[i] &lt; 0) t = 1; else t = 0; c.push_back((a[i] + 10) % 10); } while(c.size() &gt; 1 &amp;&amp; c.back() == 0) c.pop_back(); return c;}bool Max(vector&lt;int&gt; a, vector&lt;int&gt; b) { if(a.size() &lt; b.size()) return true; if(a.size() &gt; b.size()) return false; for(int i = a.size() - 1; i &gt;= 0; --i) if(a[i] &gt; b[i]) return false; else if(a[i] &lt; b[i]) return true; return 0;}int main() { cin &gt;&gt; s1 &gt;&gt; s2; for(int i = s1.size() - 1; i &gt;= 0; --i) a.push_back(s1[i] - '0'); for(int i = s2.size() - 1; i &gt;= 0; --i) b.push_back(s2[i] - '0'); if(Max(a, b) == true) { printf(&quot;-&quot;); auto c = sub(b, a); for(int i = c.size() - 1; i &gt;= 0; --i) printf(&quot;%d&quot;, c[i]); } else { auto c = sub(a, b); for(int i = c.size() - 1; i &gt;= 0; --i) printf(&quot;%d&quot;, c[i]); } return 0;} 示例输入输出以下是一些示例输入和对应的输出，帮助理解代码的工作原理。 示例 1输入： 121234567890123456789098765432109876543210 输出： 1-86419753208641975320 示例 2输入： 129876543210987654321012345678901234567890 输出： 186419753208641975320 示例 3输入： 125000000000000000000050000000000000000000 输出： 10 代码说明输入处理： 使用字符串 s1 和 s2 分别存储输入的两个大整数。 将字符串转换为倒序存储的整数数组 a 和 b。 减法实现： 函数 sub 实现两个大整数的逐位减法，考虑借位情况。 函数 Max 用于比较两个大整数的大小，确定是否需要输出负号。 主函数逻辑： 根据 Max 函数的结果，确定是 a - b 还是 b - a。 输出结果时，如果需要，先输出负号，再输出结果。","link":"/2024/05/30/%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%87%8F%E6%B3%95/"},{"title":"高精度加法","text":"高精度加法实现在处理大整数运算时，直接使用内置的数据类型可能会导致溢出，因此需要使用字符串或数组来存储大整数，并逐位进行运算。本文将介绍如何使用C++实现高精度加法。 代码实现以下是一个实现高精度加法的完整C++代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt; // 包含所有标准库的头文件using namespace std;vector&lt;int&gt; a; // 存储第一个大整数vector&lt;int&gt; b; // 存储第二个大整数string s1, s2; // 存储输入的两个大整数字符串// 实现两个大整数的加法函数vector&lt;int&gt; add(vector&lt;int&gt; a, vector&lt;int&gt; b) { if (a.size() &lt; b.size()) return add(b, a); // 确保 a 的长度大于或等于 b vector&lt;int&gt; c; // 存储结果的向量 int t = 0; // 进位 // 遍历较长的向量 a for (int i = 0; i &lt; a.size(); ++i) { t += a[i]; // 累加 a 的当前位 if (i &lt; b.size()) t += b[i]; // 如果 b 还有对应的位，则累加 b 的当前位 c.push_back(t % 10); // 将当前位的结果存入 c t /= 10; // 更新进位 } // 如果有剩余的进位，则加入结果 if (t) c.push_back(t); return c;}int main() { // 读取两个大整数的字符串 cin &gt;&gt; s1 &gt;&gt; s2; // 将字符串转换为向量，低位在前 for (int i = s1.size() - 1; i &gt;= 0; --i) a.push_back(s1[i] - '0'); for (int i = s2.size() - 1; i &gt;= 0; --i) b.push_back(s2[i] - '0'); //在C++中，字符（char）和整数（int）之间有一定的对应关系。具体来说，字符 '0' 到 '9' 的ASCII值分别是48到57。为了将字符 '0' 到 '9' 转换为对应的整数0到9，需要减去字符 '0' 的ASCII值。这是因为字符 '0' 的ASCII值是48，所以减去48就得到了对应的整数值。 // 计算两个向量的和 auto ans = add(a, b); // 逆序输出结果 for (int i = ans.size() - 1; i &gt;= 0; --i) printf(&quot;%d&quot;, ans[i]); return 0;} 示例输入输出以下是一些示例输入和对应的输出，帮助理解代码的工作原理。 示例 1输入： 121234567890123456789098765432109876543210 输出： 1111111111011111111100 示例 2输入： 125000000000000000000050000000000000000000 输出： 1100000000000000000000 示例 3输入： 12999999999999999999991 输出： 1100000000000000000000 代码说明输入处理： 使用字符串 s1 和 s2 分别存储输入的两个大整数。 将字符串转换为倒序存储的整数数组 a 和 b。 加法实现： 函数 add 实现两个大整数的逐位加法，考虑进位情况。 主函数逻辑： 将两个字符串转换为整数数组，并确保 a 的长度大于或等于 b。 计算两个向量的和，并逆序输出结果。","link":"/2024/05/30/%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8A%A0%E6%B3%95/"},{"title":"高精度除法","text":"高精度除法实现在处理大整数运算时，直接使用内置的数据类型可能会导致溢出，因此需要使用字符串或数组来存储大整数，并逐位进行运算。本文将介绍如何使用C++实现高精度除法。 代码实现以下是一个实现高精度除法的完整C++代码示例： 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; div(vector&lt;int&gt; a, int b, int &amp;r) { vector&lt;int&gt; c; r = 0; for (int i = a.size()-1; i &gt;= 0; i--) { r = r*10 + a[i]; c.push_back(r / b); r = r % b; } reverse(c.begin(), c.end()); return c;}int main() { string a; int b; cin &gt;&gt; a &gt;&gt; b; vector&lt;int&gt; A; for (int i = a.size() - 1; i &gt;= 0; i--) { A.push_back(a[i] - '0'); } int r = 0; auto C = div(A, b, r); for (int i = C.size() - 1; i &gt;= 0; i--) { printf(&quot;%d&quot;, C[i]); } cout &lt;&lt; endl &lt;&lt; r &lt;&lt; endl; return 0;} 示例输入输出以下是一些示例输入和对应的输出，帮助理解代码的工作原理。 示例 1输入： 121234567890123456789012345 输出： 1210000540890046170 示例 2输入： 1298765432109876543210123456789 输出： 1280000000450000003698765432 示例 3输入： 1210000000000000000000999999999 输出： 12100000000011 代码说明输入处理： 使用字符串 a 存储输入的大整数。 将字符串转换为倒序存储的整数数组 A。 除法实现： 函数 div 实现大整数与单个整数的逐位除法，并计算余数。 主函数逻辑： 将字符串转换为整数数组，并进行逐位除法计算。 输出结果并打印余数。","link":"/2024/05/30/%E9%AB%98%E7%B2%BE%E5%BA%A6%E9%99%A4%E6%B3%95/"},{"title":"xmu预推免机试","text":"1.给定一个字符串 &quot;a34b102&quot;，从中提取八进制数字 &quot;34102&quot;。将这个八进制数字转换为二进制，并计算其二进制表示中1的个数。C语言解决方案12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;// 函数：将八进制数转换为二进制并计算其中1的个数int countOnesInOctalToBinary(char *octalString) { long octalNum = strtol(octalString, NULL, 8); // 将八进制字符串转换为长整型数值 int count = 0; // 计算二进制中1的个数 while (octalNum &gt; 0) { count += octalNum &amp; 1; octalNum &gt;&gt;= 1; } return count;}int main() { char input[] = &quot;a34b102&quot;; char octalString[20]; // 存储提取的八进制数字字符串 int octalIndex = 0; // 提取字符串中的八进制数字部分 for (int i = 0; i &lt; strlen(input); i++) { if (input[i] &gt;= '0' &amp;&amp; input[i] &lt;= '7') { octalString[octalIndex++] = input[i]; } } octalString[octalIndex] = '\\0'; // 添加字符串结束符 printf(&quot;提取的八进制数字为：%s\\n&quot;, octalString); // 计算八进制转换为二进制中1的个数 int onesCount = countOnesInOctalToBinary(octalString); printf(&quot;八进制转换为二进制后1的个数为：%d\\n&quot;, onesCount); return 0;} 解决方案详解问题描述 输入：字符串 &quot;a34b102&quot;。 输出： 从输入字符串中提取八进制数字 &quot;34102&quot;。 将该八进制数字转换为二进制，并计算其二进制表示中1的个数。 C语言代码详解 countOnesInOctalToBinary 函数：将八进制字符串转换为长整型数值，并使用位操作计算其中1的个数。 main 函数： 初始化输入字符串 &quot;a34b102&quot;。 从输入字符串中提取八进制数字部分，并存储在 octalString 中。 调用 countOnesInOctalToBinary 函数，计算八进制数字转换为二进制后1的个数。 输出提取的八进制数字和计算得到的二进制中1的个数。 运行代码 编译并运行这段C程序。 输出结果应为：12提取的八进制数字为：34102八进制转换为二进制后1的个数为：5 这表明程序正确地从输入字符串中提取了八进制数字，并计算了所需的二进制中1的个数。","link":"/2024/06/29/xmu%E9%A2%84%E6%8E%A8%E5%85%8D%E6%9C%BA%E8%AF%95/"},{"title":"算法设计的一些概念","text":"1.简述分治算法分治算法（Divide and Conquer）的基本思想是将一个复杂的问题分解成多个较小的、相互独立的子问题，然后递归地解决这些子问题，最后将子问题的解合并起来得到原问题的解。具体步骤如下： 分解（Divide）：将问题划分为若干个规模较小的子问题。这些子问题的形式与原问题相同或相似，但规模要小于原问题。 解决（Conquer）：递归地求解这些子问题。当子问题的规模足够小时（达到某个递归基准），直接解决这些子问题，而不再进一步分解。 合并（Combine）：将子问题的解合并起来，形成原问题的解。 这种方法的一个典型应用是快速排序（Quicksort）和归并排序（Merge Sort）。以归并排序为例： 分解：将数组分成两个大致相等的子数组。 解决：递归地对这两个子数组进行排序。 合并：将两个已排序的子数组合并成一个有序的数组。 分治算法的优点在于能够将大问题转化为小问题，通过递归的方式简化问题的求解过程，常常能显著降低算法的时间复杂度。例如，归并排序的时间复杂度为 \\(O(n \\log n)\\)，比起简单排序算法如冒泡排序的 \\(O(n^2)\\) 要高效得多。 分治算法的典型特点是： 递归的结构。 问题的可分解性和可合并性。 子问题的独立性。 这些特点使得分治算法在计算机科学中有着广泛的应用，如排序、搜索、矩阵乘法、傅里叶变换等。 2.简述动态规划算法的基本思想动态规划（Dynamic Programming，DP）是一种用于解决复杂问题的方法，尤其适用于那些可以分解为相对简单的子问题的问题。其基本思想是通过将问题分解为更小的子问题，并将这些子问题的结果进行储存和重用，从而减少重复计算，提高算法效率。动态规划的核心思想可以概括为以下几个步骤： 划分子问题：将原问题分解为若干个相互重叠的子问题。这个过程通常会基于问题的结构，找到一种递归的关系，将大问题拆解成小问题。 定义状态：确定问题的状态。状态通常是描述问题在某一步骤的特征，可以用一个或多个变量表示。例如，在求解最短路径问题时，状态可以是当前节点和已经经过的节点集合。 确定状态转移方程：找到状态之间的关系，即状态转移方程。状态转移方程描述了如何从一个状态转移到另一个状态，以及这些状态之间的递归关系。 确定初始状态和边界条件：明确初始状态和边界条件。初始状态是问题的起始点，边界条件是一些已知的简单解。 自底向上计算：从最简单的子问题开始，逐步计算并储存每个子问题的结果。最终，通过组合这些子问题的解，得到原问题的解。 储存和重用子问题的结果：利用一个表格（通常是数组或矩阵）来储存已经计算过的子问题的结果，以便在需要时直接使用，避免重复计算。 一个经典的例子是斐波那契数列的计算。斐波那契数列的递归定义是： \\[ F(n) = F(n-1) + F(n-2) \\] 通过动态规划，可以避免重复计算，从而大大提高计算效率： 12345678def fibonacci(n): if n &lt;= 1: return n dp = [0] * (n + 1) dp[1] = 1 for i in range(2, n + 1): dp[i] = dp[i-1] + dp[i-2] return dp[n] 通过上述步骤和思想，动态规划可以高效地解决许多具有重叠子问题和最优子结构性质的问题。 3.简述回溯算法和分支限界算法的异同回溯算法和分支限界算法都是用于解决组合优化问题的常用方法，它们都采用了系统搜索的策略，但在实现细节和应用场景上有所不同。以下是对它们异同点的简述： 回溯算法基本思想：回溯算法是一种深度优先搜索（DFS）的方法，用于在解空间树中寻找所有可能的解或最优解。它通过在搜索过程中逐步构建解，并在发现当前部分解不能导致有效解时，回溯到上一步继续搜索。 特点： 逐步构建解：逐步扩展当前部分解，直到找到一个完整解或发现当前路径无效。 回溯：当发现当前路径不能通向有效解时，回到上一步继续尝试其他可能。 不剪枝：通常情况下不进行剪枝操作，尝试所有可能的路径。 应用场景：适用于需要遍历所有解空间，找出所有可行解的情况，例如八皇后问题、全排列生成等。 示例代码： 123456789def backtrack(solution, step): if step == goal: print(solution) else: for option in options: if is_valid(option): solution.append(option) backtrack(solution, step + 1) solution.pop() 分支限界算法基本思想：分支限界算法是一种广度优先搜索（BFS）或优先队列搜索的方法，通过对解空间进行分支和限界操作，有效剪枝以减少搜索空间，从而更快找到最优解或可行解。 特点： 分支：将问题逐步分解成更小的子问题，每个子问题代表解空间的一部分。 限界：使用限界函数（例如上下界估计）判断当前子问题是否可能包含最优解，如果不可能，则剪枝，避免无效搜索。 优先搜索：通常结合优先队列，根据限界函数值优先处理最有可能产生最优解的子问题。 应用场景：适用于需要找到最优解并且解空间较大的情况，例如旅行商问题、0/1背包问题等。 示例代码： 123456789101112import heapqdef branch_and_bound(initial_state): priority_queue = [] heapq.heappush(priority_queue, (initial_state.bound, initial_state)) while priority_queue: bound, current = heapq.heappop(priority_queue) if current.is_solution(): return current for child in current.generate_children(): if child.bound &lt; best_known_bound: heapq.heappush(priority_queue, (child.bound, child)) 异同点总结相同点： 系统搜索：都通过系统搜索策略寻找解。 解空间树：都以解空间树为基础进行问题求解。 适用于组合优化：都用于解决组合优化问题。 不同点： 搜索方式： 回溯算法采用深度优先搜索，逐步构建解并在必要时回溯。 分支限界算法通常采用广度优先搜索或优先队列搜索，通过限界函数进行剪枝。 剪枝策略： 回溯算法不进行系统性的剪枝操作。 分支限界算法通过限界函数进行有效剪枝，减少搜索空间。 应用场景： 回溯算法适合需要遍历所有解的情况。 分支限界算法适合需要找到最优解并且解空间较大的情况。 这两种算法在实际应用中各有优势，根据具体问题的性质选择合适的方法可以大大提高求解效率。 4.简述贪心算法贪心算法（Greedy Algorithm）是一种在每一步选择中都做出在当前看来是最优的选择，从而希望通过一系列局部最优的选择达到全局最优解决方案的算法策略。贪心算法的基本思想是通过分阶段逐步解决问题，在每一个阶段中选择当前状态下最优的决策。 贪心算法的基本思想 选择性质：贪心算法依赖于一种称为贪心选择性质的原则，即局部最优选择可以导致全局最优解。每一步选择的局部最优解是指在当前步骤中，不考虑后续步骤所选择的最优解。 最优子结构：问题可以通过局部最优选择形成一个最优解，即问题的最优解包含其子问题的最优解。 贪心算法的步骤 建立数学模型：将问题描述成数学模型，明确要达到的目标和约束条件。 贪心选择策略：设计一个贪心选择策略，每一步都选择当前最优的解。 验证贪心选择的正确性：确保通过贪心选择能得到问题的一个全局最优解，通常需要证明贪心选择具有最优子结构性质。 构造解：从局部最优解出发逐步构造全局最优解。 贪心算法的应用贪心算法广泛应用于一些能够通过局部最优解逐步构造全局最优解的问题，经典的应用包括： 最小生成树问题（Kruskal算法、Prim算法） 单源最短路径问题（Dijkstra算法） 活动选择问题 背包问题的部分情况（如分数背包问题） 示例：分数背包问题在分数背包问题中，给定一组物品，每个物品有一个价值和重量，目标是将这些物品装入一个背包，使得背包的总价值最大化，并且允许对物品进行分割。贪心算法的策略是根据每个物品的价值重量比进行选择，每次选择价值重量比最高的物品，直到背包装满。 1234567891011121314151617181920212223242526class Item: def __init__(self, value, weight): self.value = value self.weight = weight self.ratio = value / weightdef fractional_knapsack(items, capacity): # 按照物品的价值重量比排序 items.sort(key=lambda x: x.ratio, reverse=True) total_value = 0.0 for item in items: if capacity &gt;= item.weight: # 如果背包能装下当前物品，就全部装入 capacity -= item.weight total_value += item.value else: # 否则装入部分物品 total_value += item.ratio * capacity break return total_value# 示例用法items = [Item(60, 10), Item(100, 20), Item(120, 30)]capacity = 50print(f&quot;最大价值: {fractional_knapsack(items, capacity)}&quot;) 贪心算法的优缺点优点： 简单高效：贪心算法实现简单，通常能在多项式时间内解决问题。 局部最优选择：在很多实际问题中，贪心算法能快速找到较优解。 缺点： 局限性：贪心算法不总能保证全局最优解，特别是对不满足贪心选择性质和最优子结构性质的问题。 适用范围有限：贪心算法适用于问题具有贪心选择性质和最优子结构性质的问题，不适用于所有问题。 总之，贪心算法通过每一步都选择当前最优的策略，希望通过局部最优解达到全局最优解，但其应用需谨慎，确保问题具有贪心选择性质和最优子结构性质。","link":"/2024/06/30/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5/"},{"title":"分治算法经典问题","text":"分治算法（Divide and Conquer）是一种通过将问题分解为多个规模较小的子问题，递归地解决这些子问题，然后合并其结果来解决原问题的算法策略。其基本思想可以概括为以下几个步骤： 分解（Divide）：将问题分解成若干个子问题，这些子问题是原问题的规模较小的实例。 解决（Conquer）：递归地解决这些子问题。如果子问题规模足够小，则直接解决。 合并（Combine）：将子问题的解合并成原问题的解。 归并排序（Merge Sort）问题描述： 对一个无序数组进行排序。 分治策略： 分解：将数组分成两个大小相等的子数组。 解决：递归地对两个子数组进行排序。 合并：合并两个已排序的子数组。 伪代码： 1234567891011121314151617181920212223Algorithm Merge_Sort(array) if length(array) &lt;= 1: return array mid = length(array) // 2 left_half = Merge_Sort(array[0:mid]) right_half = Merge_Sort(array[mid:]) return Merge(left_half, right_half)Algorithm Merge(left, right) result = [] while left and right are not empty: if left[0] &lt;= right[0]: result.append(left[0]) left = left[1:] else: result.append(right[0]) right = right[1:] result.extend(left if left is not empty else right) return result 快速排序（Quick Sort）问题描述： 对一个无序数组进行排序。 分治策略： 分解：选择一个基准元素，将数组分成两部分，使得左半部分的元素都小于等于基准元素，右半部分的元素都大于等于基准元素。 解决：递归地对两个子数组进行排序。 合并：因为子数组已经有序，所以不需要显式地合并操作。 伪代码： 12345678910Algorithm Quick_Sort(array) if length(array) &lt;= 1: return array pivot = array[-1] left = [x for x in array[:-1] if x &lt;= pivot] right = [x for x in array[:-1] if x &gt; pivot] return Quick_Sort(left) + [pivot] + Quick_Sort(right) 最近点对问题（Closest Pair Problem）问题描述： 在二维平面上，找到距离最近的两个点。 分治策略： 分解：将点集按 x 坐标排序，并分成两个大小相等的子集。 解决：递归地找到左半部分和右半部分的最近点对。 合并：找到跨越分割线的最近点对，并与左右半部分的最近点对进行比较，得到最终的最近点对。 伪代码： 123456789101112131415161718192021222324252627282930313233343536Algorithm Closest_Pair(points) if length(points) &lt;= 3: return brute_force_closest_pair(points) mid = length(points) // 2 left_half = points[0:mid] right_half = points[mid:] closest_left = Closest_Pair(left_half) closest_right = Closest_Pair(right_half) d = min(distance(closest_left), distance(closest_right)) strip = [p for p in points if abs(p.x - points[mid].x) &lt; d] return min(d, closest_in_strip(strip, d))Algorithm brute_force_closest_pair(points) min_dist = infinity closest_pair = None for i from 0 to length(points): for j from i+1 to length(points): if distance(points[i], points[j]) &lt; min_dist: min_dist = distance(points[i], points[j]) closest_pair = (points[i], points[j]) return closest_pairAlgorithm closest_in_strip(strip, d) min_dist = d strip.sort_by_y() for i from 0 to length(strip): for j from i+1 to min(i+7, length(strip)): if distance(strip[i], strip[j]) &lt; min_dist: min_dist = distance(strip[i], strip[j]) closest_pair = (strip[i], strip[j]) return closest_pair 矩阵乘法 Strassen 算法问题描述： 计算两个矩阵的乘积。 分治策略： 分解：将矩阵分成 4 个大小相等的子矩阵。 解决：递归地计算这些子矩阵的乘积。 合并：将子矩阵的乘积合并成最终结果。 伪代码： 1234567891011121314151617181920212223Algorithm Strassen_Multiply(A, B) if size(A) is small: return standard_matrix_multiply(A, B) Split A and B into submatrices: A11, A12, A21, A22 B11, B12, B21, B22 M1 = Strassen_Multiply(A11 + A22, B11 + B22) M2 = Strassen_Multiply(A21 + A22, B11) M3 = Strassen_Multiply(A11, B12 - B22) M4 = Strassen_Multiply(A22, B21 - B11) M5 = Strassen_Multiply(A11 + A12, B22) M6 = Strassen_Multiply(A21 - A11, B11 + B12) M7 = Strassen_Multiply(A12 - A22, B21 + B22) C11 = M1 + M4 - M5 + M7 C12 = M3 + M5 C21 = M2 + M4 C22 = M1 - M2 + M3 + M6 return Combine(C11, C12, C21, C22) 汉诺塔问题（Tower of Hanoi）问题描述： 将 n 个盘子从源柱移动到目标柱，且每次只能移动一个盘子，且大盘子不能放在小盘子上面。 分治策略： 分解：将 n 个盘子移动问题分解为移动 n-1 个盘子的问题。 解决：递归地将 n-1 个盘子移动到辅助柱，将第 n 个盘子移动到目标柱，然后将 n-1 个盘子从辅助柱移动到目标柱。 合并：通过递归调用将问题解决。 伪代码： 123456789Algorithm Tower_of_Hanoi(n, source, target, auxiliary) if n == 1: print &quot;Move disk 1 from &quot; + source + &quot; to &quot; + target return Tower_of_Hanoi(n-1, source, auxiliary, target) print &quot;Move disk &quot; + n + &quot; from &quot; + source + &quot; to &quot; + target Tower_of_Hanoi(n-1, auxiliary, target, source) 通过这些详细的解释和伪代码，可以看到分治算法在解决这些经典问题时的高效性和直观性。每个问题都依赖于特定的分治策略，通过将问题分解为子问题，递归地解决子问题，再合并结果来解决原问题。","link":"/2024/06/30/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/"},{"title":"经典动态规划问题","text":"动态规划（Dynamic Programming，DP）是一种用于解决复杂问题的方法，尤其适用于那些可以分解为相对简单的子问题的问题。其基本思想是通过将问题分解为更小的子问题，并将这些子问题的结果进行储存和重用，从而减少重复计算，提高算法效率。动态规划的核心思想可以概括为以下几个步骤： 划分子问题：将原问题分解为若干个相互重叠的子问题。这个过程通常会基于问题的结构，找到一种递归的关系，将大问题拆解成小问题。 定义状态：确定问题的状态。状态通常是描述问题在某一步骤的特征，可以用一个或多个变量表示。例如，在求解最短路径问题时，状态可以是当前节点和已经经过的节点集合。 确定状态转移方程：找到状态之间的关系，即状态转移方程。状态转移方程描述了如何从一个状态转移到另一个状态，以及这些状态之间的递归关系。 确定初始状态和边界条件：明确初始状态和边界条件。初始状态是问题的起始点，边界条件是一些已知的简单解。 自底向上计算：从最简单的子问题开始，逐步计算并储存每个子问题的结果。最终，通过组合这些子问题的解，得到原问题的解。 储存和重用子问题的结果：利用一个表格（通常是数组或矩阵）来储存已经计算过的子问题的结果，以便在需要时直接使用，避免重复计算。 01背包问题问题描述： 给定一组物品，每个物品有一个重量和一个价值，另有一个背包，它的容量为限定的重量。目标是找出一个物品的子集，使得这些物品的总重量不超过背包的容量，并且它们的总价值最大。 动态规划解法： 状态定义： 用 dp[i][w] 表示前 i 个物品中可以放入一个容量为 w 的背包的最大价值。 状态转移方程： 如果不选择第 i 个物品：dp[i][w] = dp[i-1][w] 如果选择第 i 个物品：dp[i][w] = dp[i-1][w-weight[i-1]] + value[i-1] 综合两种情况：dp[i][w] = max(dp[i-1][w], dp[i-1][w-weight[i-1]] + value[i-1]) 初始化： 当没有物品或容量为0时，dp[0][w] = 0 和 dp[i][0] = 0 结果： 最终结果在 dp[n][W]，其中 n 是物品的数量，W 是背包的容量。 伪代码： 1234567891011121314Algorithm 0_1_Knapsack(values, weights, W) n = length(values) dp = array[n+1][W+1] for i from 0 to n: for w from 0 to W: if i == 0 or w == 0: dp[i][w] = 0 else if weights[i-1] &lt;= w: dp[i][w] = max(dp[i-1][w], dp[i-1][w-weights[i-1]] + values[i-1]) else: dp[i][w] = dp[i-1][w] return dp[n][W] 最长公共子序列问题（LCS）问题描述： 给定两个字符串，求它们的最长公共子序列的长度。公共子序列是不需要连续但保持相对顺序的子串。 动态规划解法： 状态定义： 用 dp[i][j] 表示字符串 X 的前 i 个字符和字符串 Y 的前 j 个字符的最长公共子序列的长度。 状态转移方程： 如果 X[i-1] == Y[j-1]：dp[i][j] = dp[i-1][j-1] + 1 如果 X[i-1] != Y[j-1]：dp[i][j] = max(dp[i-1][j], dp[i][j-1]) 初始化： 当 i 或 j 为 0 时，dp[i][0] = 0 和 dp[0][j] = 0 结果： 最终结果在 dp[m][n]，其中 m 和 n 分别是字符串 X 和 Y 的长度。 伪代码： 123456789101112131415Algorithm LCS(X, Y) m = length(X) n = length(Y) dp = array[m+1][n+1] for i from 0 to m: for j from 0 to n: if i == 0 or j == 0: dp[i][j] = 0 else if X[i-1] == Y[j-1]: dp[i][j] = dp[i-1][j-1] + 1 else: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) return dp[m][n]","link":"/2024/06/30/%E7%BB%8F%E5%85%B8%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98/"},{"title":"贪心算法经典问题","text":"贪心算法是解决一类优化问题的有效策略，通过在每一步选择中做出局部最优选择，希望最终能够达到全局最优解。以下是一些经典的贪心算法问题及其应用： 1. 活动选择问题（Activity Selection Problem）问题描述： 给定一组活动，每个活动有一个开始时间和结束时间，选择尽可能多的活动，使得它们互不重叠。 贪心策略： 每次选择结束时间最早且与已选择活动不冲突的活动。 伪代码： 1234567891011算法 活动选择(activities) 按活动的结束时间对活动进行排序 已选活动集 = [] 上一个活动的结束时间 = 0 对于 每个活动 in activities: 如果 活动的开始时间 &gt;= 上一个活动的结束时间: 将活动添加到已选活动集 更新上一个活动的结束时间为当前活动的结束时间 返回 已选活动集 2. 分数背包问题（Fractional Knapsack Problem）问题描述： 给定一组物品，每个物品有一个价值和重量，背包有固定的容量，允许对物品进行分割，求能够装入背包的最大价值。 贪心策略： 按单位重量的价值排序，优先选择单位价值最高的物品。 伪代码： 1234567891011算法 分数背包(items, capacity) 按物品的价值重量比降序排序 总价值 = 0 对于 每个物品 in items: 如果 物品的重量 &lt;= 背包剩余容量: 背包剩余容量 -= 物品的重量 总价值 += 物品的价值 否则: 总价值 += 物品的价值 * (背包剩余容量 / 物品的重量) 跳出循环 返回 总价值 3. 最小生成树问题（Minimum Spanning Tree, MST）问题描述： 在一个加权连通图中，找到一个子图，使得它包含所有顶点且边的总权重最小。 贪心策略： Kruskal算法：按边的权重从小到大排序，每次选择权重最小且不构成环的边。 Prim算法：从一个顶点出发，每次选择权重最小且未被访问过的顶点连接的边。 伪代码（Kruskal算法）： 1234567算法 Kruskal(graph) 初始化一个空集来保存最小生成树(MST) 按边的权重对所有边进行排序 对于 每条边 in 排序后的边: 如果 该边不与MST形成环: 将该边添加到MST 返回 MST 伪代码（Prim算法）： 12345678910算法 Prim(graph, start_vertex) 初始化一个优先队列，并将起始顶点加入队列 初始化一个空集来保存最小生成树(MST) 当 优先队列不为空: 提取优先队列中权重最小的顶点 将该顶点添加到MST 对于 该顶点的每个邻接顶点: 如果 邻接顶点不在MST中: 将该邻接顶点和边权重加入优先队列 返回 MST 4. 单源最短路径问题（Dijkstra’s Algorithm）问题描述： 在一个加权图中，找到从源点到所有其他顶点的最短路径。 贪心策略： 每次选择离源点最近的未访问顶点，更新其邻接顶点的最短路径。 伪代码： 12345678910算法 Dijkstra(graph, source) 初始化所有顶点的距离为无穷大，源点距离为0 初始化一个优先队列，将源点加入队列 当 优先队列不为空: 提取优先队列中距离最小的顶点 对于 提取顶点的每个邻接顶点: 如果 通过提取顶点的路径比当前已知路径更短: 更新邻接顶点的距离 将/更新邻接顶点在优先队列中的位置 返回 所有顶点的最短距离 5. 霍夫曼编码（Huffman Coding）问题描述： 对一组字符进行编码，使得编码后的总长度最短，字符出现频率高的使用较短的编码。 贪心策略： 每次选择频率最低的两个字符，合并为一个新的节点，重复直到所有字符被合并到一棵树中。 伪代码： 1234567算法 霍夫曼编码(characters, frequencies) 初始化一个优先队列，将字符及其频率加入队列 当 优先队列中有多于一个节点: 提取两个频率最小的节点 创建一个新节点，将这两个节点作为子节点，新节点的频率为两子节点频率之和 将新节点加入优先队列 返回 优先队列中剩余的唯一节点（霍夫曼树的根节点） 6. 区间调度问题（Interval Scheduling Maximization）问题描述： 给定一组区间，选择最多的不重叠区间。 贪心策略： 每次选择结束时间最早且不与已选择区间重叠的区间。 伪代码： 1234567891011算法 区间调度(intervals) 按区间的结束时间对区间进行排序 已选区间集 = [] 上一个区间的结束时间 = 0 对于 每个区间 in intervals: 如果 区间的开始时间 &gt;= 上一个区间的结束时间: 将区间添加到已选区间集 更新上一个区间的结束时间为当前区间的结束时间 返回 已选区间集 这些伪代码展示了如何使用贪心算法解决经典问题，通过每一步选择局部最优解来逐步构建最终解。贪心算法的核心在于找到适合当前问题的贪心选择策略，以保证每一步的选择都是局部最优的，希望通过这些局部最优选择来达到全局最优解。","link":"/2024/06/30/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/"},{"title":"最长公共子序列（lcs）代码实现","text":"c语言实现带回溯的lcs 我们将 lcs 函数分成两个部分：一个部分计算长度，另一个部分构造LCS字符串。 我们需要先计算LCS长度，然后分配适当大小的内存，再构造LCS字符串。 完整的C代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;// LCS算法实现并返回LCS长度int lcs_length(const char *X, const char *Y) { int m = strlen(X); int n = strlen(Y); int **dp = (int **)malloc((m + 1) * sizeof(int *)); for (int i = 0; i &lt;= m; i++) { dp[i] = (int *)malloc((n + 1) * sizeof(int)); } // 填充dp数组 for (int i = 0; i &lt;= m; i++) { for (int j = 0; j &lt;= n; j++) { if (i == 0 || j == 0) { dp[i][j] = 0; } else if (X[i - 1] == Y[j - 1]) { dp[i][j] = dp[i - 1][j - 1] + 1; } else { dp[i][j] = dp[i - 1][j] &gt; dp[i][j - 1] ? dp[i - 1][j] : dp[i][j - 1]; } } } int result = dp[m][n]; // 释放dp数组 for (int i = 0; i &lt;= m; i++) { free(dp[i]); } free(dp); return result;}// 构造LCS字符串void construct_lcs(const char *X, const char *Y, char *lcs_str) { int m = strlen(X); int n = strlen(Y); int **dp = (int **)malloc((m + 1) * sizeof(int *)); for (int i = 0; i &lt;= m; i++) { dp[i] = (int *)malloc((n + 1) * sizeof(int)); } // 填充dp数组 for (int i = 0; i &lt;= m; i++) { for (int j = 0; j &lt;= n; j++) { if (i == 0 || j == 0) { dp[i][j] = 0; } else if (X[i - 1] == Y[j - 1]) { dp[i][j] = dp[i - 1][j - 1] + 1; } else { dp[i][j] = dp[i - 1][j] &gt; dp[i][j - 1] ? dp[i - 1][j] : dp[i][j - 1]; } } } int index = dp[m][n]; lcs_str[index] = '\\0'; // 设置字符串结束符 int i = m, j = n; while (i &gt; 0 &amp;&amp; j &gt; 0) { if (X[i - 1] == Y[j - 1]) { lcs_str[index - 1] = X[i - 1]; i--; j--; index--; } else if (dp[i - 1][j] &gt; dp[i][j - 1]) { i--; } else { j--; } } // 释放dp数组 for (int i = 0; i &lt;= m; i++) { free(dp[i]); } free(dp);}// 主函数int main() { char X[] = &quot;ABCBDAB&quot;; char Y[] = &quot;BDCAB&quot;; int lcs_len = lcs_length(X, Y); // 获取LCS长度 char *lcs_str = (char *)malloc((lcs_len + 1) * sizeof(char)); construct_lcs(X, Y, lcs_str); // 构造LCS字符串 printf(&quot;最长公共子序列的长度: %d\\n&quot;, lcs_len); printf(&quot;最长公共子序列: %s\\n&quot;, lcs_str); free(lcs_str); return 0;} 解释 计算LCS长度的函数 lcs_length： 这个函数计算并返回LCS的长度。它使用动态分配的二维数组 dp 来存储中间结果，最终返回 dp[m][n]。 构造LCS字符串的函数 construct_lcs： 这个函数使用与 lcs_length 相同的方法填充 dp 数组，然后通过回溯 dp 数组来构造LCS字符串。 主函数 main： 首先调用 lcs_length 计算LCS长度。 然后分配足够的内存来存储LCS字符串，并调用 construct_lcs 来构造LCS字符串。 最后，打印LCS长度和LCS字符串，并释放分配的内存。 编译和运行输出应该是： 12最长公共子序列的长度: 4最长公共子序列: BDAB 这个输出表示字符串 “ABCBDAB” 和 “BDCAB” 的最长公共子序列的长度为4，并且最长公共子序列为 “BDAB”。 C++实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;// LCS算法实现并返回LCS长度int lcs_length(const string &amp;X, const string &amp;Y) { int m = X.length(); int n = Y.length(); vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0)); // 填充dp数组 for (int i = 1; i &lt;= m; ++i) { for (int j = 1; j &lt;= n; ++j) { if (X[i - 1] == Y[j - 1]) { dp[i][j] = dp[i - 1][j - 1] + 1; } else { dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); } } } return dp[m][n];}// 构造LCS字符串string construct_lcs(const string &amp;X, const string &amp;Y) { int m = X.length(); int n = Y.length(); vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0)); // 填充dp数组 for (int i = 1; i &lt;= m; ++i) { for (int j = 1; j &lt;= n; ++j) { if (X[i - 1] == Y[j - 1]) { dp[i][j] = dp[i - 1][j - 1] + 1; } else { dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); } } } // 构造LCS字符串 int i = m, j = n; string lcs_str; while (i &gt; 0 &amp;&amp; j &gt; 0) { if (X[i - 1] == Y[j - 1]) { lcs_str.push_back(X[i - 1]); --i; --j; } else if (dp[i - 1][j] &gt; dp[i][j - 1]) { --i; } else { --j; } } reverse(lcs_str.begin(), lcs_str.end()); return lcs_str;}// 主函数int main() { string X = &quot;ABCBDAB&quot;; string Y = &quot;BDCAB&quot;; int lcs_len = lcs_length(X, Y); string lcs_str = construct_lcs(X, Y); cout &lt;&lt; &quot;最长公共子序列的长度: &quot; &lt;&lt; lcs_len &lt;&lt; endl; cout &lt;&lt; &quot;最长公共子序列: &quot; &lt;&lt; lcs_str &lt;&lt; endl; return 0;} Python实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950def lcs_length(X, Y): m = len(X) n = len(Y) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if X[i - 1] == Y[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]def construct_lcs(X, Y): m = len(X) n = len(Y) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if X[i - 1] == Y[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) lcs_str = [] i, j = m, n while i &gt; 0 and j &gt; 0: if X[i - 1] == Y[j - 1]: lcs_str.append(X[i - 1]) i -= 1 j -= 1 elif dp[i - 1][j] &gt; dp[i][j - 1]: i -= 1 else: j -= 1 lcs_str.reverse() return ''.join(lcs_str)# 示例用法X = &quot;ABCBDAB&quot;Y = &quot;BDCAB&quot;lcs_len = lcs_length(X, Y)lcs_str = construct_lcs(X, Y)print(f&quot;最长公共子序列的长度: {lcs_len}&quot;)print(f&quot;最长公共子序列: {lcs_str}&quot;) 解释 计算LCS长度的函数： C++的 lcs_length 和Python的 lcs_length 函数使用动态分配的二维数组 dp 来存储中间结果，最终返回 dp[m][n]。 构造LCS字符串的函数： C++的 construct_lcs 和Python的 construct_lcs 函数使用与 lcs_length 相同的方法填充 dp 数组，然后通过回溯 dp 数组来构造LCS字符串。 主函数： C++和Python的主函数分别调用 lcs_length 计算LCS长度，然后调用 construct_lcs 构造LCS字符串，最后打印LCS长度和LCS字符串。","link":"/2024/06/30/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88lcs%EF%BC%89%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/"},{"title":"01背包问题代码实现","text":"01背包问题问题描述： 给定一组物品，每个物品有一个重量和一个价值，另有一个背包，它的容量为限定的重量。目标是找出一个物品的子集，使得这些物品的总重量不超过背包的容量，并且它们的总价值最大。 动态规划解法 状态定义： 用 dp[i][w] 表示前 i 个物品中可以放入一个容量为 w 的背包的最大价值。 状态转移方程： 如果不选择第 i 个物品：dp[i][w] = dp[i-1][w] 如果选择第 i 个物品：dp[i][w] = dp[i-1][w-weight[i-1]] + value[i-1] 综合两种情况：dp[i][w] = max(dp[i-1][w], dp[i-1][w-weight[i-1]] + value[i-1]) 初始化： 当没有物品或容量为0时，dp[0][w] = 0 和 dp[i][0] = 0 结果： 最终结果在 dp[n][W]，其中 n 是物品的数量，W 是背包的容量。 C实现123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include&lt;bits/stdc++.h&gt;using namespace std;int f[5][9]={0};int w[5] = {0,2,3,4,5};int v[5] = {0,3,4,5,8};int main(){ int i,j; memset(f,0,sizeof(f)); for(int i=1;i&lt;5;i++) { for(int j=1;j&lt;9;j++) { if(w[i]&gt;j) f[i][j]=f[i-1][j]; else f[i][j]=max(f[i-1][j],f[i-1][j-w[i]]+v[i]); } } for(int i=0;i&lt;5;i++) { for(int j=0;j&lt;9;j++) { printf(&quot;f[%d][%d]=%d\\n&quot;,i,j,f[i][j]); } } return 0;} C++实现123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int knapsack(int W, const vector&lt;int&gt; &amp;wt, const vector&lt;int&gt; &amp;val) { int n = val.size(); vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(W + 1, 0)); for (int i = 0; i &lt;= n; i++) { for (int w = 0; w &lt;= W; w++) { if (i == 0 || w == 0) { dp[i][w] = 0; } else if (wt[i - 1] &lt;= w) { dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - wt[i - 1]] + val[i - 1]); } else { dp[i][w] = dp[i - 1][w]; } } } return dp[n][W];}int main() { vector&lt;int&gt; val = {60, 100, 120}; vector&lt;int&gt; wt = {10, 20, 30}; int W = 50; cout &lt;&lt; &quot;最大价值: &quot; &lt;&lt; knapsack(W, wt, val) &lt;&lt; endl; return 0;} Python实现1234567891011121314151617181920def knapsack(W, wt, val): n = len(val) dp = [[0 for _ in range(W + 1)] for _ in range(n + 1)] for i in range(n + 1): for w in range(W + 1): if i == 0 or w == 0: dp[i][w] = 0 elif wt[i - 1] &lt;= w: dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - wt[i - 1]] + val[i - 1]) else: dp[i][w] = dp[i - 1][w] return dp[n][W]# 示例用法val = [60, 100, 120]wt = [10, 20, 30]W = 50print(f&quot;最大价值: {knapsack(W, wt, val)}&quot;) 解释 状态定义： dp[i][w] 表示前 i 个物品中可以放入容量为 w 的背包的最大价值。 状态转移方程： 如果不选择第 i 个物品：dp[i][w] = dp[i-1][w] 如果选择第 i 个物品：dp[i][w] = dp[i-1][w-weight[i-1]] + value[i-1] 综合两种情况：dp[i][w] = max(dp[i-1][w], dp[i-1][w-weight[i-1]] + value[i-1]) 初始化： dp[0][w] = 0 和 dp[i][0] = 0 表示当没有物品或容量为0时，最大价值为0。 计算结果： 通过迭代填充 dp 数组，最终结果存储在 dp[n][W] 中，其中 n 是物品的数量，W 是背包的容量。","link":"/2024/06/30/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/"},{"title":"C语言中的ctype.h库函数用法详解","text":"C语言中的 ctype.h 库提供了一组函数，用于字符处理。本文将详细介绍这些函数及其用法。 1. 概述ctype.h 库包含了许多字符处理函数，如大小写转换、判断字符类型等。 2. ctype.h库函数3.1 字符类型判断函数int isalpha(int c)判断字符 c 是否为字母（a-z 或 A-Z）。 示例代码： 123456789101112#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;int main() { char c = 'A'; if (isalpha(c)) { printf(&quot;%c 是一个字母\\n&quot;, c); } else { printf(&quot;%c 不是一个字母\\n&quot;, c); } return 0;} int isdigit(int c)判断字符 c 是否为数字（0-9）。 示例代码： 123456789101112#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;int main() { char c = '1'; if (isdigit(c)) { printf(&quot;%c 是一个数字\\n&quot;, c); } else { printf(&quot;%c 不是一个数字\\n&quot;, c); } return 0;} int isalnum(int c)判断字符 c 是否为字母或数字。 示例代码： 123456789101112#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;int main() { char c = 'a'; if (isalnum(c)) { printf(&quot;%c 是一个字母或数字\\n&quot;, c); } else { printf(&quot;%c 不是一个字母或数字\\n&quot;, c); } return 0;} int isspace(int c)判断字符 c 是否为空白字符（空格、换行、制表符等）。 示例代码： 1234567891011121314#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;int main() { char c = ' '; if (isspace(c)) { printf(&quot;字符是空白字符\\n&quot;); } else { printf(&quot;字符不是空白字符\\n&quot;); } return 0;} 3.2 大小写转换函数int toupper(int c)将字符 c 转换为大写字母，如果 c 是小写字母。 示例代码： 123456789#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;int main() { char c = 'a'; char upper = toupper(c); printf(&quot;%c 转换为大写字母是 %c\\n&quot;, c, upper); return 0;} int tolower(int c)将字符 c 转换为小写字母，如果 c 是大写字母。 示例代码： 123456789#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;int main() { char c = 'A'; char lower = tolower(c); printf(&quot;%c 转换为小写字母是 %c\\n&quot;, c, lower); return 0;} 3.3 其他字符处理函数int isupper(int c)判断字符 c 是否为大写字母。 示例代码： 123456789101112#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;int main() { char c = 'A'; if (isupper(c)) { printf(&quot;%c 是一个大写字母\\n&quot;, c); } else { printf(&quot;%c 不是一个大写字母\\n&quot;, c); } return 0;} int islower(int c)判断字符 c 是否为小写字母。 示例代码： 123456789101112#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;int main() { char c = 'a'; if (islower(c)) { printf(&quot;%c 是一个小写字母\\n&quot;, c); } else { printf(&quot;%c 不是一个小写字母\\n&quot;, c); } return 0;} 4. 总结C语言中的 ctype.h 库函数提供了字符处理功能，极大地简化了编程中和字符处理。、字符类型判断、大小写转换等多种常用操作。掌握这些函数的用法，可以大大提高编程效率和代码的可读性。 希望本文对你理解和使用ctype.h 库函数有所帮助。如果你有任何疑问或建议，欢迎在评论区留言讨论。","link":"/2024/06/30/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84ctype-h%E5%BA%93%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"title":"C语言中的math.h库函数用法详解","text":"C语言中的 math.h 库提供了一组数学函数，用于执行各种数学运算。本文将详细介绍这些函数及其用法。 1. 概述math.h 库包含了许多常用的数学函数，如三角函数、对数函数、指数函数、幂函数、平方根函数等。这些函数可以简化数学计算，提高编程效率。 2. 常用数学函数2.1 幂函数double pow(double x, double y)计算 x 的 y 次幂。 示例代码： 12345678910#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main() { double base = 2.0; double exponent = 3.0; double result = pow(base, exponent); printf(&quot;pow(%.1f, %.1f) = %.2f\\n&quot;, base, exponent, result); return 0;} 2.2 平方根函数double sqrt(double x)计算 x 的平方根。 示例代码： 123456789#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main() { double num = 16.0; double result = sqrt(num); printf(&quot;sqrt(%.1f) = %.2f\\n&quot;, num, result); return 0;} 2.3 三角函数double sin(double x)计算 x 的正弦值，x 的单位为弧度。 示例代码： 123456789#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main() { double angle = M_PI / 2; // 90度 double result = sin(angle); printf(&quot;sin(%.2f) = %.2f\\n&quot;, angle, result); return 0;} double cos(double x)计算 x 的余弦值，x 的单位为弧度。 示例代码： 123456789#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main() { double angle = M_PI / 3; // 60度 double result = cos(angle); printf(&quot;cos(%.2f) = %.2f\\n&quot;, angle, result); return 0;} double tan(double x)计算 x 的正切值，x 的单位为弧度。 示例代码： 123456789#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main() { double angle = M_PI / 4; // 45度 double result = tan(angle); printf(&quot;tan(%.2f) = %.2f\\n&quot;, angle, result); return 0;} 2.4 反三角函数double asin(double x)计算 x 的反正弦值，结果为弧度。 示例代码： 123456789#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main() { double value = 1.0; double result = asin(value); printf(&quot;asin(%.1f) = %.2f\\n&quot;, value, result); return 0;} double acos(double x)计算 x 的反余弦值，结果为弧度。 示例代码： 123456789#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main() { double value = 0.5; double result = acos(value); printf(&quot;acos(%.1f) = %.2f\\n&quot;, value, result); return 0;} double atan(double x)计算 x 的反正切值，结果为弧度。 示例代码： 123456789#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main() { double value = 1.0; double result = atan(value); printf(&quot;atan(%.1f) = %.2f\\n&quot;, value, result); return 0;} 2.5 对数函数double log(double x)计算 x 的自然对数（以 e 为底）。 示例代码： 123456789#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main() { double num = 10.0; double result = log(num); printf(&quot;log(%.1f) = %.2f\\n&quot;, num, result); return 0;} double log10(double x)计算 x 的常用对数（以 10 为底）。 示例代码： 123456789#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main() { double num = 10.0; double result = log10(num); printf(&quot;log10(%.1f) = %.2f\\n&quot;, num, result); return 0;} 2.6 指数函数double exp(double x)计算 e 的 x 次幂。 示例代码： 123456789#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main() { double exponent = 2.0; double result = exp(exponent); printf(&quot;exp(%.1f) = %.2f\\n&quot;, exponent, result); return 0;} 2.7 取整函数double ceil(double x)返回大于或等于 x 的最小整数值。 示例代码： 123456789#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main() { double num = 2.3; double result = ceil(num); printf(&quot;ceil(%.1f) = %.1f\\n&quot;, num, result); return 0;} double floor(double x)返回小于或等于 x 的最大整数值。 示例代码： 123456789#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main() { double num = 2.7; double result = floor(num); printf(&quot;floor(%.1f) = %.1f\\n&quot;, num, result); return 0;} double round(double x)返回四舍五入后的整数值。 示例代码： 123456789#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main() { double num = 2.5; double result = round(num); printf(&quot;round(%.1f) = %.1f\\n&quot;, num, result); return 0;} 2.8 绝对值函数double fabs(double x)返回 x 的绝对值。 示例代码： 123456789#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main() { double num = -5.5; double result = fabs(num); printf(&quot;fabs(%.1f) = %.1f\\n&quot;, num, result); return 0;} 3. 总结C语言中的 math.h 库函数提供了丰富的数学运算功能，极大地简化了编程中的数学计算。这些函数涵盖了幂运算、三角函数、对数函数、指数函数、取整函数和绝对值函数等多种常用操作。掌握这些函数的用法，可以大大提高编程效率和代码的可读性。 希望本文对你理解和使用 math.h 库函数有所帮助。如果你有任何疑问或建议，欢迎在评论区留言讨论。","link":"/2024/06/30/C%E8%AF%AD%E8%A8%80%E4%B8%AD-math-h-%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E7%94%A8%E6%B3%95/"},{"title":"C语言中的string.h库函数用法详解","text":"C语言中的 string.h 库提供了一组用于字符串处理的函数。这些函数可以帮助我们对字符串进行各种操作，如复制、连接、比较、搜索等。本文将详细介绍这些函数及其用法。 1. 概述string.h 库包含了许多常用的字符串处理函数，如字符串复制、连接、比较、查找、长度计算等。这些函数可以简化字符串操作，提高编程效率。 2. 常用字符串处理函数2.1 字符串长度size_t strlen(const char *str)计算字符串 str 的长度（不包括终止符 \\0）。 示例代码： 123456789#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() { char str[] = &quot;Hello, World!&quot;; size_t len = strlen(str); printf(&quot;The length of the string is: %zu\\n&quot;, len); return 0;} 2.2 字符串复制char *strcpy(char *dest, const char *src)将字符串 src 复制到 dest。 示例代码： 12345678910#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() { char src[] = &quot;Hello, World!&quot;; char dest[50]; strcpy(dest, src); printf(&quot;Destination string is: %s\\n&quot;, dest); return 0;} char *strncpy(char *dest, const char *src, size_t n)将字符串 src 的前 n 个字符复制到 dest。 示例代码： 1234567891011#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() { char src[] = &quot;Hello, World!&quot;; char dest[50]; strncpy(dest, src, 5); dest[5] = '\\0'; // 确保字符串以null终止 printf(&quot;Destination string is: %s\\n&quot;, dest); return 0;} 2.3 字符串连接char *strcat(char *dest, const char *src)将字符串 src 连接到 dest 的末尾。 示例代码： 12345678910#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() { char dest[50] = &quot;Hello&quot;; char src[] = &quot;, World!&quot;; strcat(dest, src); printf(&quot;Concatenated string is: %s\\n&quot;, dest); return 0;} char *strncat(char *dest, const char *src, size_t n)将字符串 src 的前 n 个字符连接到 dest 的末尾。 示例代码： 12345678910#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() { char dest[50] = &quot;Hello&quot;; char src[] = &quot;, World!&quot;; strncat(dest, src, 6); printf(&quot;Concatenated string is: %s\\n&quot;, dest); return 0;} 2.4 字符串比较int strcmp(const char *str1, const char *str2)比较字符串 str1 和 str2。 示例代码： 12345678910111213141516#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() { char str1[] = &quot;Hello&quot;; char str2[] = &quot;World&quot;; int result = strcmp(str1, str2); if (result == 0) { printf(&quot;The strings are equal.\\n&quot;); } else if (result &lt; 0) { printf(&quot;str1 is less than str2.\\n&quot;); } else { printf(&quot;str1 is greater than str2.\\n&quot;); } return 0;} int strncmp(const char *str1, const char *str2, size_t n)比较字符串 str1 和 str2 的前 n 个字符。 示例代码： 12345678910111213141516#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() { char str1[] = &quot;Hello&quot;; char str2[] = &quot;Helium&quot;; int result = strncmp(str1, str2, 3); if (result == 0) { printf(&quot;The first 3 characters of the strings are equal.\\n&quot;); } else if (result &lt; 0) { printf(&quot;The first 3 characters of str1 are less than str2.\\n&quot;); } else { printf(&quot;The first 3 characters of str1 are greater than str2.\\n&quot;); } return 0;} 2.5 字符串查找char *strchr(const char *str, int c)在字符串 str 中查找字符 c 的第一次出现，返回指向该字符的指针。 示例代码： 12345678910111213#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() { char str[] = &quot;Hello, World!&quot;; char *ptr = strchr(str, 'W'); if (ptr) { printf(&quot;Character found at position: %ld\\n&quot;, ptr - str); } else { printf(&quot;Character not found.\\n&quot;); } return 0;} char *strrchr(const char *str, int c)在字符串 str 中查找字符 c 的最后一次出现，返回指向该字符的指针。 示例代码： 12345678910111213#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() { char str[] = &quot;Hello, World!&quot;; char *ptr = strrchr(str, 'o'); if (ptr) { printf(&quot;Last occurrence of character found at position: %ld\\n&quot;, ptr - str); } else { printf(&quot;Character not found.\\n&quot;); } return 0;} char *strstr(const char *haystack, const char *needle)在字符串 haystack 中查找字符串 needle 的第一次出现，返回指向该字符串的指针。 示例代码： 1234567891011121314#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() { char haystack[] = &quot;Hello, World!&quot;; char needle[] = &quot;World&quot;; char *ptr = strstr(haystack, needle); if (ptr) { printf(&quot;Substring found at position: %ld\\n&quot;, ptr - haystack); } else { printf(&quot;Substring not found.\\n&quot;); } return 0;} 2.6 字符串拷贝char *strdup(const char *s)复制字符串 s 并返回一个指向新字符串的指针。需要注意的是，返回的新字符串是动态分配的，使用完后需要使用 free 函数释放。 示例代码： 123456789101112131415#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int main() { char str[] = &quot;Hello, World!&quot;; char *copy = strdup(str); if (copy) { printf(&quot;Duplicated string: %s\\n&quot;, copy); free(copy); // 释放动态分配的内存 } else { printf(&quot;Failed to duplicate string.\\n&quot;); } return 0;} 2.7 字符串长度size_t strnlen(const char *s, size_t maxlen)计算字符串 s 的长度，但最多检查 maxlen 个字符。如果在 maxlen 个字符之前找到了终止符，则返回实际长度；否则返回 maxlen。 示例代码： 123456789#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() { char str[] = &quot;Hello, World!&quot;; size_t len = strnlen(str, 5); printf(&quot;The length of the string (up to 5 characters) is: %zu\\n&quot;, len); return 0;} 3. 总结C语言中的 string.h 库函数提供了丰富的字符串处理功能，极大地简化了编程中的字符串操作。这些函数涵盖了字符串复制、连接、比较、查找、长度计算等多种常用操作。掌握这些函数的用法，可以大大提高编程效率和代码的可读性。 希望本文对你理解和使用 string.h 库函数有所帮助。如果你有任何疑问或建议，欢迎在评论区留言讨论。","link":"/2024/06/30/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84string-h%E5%BA%93%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"title":"动态规划相关题目","text":"1.队列中看得到最多学生人数的学生学校里有 N 个学生要站成一列纵队。队伍里的每个学生只能看见站在他前面、并且身高比他高的学生。例如，有 5 个学生站成一队，身高从前到后分别为 9 7 3 4 8 1，第 3 个学生能看到前 2 个学生，第 6 个学生只能看到第 1 和第 5 个学生。要求：给定队列中从前到后每个人的身高，请你给出一个有效的算法，计算出哪个学生能够看到最多的人数。 要解决这个问题，我们需要一个算法来确定每个学生能够看到前面几个学生。具体来说，每个学生只能看到他前面且身高比他高的学生。我们可以使用一个栈来高效地解决这个问题。 算法分析 使用栈： 我们可以从队列的前面向后面遍历，并使用一个栈来维护当前能被看到的学生。 对于每个学生，如果栈顶的学生比当前学生矮，那么当前学生可以看到栈顶的学生。因此，当前学生可以看到栈顶学生及其下面的所有学生。将当前学生的索引压入栈中。 栈中的学生会按从高到矮的顺序排列，以确保在后续处理时能够快速判断新学生能看到多少个之前的学生。 详细步骤： 初始化一个空栈和一个数组visible_count用于记录每个学生能看到的学生数量。 遍历学生队列： 对于每个学生，从栈中弹出所有比当前学生矮的学生，因为这些学生不能被后来的学生看到。 将当前学生的索引压入栈中。 记录当前学生能看到的学生数量，即栈的大小。 时间复杂度： 每个学生最多进栈和出栈一次，因此时间复杂度是 (O(N))。 代码实现123456789101112131415161718192021222324def max_visible_students(heights): n = len(heights) stack = [] visible_count = [0] * n for i in range(n): # 弹出所有比当前学生矮的学生 while stack and heights[stack[-1]] &lt;= heights[i]: stack.pop() # 当前学生能看到的学生数 visible_count[i] = len(stack) # 当前学生入栈 stack.append(i) # 找到能看到最多学生的那个学生的索引 max_visible = max(visible_count) student_index = visible_count.index(max_visible) return student_index, max_visible# 测试用例heights = [9, 7, 3, 4, 8, 1]index, max_visible = max_visible_students(heights)print(f&quot;第 {index+1} 个学生能看到最多的人数，为 {max_visible} 人&quot;) 证明最优子结构和重叠子问题 最优子结构： 对于每个学生，其能看到的学生数取决于他前面的学生的能见情况。这意味着问题可以分解成更小的子问题，每个子问题的解都可以合并得到最终问题的解。 重叠子问题： 在计算每个学生能看到的人数时，我们需要多次访问和比较同一个学生的身高。因此，有重叠的子问题。 综上所述，我们使用栈的解决方案具有最优子结构和重叠子问题性质，能够在 (O(N)) 时间内有效解决问题。","link":"/2024/07/03/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/"},{"title":"回溯法和相关例题","text":"回溯法在算法设计中的应用什么是回溯法？回溯法（Backtracking）是一种系统化地搜索问题解空间的方法，主要应用于组合优化问题。它通过构建解的空间树，并沿着这棵树的深度优先搜索来寻找问题的所有解或最优解。 回溯法的基本思想回溯法的基本思想是逐步构建解，并在构建过程中进行判断，如果当前部分解不满足问题的要求，则立即返回（剪枝），否则继续构建，直到找到一个完整的解。简言之，就是在探索解空间树时，走不通的路立即回头，尝试下一条路径。 回溯法的步骤 选择：选择一个可以扩展的节点。 扩展：将节点扩展出若干子节点。 可行性判断：判断这些子节点是否满足约束条件。 递归：对子节点重复上述步骤。 回溯：如果某条路径走到头且不满足条件，返回上一步继续尝试其他路径。 回溯法的例题例题：八皇后问题 八皇后问题是一个经典的回溯算法问题，要求在 8×8 的国际象棋棋盘上放置 8 个皇后，使得任意两个皇后都不能在同一行、同一列或同一斜线上。 解决思路 选择：选择棋盘的每一行。 扩展：尝试在当前行的每一列放置一个皇后。 可行性判断：检查当前皇后的位置是否与之前放置的皇后冲突（即是否在同一列或同一斜线上）。 递归：如果当前行可以放置皇后，则递归处理下一行。 回溯：如果当前行的所有列都无法放置皇后，则返回上一行重新选择。 伪代码123456789101112131415161718192021function solveNQueens(n): solutions = [] board = [-1] * n # 用一维数组表示棋盘，index 表示行，值表示列 backtrack(board, 0, n, solutions) return solutionsfunction backtrack(board, row, n, solutions): if row == n: solutions.append(board[:]) return for col in range(n): if isSafe(board, row, col): board[row] = col backtrack(board, row + 1, n, solutions) board[row] = -1 # 回溯function isSafe(board, row, col): for i in range(row): if board[i] == col or abs(board[i] - col) == abs(i - row): return False return True 示例代码（Python 实现）123456789101112131415161718192021222324252627def solve_n_queens(n): solutions = [] board = [-1] * n # 用一维数组表示棋盘，index 表示行，值表示列 def backtrack(board, row, n, solutions): if row == n: solutions.append(board[:]) return for col in range(n): if is_safe(board, row, col): board[row] = col backtrack(board, row + 1, n, solutions) board[row] = -1 # 回溯 def is_safe(board, row, col): for i in range(row): if board[i] == col or abs(board[i] - col) == abs(i - row): return False return True backtrack(board, 0, n, solutions) return solutions# 调用函数n = 8solutions = solve_n_queens(n)for solution in solutions: print(solution) 例题：图的着色问题 图的着色问题要求使用最少的颜色为图中的每个顶点着色，使得相邻顶点具有不同的颜色。 解决思路 选择：选择图中的每个顶点。 扩展：尝试为当前顶点着不同的颜色。 可行性判断：检查当前顶点的颜色是否与相邻顶点冲突。 递归：如果当前顶点可以着色，则递归处理下一个顶点。 回溯：如果所有颜色都无法为当前顶点着色，则返回上一步重新选择。 伪代码12345678910111213141516171819202122function graphColoring(graph, m): color = [-1] * len(graph) if not backtrack(graph, m, color, 0): return False return colorfunction backtrack(graph, m, color, v): if v == len(graph): return True for c in range(1, m + 1): if isSafe(graph, color, v, c): color[v] = c if backtrack(graph, m, color, v + 1): return True color[v] = -1 # 回溯 return Falsefunction isSafe(graph, color, v, c): for i in range(len(graph)): if graph[v][i] == 1 and color[i] == c: return False return True 示例代码（Python 实现）1234567891011121314151617181920212223242526272829303132333435def graph_coloring(graph, m): n = len(graph) color = [-1] * n def backtrack(v): if v == n: return True for c in range(1, m + 1): if is_safe(v, c): color[v] = c if backtrack(v + 1): return True color[v] = -1 # 回溯 return False def is_safe(v, c): for i in range(n): if graph[v][i] == 1 and color[i] == c: return False return True if not backtrack(0): return False return color# 示例输入graph = [ [0, 1, 1, 1], [1, 0, 1, 0], [1, 1, 0, 1], [1, 0, 1, 0]]m = 3result = graph_coloring(graph, m)print(&quot;图的着色:&quot;, result) 例题：求子集 求子集问题要求找出集合的所有子集。 解决思路 选择：选择集合中的每个元素。 扩展：将当前元素加入子集中或不加入。 递归：处理下一个元素。 回溯：在不加入当前元素的情况下处理下一个元素。 伪代码1234567891011function subsets(nums): result = [] backtrack(nums, 0, [], result) return resultfunction backtrack(nums, start, path, result): result.append(path[:]) for i in range(start, len(nums)): path.append(nums[i]) backtrack(nums, i + 1, path, result) path.pop() # 回溯 示例代码（Python 实现）1234567891011121314151617def subsets(nums): result = [] def backtrack(start, path): result.append(path[:]) for i in range(start, len(nums)): path.append(nums[i]) backtrack(i + 1, path) path.pop() # 回溯 backtrack(0, []) return result# 示例输入nums = [1, 2, 3]result = subsets(nums)print(&quot;所有子集:&quot;, result) 例题：字符串的排列 字符串的排列问题要求找出字符串的所有排列。 解决思路 选择：选择字符串中的每个字符。 扩展：将当前字符加入排列或不加入。 递归：处理剩下的字符。 回溯：移除当前字符，尝试其他字符。 伪代码12345678910111213function permute(s): result = [] backtrack(list(s), 0, result) return resultfunction backtrack(s, start, result): if start == len(s): result.append(''.join(s)) return for i in range(start, len(s)): s[start], s[i] = s[i], s[start] backtrack(s, start + 1, result) s[start], s[i] = s[i], s[start] # 回溯 示例代码（Python 实现）123456789101112131415161718192021def permute(s): result = [] def backtrack(s, start): if start == len(s): result.append(''.join(s)) return for i in range(start, len(s)): s[start], s[i] = s[i], s[start] backtrack(s, start + 1) s[start], s[i] = s[i], s[start] # 回溯 backtrack(list(s), 0) return result# 示例输入s = &quot;abc&quot;result = permute(s)print(&quot;所有排列:&quot;, result) 回溯法的优缺点优点： 简单直观：回溯法的思路简单直观，容易理解和实现。 灵活性强：可以应用于各种组合问题，如排列、组合、子集等。 缺点： 效率低：回溯法属于暴力搜索，可能需要遍历所有解空间，效率较低。 剪枝困难：对于复杂问题，剪枝条件不易设计，容易导致大量无效搜索。 总结回溯法是一种解决组合优化问题的有效方法，通过系统化地搜索问题解空间，能够找到所有满足条件的解或最优解。尽管效率较低，但通过合理的剪枝，可以在一定程度上提升算法性能。了解并掌握回溯法，对于解决类似问题有很大帮助。 以上就是关于回溯法及其应用的详细讲解，希望对你有所帮助！","link":"/2024/07/03/%E5%9B%9E%E6%BA%AF%E6%B3%95%E5%92%8C%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98/"},{"title":"算法设计证明题","text":"例题1.最长公共子串问题的最优子结构性质证明问题描述：证明最长公共子串问题具有最优子结构性质。 定义： 最长公共子串（Longest Common Substring, LCS）是指两个字符串中长度最长的公共子串。 动态规划算法： 12345678910111213141516def longest_common_substring(X, Y): m, n = len(X), len(Y) dp = [[0] * (n + 1) for _ in range(m + 1)] length = 0 # 存储最长公共子串的长度 end_pos = 0 # 存储最长公共子串在 X 结束的位置 for i in range(1, m + 1): for j in range(1, n + 1): if X[i - 1] == Y[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 if dp[i][j] &gt; length: length = dp[i][j] end_pos = i else: dp[i][j] = 0 return X[end_pos - length:end_pos] 最优子结构性质证明： 状态定义： dp[i][j] 表示 X[0:i] 和 Y[0:j] 以 X[i-1] 和 Y[j-1] 结尾的最长公共子串长度。 递推关系： 如果 X[i-1] == Y[j-1]，则 dp[i][j] = dp[i-1][j-1] + 1。 否则，dp[i][j] = 0。 初始条件： dp[0][*] = 0 和 dp[*][0] = 0，表示一个空串和任意串的最长公共子串长度为0。 最优子结构： 假设我们已经知道 X[0:i-1] 和 Y[0:j-1] 的最长公共子串，如果 X[i-1] == Y[j-1]，那么最长公共子串可以通过将 X[i-1] 和 Y[j-1] 加到 dp[i-1][j-1] 的结果中得到。 如果 X[i-1] != Y[j-1]，那么 X[0:i] 和 Y[0:j] 的最长公共子串长度为0。 通过上述递推关系，可以逐步计算每个子问题的解，从而得到整个问题的解。因此，最长公共子串问题具有最优子结构性质。 例题2.0/1 背包问题的最优子结构性质证明问题描述：证明0/1背包问题具有最优子结构性质。 定义： 0/1背包问题是指在给定一组物品，每个物品有一个重量和价值，在总重量不超过背包容量的情况下，选择若干物品使得其总价值最大。 动态规划算法： 1234567891011def knapsack(weights, values, W): n = len(weights) dp = [[0] * (W + 1) for _ in range(n + 1)] for i in range(1, n + 1): for w in range(1, W + 1): if weights[i - 1] &lt;= w: dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weights[i - 1]] + values[i - 1]) else: dp[i][w] = dp[i - 1][w] return dp[n][W] 最优子结构性质证明： 状态定义： dp[i][w] 表示前 i 个物品在总重量不超过 w 的情况下的最大价值。 递推关系： 如果不选第 i 个物品：dp[i][w] = dp[i - 1][w]。 如果选第 i 个物品：dp[i][w] = dp[i - 1][w - weights[i - 1]] + values[i - 1]，前提是 weights[i - 1] &lt;= w。 综合上述两种情况：\\[dp[i][w] = \\max(dp[i - 1][w], dp[i - 1][w - weights[i - 1]] + values[i - 1])\\] 初始条件： dp[0][*] = 0 和 dp[*][0] = 0，表示没有物品或背包容量为0时的最大价值为0。 最优子结构： 假设我们已经知道前 i-1 个物品在总重量不超过 w 和 w - weights[i-1] 情况下的最大价值。对于第 i 个物品，我们有两个选择： 不选第 i 个物品，那么最大价值是 dp[i - 1][w]。 选第 i 个物品，那么最大价值是 dp[i - 1][w - weights[i - 1]] + values[i - 1]。 通过选择这两者的最大值，我们得到 dp[i][w]。 因此，0/1背包问题具有最优子结构性质，可以通过解决子问题的最优解来构建原问题的最优解。 例题3：二分查找的正确性证明问题描述：给定一个有序数组 \\(A\\) 和一个目标值 \\(x\\)，证明二分查找算法能够在数组中找到目标值 \\(x\\)，或者在目标值不存在时正确返回。 证明： 二分查找算法： 1234567891011def binary_search(A, x): left, right = 0, len(A) - 1 while left &lt;= right: mid = (left + right) // 2 if A[mid] == x: return mid elif A[mid] &lt; x: left = mid + 1 else: right = mid - 1 return -1 证明过程： 初始条件：开始时，left 指向数组的第一个元素，right 指向数组的最后一个元素。 保持不变的条件：在每次迭代中，目标值 \\(x\\) 要么在当前搜索范围 [left, right] 之内，要么不在数组中。假设初始时搜索范围内包含 \\(x\\)，则在每次迭代中通过更新 left 和 right，我们保持这一条件： 如果 A[mid] == x，算法返回 mid，证明结束。 如果 A[mid] &lt; x，则 x 必定在 [mid + 1, right] 范围内，更新 left = mid + 1，保持不变条件成立。 如果 A[mid] &gt; x，则 x 必定在 [left, mid - 1] 范围内，更新 right = mid - 1，保持不变条件成立。 终止条件：循环终止时，left &gt; right，表示搜索范围为空。此时，算法正确返回 -1，表示 \\(x\\) 不在数组中。 例题4：快速排序的平均时间复杂度证明问题描述：证明快速排序的平均时间复杂度为 \\(O(n \\log n)\\)。 证明： 快速排序算法： 12345678def quicksort(A): if len(A) &lt;= 1: return A pivot = A[len(A) // 2] left = [x for x in A if x &lt; pivot] middle = [x for x in A if x == pivot] right = [x for x in A if x &gt; pivot] return quicksort(left) + middle + quicksort(right) 证明过程： 递归关系：设 \\(T(n)\\) 为排序 \\(n\\) 个元素的时间复杂度。假设每次选择的 pivot 将数组划分为两个子数组，左子数组大小为 \\(k\\)，右子数组大小为 \\(n - k - 1\\)。则：\\[T(n) = T(k) + T(n - k - 1) + O(n)\\] 期望划分：理想情况下，每次 pivot 选择能够均匀划分数组，即 \\(k = \\frac{n}{2}\\)。则递归关系为：\\[T(n) = 2T\\left(\\frac{n}{2}\\right) + O(n)\\] 递归求解：使用主定理求解递归关系：\\[T(n) = O(n \\log n)\\] 例题5：Dijkstra算法的正确性证明问题描述：证明Dijkstra算法能够在带非负权重的图中找到从源点到其他所有节点的最短路径。 证明： Dijkstra算法： 12345678910111213141516import heapqdef dijkstra(graph, start): heap = [(0, start)] distances = {vertex: float('infinity') for vertex in graph} distances[start] = 0 while heap: current_distance, current_vertex = heapq.heappop(heap) if current_distance &gt; distances[current_vertex]: continue for neighbor, weight in graph[current_vertex]: distance = current_distance + weight if distance &lt; distances[neighbor]: distances[neighbor] = distance heapq.heappush(heap, (distance, neighbor)) return distances 证明过程： 初始条件：开始时，所有节点的距离被初始化为无穷大，源点距离为0。优先队列中包含源点。 保持不变的条件：在每一步迭代中，优先队列中包含待处理节点的最短路径估计值。当前节点 current_vertex 是从源点到该节点的最短路径。 证明最短路径：假设当前节点 current_vertex 的最短路径已被确定，对其所有邻居节点 neighbor 更新距离： 如果 distance 小于 neighbor 的当前距离，更新 neighbor 的距离并将其加入优先队列。 通过松弛操作，不断更新各节点的最短路径，最终所有节点的最短路径被正确计算。 终止条件：优先队列为空时，所有节点的最短路径已确定，算法结束。 例题6：动态规划求解最长公共子序列（LCS）问题的正确性证明问题描述：证明动态规划算法能正确计算两个字符串的最长公共子序列。 证明： 动态规划算法： 12345678910def lcs(X, Y): m, n = len(X), len(Y) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if X[i - 1] == Y[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n] 证明过程： 状态定义：dp[i][j] 表示 X[0:i] 和 Y[0:j] 的最长公共子序列长度。 递推关系： 如果 X[i-1] == Y[j-1]，则 dp[i][j] = dp[i-1][j-1] + 1。 否则，dp[i][j] = max(dp[i-1][j], dp[i][j-1])。 初始条件：dp[0][*] = 0 和 dp[*][0] = 0，表示一个空串和任意串的最长公共子序列长度为0。 正确性证明：通过递推关系，逐步计算每个子问题的解，最终 dp[m][n] 为 X 和 Y 的最长公共子序列长度。 这些例题及其证明过程展示了算法设计和分析中常见的证明方法和步骤，希望对你有帮助。","link":"/2024/07/04/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E8%AF%81%E6%98%8E%E9%A2%98/"},{"title":"证明某个算法的时间复杂度","text":"证明某个算法策略的时间复杂度通常需要通过分析算法的每一步操作，并求出这些操作的总数随输入规模变化的函数关系。下面是一个详细的步骤，使用实例说明如何证明某个算法的时间复杂度。 一般步骤 明确输入规模：确定输入规模 \\(n\\) 是如何定义的（例如，数组的长度、图中的节点数等）。 分析每一步操作：逐步分析算法中的每一步操作，计算每一步操作的次数。 建立关系式：将每一步操作的次数累加起来，建立总的时间复杂度的关系式。 求解关系式：根据关系式，使用渐进分析法（大O符号）求解时间复杂度。 示例：证明快速排序的平均时间复杂度快速排序算法： 12345678def quicksort(A): if len(A) &lt;= 1: return A pivot = A[len(A) // 2] left = [x for x in A if x &lt; pivot] middle = [x for x in A if x == pivot] right = [x for x in A if x &gt; pivot] return quicksort(left) + middle + quicksort(right) 步骤1：明确输入规模 输入规模 \\(n\\) 是数组 \\(A\\) 的长度。 步骤2：分析每一步操作 分区操作：选择枢纽元 pivot，并将数组分为 left、middle 和 right 三部分。此操作需要遍历整个数组 \\(A\\)，因此时间复杂度为 \\(O(n)\\)。 递归调用：对 left 和 right 递归调用 quicksort。 步骤3：建立关系式 设 \\(T(n)\\) 为排序长度为 \\(n\\) 的数组所需的时间。 分区操作时间为 \\(O(n)\\)，递归调用时间为 left 和 right 的排序时间。假设每次 pivot 将数组均匀分为两部分（理想情况），则：\\[T(n) = T\\left(\\frac{n}{2}\\right) + T\\left(\\frac{n}{2}\\right) + O(n) = 2T\\left(\\frac{n}{2}\\right) + O(n)\\] 步骤4：求解关系式 使用递归树或主定理（Master Theorem）求解递归关系。 主定理的形式：对于 \\(T(n) = aT\\left(\\frac{n}{b}\\right) + f(n)\\)，如果 \\(a = 2\\)、\\(b = 2\\)、\\(f(n) = O(n)\\)，符合主定理的第二种情况（ \\(f(n) = O(n^{\\log_b a})\\)），即 \\(f(n) = O(n)\\)，\\(a = b\\)：\\[T(n) = O(n \\log n)\\] 因此，快速排序的平均时间复杂度为 \\(O(n \\log n)\\)。 进一步例子：线性搜索的时间复杂度线性搜索算法： 12345def linear_search(A, x): for i in range(len(A)): if A[i] == x: return i return -1 步骤1：明确输入规模 输入规模 \\(n\\) 是数组 \\(A\\) 的长度。 步骤2：分析每一步操作 最坏情况下，需要遍历整个数组才能找到目标值 \\(x\\)，或者确认 \\(x\\) 不在数组中。 步骤3：建立关系式 在最坏情况下，循环执行 \\(n\\) 次，比较操作执行 \\(n\\) 次。 步骤4：求解关系式 总操作次数为 \\(n\\)，时间复杂度为 \\(O(n)\\)。 总结证明一个算法的时间复杂度需要以下几步： 明确输入规模 \\(n\\)。 分析每一步操作的次数。 建立总的时间复杂度关系式。 使用渐进分析法（大O符号）求解关系式。 这些步骤可以帮助我们系统地分析和证明各种算法的时间复杂度。","link":"/2024/07/04/%E8%AF%81%E6%98%8E%E6%9F%90%E4%B8%AA%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"title":"主定理法的证明","text":"主定理（Master Theorem）是一种用于求解递归关系的工具，特别适用于形式为 \\(T(n) = aT\\left(\\frac{n}{b}\\right) + f(n)\\) 的递归关系。主定理提供了一种方法，通过比较递归部分和非递归部分的增长率，来推断递归关系的渐近解。 主定理的陈述设 \\(T(n)\\) 是由以下递归关系定义的函数：\\[ T(n) = aT\\left(\\frac{n}{b}\\right) + f(n) \\]其中 \\(a \\geq 1\\) 且 \\(b &gt; 1\\) 是常数，\\(f(n)\\) 是一个给定的函数。那么，\\(T(n)\\) 的渐近行为可以由以下三种情况之一来描述： 如果存在常数 \\(\\epsilon &gt; 0\\) 使得 \\(f(n) = O(n^{\\log_b a - \\epsilon})\\)，则 \\(T(n) = \\Theta(n^{\\log_b a})\\)。 如果 \\(f(n) = \\Theta(n^{\\log_b a})\\)，则 \\(T(n) = \\Theta(n^{\\log_b a} \\log n)\\)。 如果存在常数 \\(\\epsilon &gt; 0\\) 使得 \\(f(n) = \\Omega(n^{\\log_b a + \\epsilon})\\)，且对于某个常数 \\(c &lt; 1\\) 和所有足够大的 \\(n\\)，满足 \\(af\\left(\\frac{n}{b}\\right) \\leq cf(n)\\)，则 \\(T(n) = \\Theta(f(n))\\)。 主定理的证明主定理的证明涉及对递归关系的逐层展开，并通过比较递归部分和非递归部分的增长率，来推断出递归关系的渐近解。以下是三种情况的证明思路： 情况1： \\(f(n) = O(n^{\\log_b a - \\epsilon})\\)我们通过多次展开递归关系来证明： \\[ T(n) = aT\\left(\\frac{n}{b}\\right) + f(n) \\] 将 \\(T\\left(\\frac{n}{b}\\right)\\) 继续展开： \\[ T\\left(\\frac{n}{b}\\right) = aT\\left(\\frac{n}{b^2}\\right) + f\\left(\\frac{n}{b}\\right) \\] 将其代入： \\[ T(n) = a \\left(aT\\left(\\frac{n}{b^2}\\right) + f\\left(\\frac{n}{b}\\right)\\right) + f(n) \\]\\[ T(n) = a^2T\\left(\\frac{n}{b^2}\\right) + af\\left(\\frac{n}{b}\\right) + f(n) \\] 继续展开 \\(k\\) 次： \\[ T(n) = a^kT\\left(\\frac{n}{b^k}\\right) + \\sum_{i=0}^{k-1} a^i f\\left(\\frac{n}{b^i}\\right) \\] 最终，当 \\(k = \\log_b n\\) 时，\\(\\frac{n}{b^k} = 1\\)，此时 \\(T(1)\\) 为常数： \\[ T(n) = a^{\\log_b n} T(1) + \\sum_{i=0}^{\\log_b n - 1} a^i f\\left(\\frac{n}{b^i}\\right) \\] 因为 \\(a^{\\log_b n} = n^{\\log_b a}\\)： \\[ T(n) = n^{\\log_b a} T(1) + \\sum_{i=0}^{\\log_b n - 1} a^i f\\left(\\frac{n}{b^i}\\right) \\] 由于 \\(f(n) = O(n^{\\log_b a - \\epsilon})\\)，\\(\\sum_{i=0}^{\\log_b n - 1} a^i f\\left(\\frac{n}{b^i}\\right) = O(n^{\\log_b a - \\epsilon}) \\times \\sum_{i=0}^{\\log_b n - 1} (a/b^i) = O(n^{\\log_b a - \\epsilon})\\)。 因此，\\(\\sum_{i=0}^{\\log_b n - 1} a^i f\\left(\\frac{n}{b^i}\\right) \\leq n^{\\log_b a}\\)。 综上，\\(T(n) = \\Theta(n^{\\log_b a})\\)。 情况2： \\(f(n) = \\Theta(n^{\\log_b a})\\)类似地，通过展开递归关系，我们可以得到： \\[ T(n) = a^kT\\left(\\frac{n}{b^k}\\right) + \\sum_{i=0}^{k-1} a^i f\\left(\\frac{n}{b^i}\\right) \\] 当 \\(k = \\log_b n\\) 时： \\[ T(n) = n^{\\log_b a} T(1) + \\sum_{i=0}^{\\log_b n - 1} a^i \\Theta\\left(\\left(\\frac{n}{b^i}\\right)^{\\log_b a}\\right) \\]\\[ T(n) = n^{\\log_b a} T(1) + \\sum_{i=0}^{\\log_b n - 1} n^{\\log_b a} \\] 由于有 \\(\\log_b n\\) 个项： \\[ T(n) = n^{\\log_b a} \\log n \\] 因此，\\(T(n) = \\Theta(n^{\\log_b a} \\log n)\\)。 情况3： \\(f(n) = \\Omega(n^{\\log_b a + \\epsilon})\\)在这种情况下，假设 \\(f(n) = \\Omega(n^{\\log_b a + \\epsilon})\\)，且对于某个常数 \\(c &lt; 1\\) 和所有足够大的 \\(n\\)，满足 \\(af\\left(\\frac{n}{b}\\right) \\leq cf(n)\\)。 展开递归关系： \\[ T(n) = a^kT\\left(\\frac{n}{b^k}\\right) + \\sum_{i=0}^{k-1} a^i f\\left(\\frac{n}{b^i}\\right) \\] 由于 \\(af\\left(\\frac{n}{b}\\right) \\leq cf(n)\\)，递归展开后： \\[ T(n) \\leq f(n) \\sum_{i=0}^{k-1} a^i c^i \\] 当 \\(k \\rightarrow \\infty\\) 时，\\(\\sum_{i=0}^{\\infty} (ac)^i = \\frac{1}{1 - ac}\\)： \\[ T(n) = \\Theta(f(n)) \\] 综上，证明了主定理的三种情况。通过主定理，可以快速求解许多常见递归关系的时间复杂度。","link":"/2024/07/04/%E4%B8%BB%E5%AE%9A%E7%90%86%E6%B3%95%E7%9A%84%E8%AF%81%E6%98%8E/"},{"title":"传统的图像隐写术和结合深度学习的图像隐写术二者各自的优缺点","text":"图像隐写术（Steganography）是一种信息隐藏技术，用于在图像、视频、音频等多媒体文件中隐藏数据。传统的图像隐写方法和结合深度学习的图像隐写方法各有优缺点，以下是对它们的对比分析： 传统方法优点 简单易实现：传统方法通常基于简单的算法，如最低有效位（LSB）替换、DCT（离散余弦变换）域隐写等，易于理解和实现。 计算效率高：这些方法的计算复杂度较低，处理速度快，适合资源有限的环境。 低存储需求：所需的存储空间较小，不需要复杂的模型参数和训练数据。 确定性强：结果是确定的，具有可预测性和稳定性。 缺点 安全性低：传统方法容易被检测和攻击，例如统计分析、隐写分析等方法可以较容易地检测出隐藏信息。 鲁棒性差：对图像的常见操作如压缩、裁剪、旋转等不敏感，隐藏信息容易丢失。 容量有限：可隐藏的信息量通常较小，无法满足大容量数据隐藏的需求。 结合深度学习的方法优点 高安全性：深度学习方法可以生成更为复杂和难以检测的隐写模式，提升了隐写信息的安全性和隐蔽性。 鲁棒性强：深度学习方法可以通过训练增强对图像变换（如压缩、裁剪、旋转等）的鲁棒性，隐藏信息不易丢失。 大容量：深度学习方法可以有效利用图像的冗余部分，隐藏更大容量的信息。 自适应性强：可以根据不同的图像内容和隐藏信息需求，自动调整隐写策略，提高隐写效果。 缺点 复杂度高：需要设计和训练复杂的深度学习模型，算法实现和调试难度较大。 计算资源需求高：模型训练和推理需要大量的计算资源和时间，不适合资源受限的环境。 存储需求高：深度学习模型参数和训练数据需要大量存储空间，增加了存储成本。 不确定性：由于模型的复杂性和随机性，结果可能不稳定，不同次运行可能产生不同的隐写效果。 总结传统方法和结合深度学习的隐写方法各有优劣，选择适当的方法需要考虑具体应用场景的需求。对于计算资源有限、需要快速实现的场景，传统方法可能更适用；而对于安全性和鲁棒性要求高、数据容量大的应用场景，结合深度学习的方法则具有显著优势。","link":"/2024/07/12/%E4%BC%A0%E7%BB%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E9%9A%90%E5%86%99%E6%9C%AF%E5%92%8C%E7%BB%93%E5%90%88%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%9B%BE%E5%83%8F%E9%9A%90%E5%86%99%E6%9C%AF%E4%BA%8C%E8%80%85%E5%90%84%E8%87%AA%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9/"},{"title":"swimtransformer和transformer之间的区别","text":"SwimTransformer 和 Transformer 都是基于深度学习的模型，但它们的架构和应用领域有所不同。以下是它们之间的主要区别： Transformer背景: Transformer 是由 Vaswani 等人在 2017 年提出的，是一种用于自然语言处理（NLP）的模型。其主要用于序列到序列的任务，如机器翻译、文本生成、文本分类等。 架构: 自注意力机制: Transformer 的核心是自注意力机制（Self-Attention），它可以在不考虑序列顺序的情况下处理序列中的每一个元素，并捕捉序列中元素之间的依赖关系。 编码器-解码器架构: 原始的 Transformer 包括一个编码器（encoder）和一个解码器（decoder）两个部分。编码器将输入序列编码成一个固定长度的上下文向量，解码器根据这个上下文向量生成输出序列。 并行处理: 由于自注意力机制的引入，Transformer 可以进行并行处理，提高了训练和推理的速度。 应用: 主要应用于NLP任务，如机器翻译、文本摘要、情感分析等。 Swin Transformer背景: Swin Transformer（Shifted Window Transformer）是由 Microsoft Research Asia 在 2021 年提出的，主要用于计算机视觉任务。它是 Vision Transformer（ViT）的一个改进版本，旨在提高视觉任务中的性能。 架构: 局部注意力机制: 与传统的全局自注意力机制不同，Swin Transformer 引入了局部窗口的自注意力机制，通过将输入图像划分为若干不重叠的小窗口，并在每个窗口内计算自注意力，这样可以减少计算量。 滑动窗口机制: 为了捕捉跨窗口的全局信息，Swin Transformer 采用了滑动窗口（Shifted Window）机制，通过交错地移动窗口位置，使得不同窗口之间能够相互交互。 分层架构: Swin Transformer 具有分层架构，每一层对输入进行逐步缩放，逐渐聚合全局信息。这类似于卷积神经网络（CNN）的分层特征提取过程。 应用: 主要应用于计算机视觉任务，如图像分类、目标检测、图像分割等。 总结 Transformer 主要用于自然语言处理任务，依赖全局自注意力机制，可以并行处理序列数据。 Swin Transformer 是一个改进的视觉Transformer，主要用于计算机视觉任务，通过局部窗口自注意力和滑动窗口机制来减少计算复杂度并捕捉图像的全局信息。 通过以上比较可以看出，尽管二者都基于自注意力机制，但在具体架构和应用领域上有显著的不同。","link":"/2024/07/13/swimtransformer%E5%92%8Ctransformer%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"title":"厦门大学夏令营机试第一题-根据数字各位数之和排序","text":"题目描述给定两个整数 n 和 m，需要对从 n 到 m 的所有整数进行排序。排序规则如下： 按照每个数字各位数之和从小到大排序。 如果各位数之和相同，则按照数字的大小从小到大排序。 例如： 数字 9 排在数字 123 后面，因为 1 + 2 + 3 = 6 而 9 自身的各位数之和是 9。 数字 36 排在数字 9 后面，因为 3 + 6 = 9，但 36 大于 9。 题解为了实现上述排序，我们可以使用 C++ 编写一个程序来完成。主要的思路是： 编写一个函数来计算数字的各位数之和。 编写一个比较函数，先比较各位数之和，如果相等则比较数字本身的大小。 使用 sort 函数进行排序。 以下是完整的 C++ 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;string&gt;using namespace std;// 计算数字每一位的和int digitSum(int number) { int sum = 0; // 初始化和为0 while (number) { sum += number % 10; // 将当前位加到和上 number /= 10; // 去掉当前位 } return sum; // 返回各位数之和}// 比较函数bool compare(int a, int b) { int sumA = digitSum(a); // 计算a的各位数之和 int sumB = digitSum(b); // 计算b的各位数之和 if (sumA == sumB) { return a &lt; b; // 如果各位数之和相等，按数值大小排序 } return sumA &lt; sumB; // 否则按各位数之和排序}int main() { int n, m; cout &lt;&lt; &quot;请输入开始的整数n: &quot;; cin &gt;&gt; n; cout &lt;&lt; &quot;请输入结束的整数m: &quot;; cin &gt;&gt; m; vector&lt;int&gt; numbers; for (int i = n; i &lt;= m; ++i) { numbers.push_back(i); // 将从n到m的所有整数添加到数组中 } // 按照比较函数排序 sort(numbers.begin(), numbers.end(), compare); cout &lt;&lt; &quot;排序后的数字: &quot;; for (int num : numbers) { cout &lt;&lt; num &lt;&lt; &quot; &quot;; // 输出排序后的数字 } cout &lt;&lt; endl; return 0;}","link":"/2024/08/06/%E5%8E%A6%E9%97%A8%E5%A4%A7%E5%AD%A6%E5%A4%8F%E4%BB%A4%E8%90%A5%E6%9C%BA%E8%AF%95%E7%AC%AC%E4%B8%80%E9%A2%98/"},{"title":"厦门大学夏令营机试第二题-堆栈合理性判断","text":"题目描述给定两个整数 N 和 M，N 代表需要判断的操作个数，M 代表堆栈的容量。接着输入 N 个堆栈的操作，S 代表入栈，X 代表出栈，每行输入一个字符串，判断每次操作是否合法。 例如： 如果在栈为空的时候执行出栈操作，则操作不合法。 如果栈的大小超过容量 M，则操作不合法。 题解为了判断堆栈操作的合法性，我们可以使用 C++ 编写一个程序来完成。主要的思路是： 使用一个栈来模拟堆栈操作。 遍历所有操作，根据操作类型进行入栈或出栈，并在每一步检查操作是否合法。 以下是完整的 C++ 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;bool isValidStackOperations(int M, const string&amp; operations) { stack&lt;int&gt; stk; for (char op : operations) { if (op == 's') { if (stk.size() &gt;= M) { return false; // 如果栈的大小超过容量 M，则操作不合法 } stk.push(1); // 用1代表任意入栈的数字，因为具体数字不重要 } else if (op == 'x') { if (stk.empty()) { return false; // 如果在栈为空的时候执行出栈操作，则操作不合法 } stk.pop(); } else { return false; // 非法字符 } } return true; // 所有操作合法}int main() { int N, M; cout &lt;&lt; &quot;请输入操作序列的个数N和堆栈容量M: &quot;; cin &gt;&gt; N &gt;&gt; M; cin.ignore(); // 清除输入缓冲区 vector&lt;string&gt; allOperations(N); for (int i = 0; i &lt; N; ++i) { cout &lt;&lt; &quot;请输入操作字符串: &quot;; getline(cin, allOperations[i]); } for (string operations : allOperations) { if (isValidStackOperations(M, operations)) { cout &lt;&lt; &quot;操作合法&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;操作不合法&quot; &lt;&lt; endl; } } return 0;} 示例1输入： 1232 3ssxxssxsxsxssxxsss 输出： 12345请输入操作序列的个数N和堆栈容量M: 2 3请输入操作字符串: ssxxs请输入操作字符串: sxsxsxssxxsss操作合法操作不合法","link":"/2024/08/06/%E5%8E%A6%E9%97%A8%E5%A4%A7%E5%AD%A6%E5%A4%8F%E4%BB%A4%E8%90%A5%E6%9C%BA%E8%AF%95%E7%AC%AC%E4%BA%8C%E9%A2%98-%E5%A0%86%E6%A0%88%E5%90%88%E7%90%86%E6%80%A7%E5%88%A4%E6%96%AD/"},{"title":"厦门大学夏令营机试第三题-淘汰赛","text":"题目描述有多个国家进行比赛，每个国家有个战力值，两两进行比赛，战力值高的获胜，求获得亚军的国家是哪个。比如有四个国家，A和B比，C和D比，最后获胜的两个国家再两两比较，求最终的亚军国家。 题解比赛过程如下： 按照输入顺序进行两两比较，胜者进入下一轮。 重复上述过程直到只剩下两个国家。 两个国家进行决赛，决赛的失败者即为亚军。 代码实现下面是实现上述逻辑的C++代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;climits&gt;using namespace std;const int maxn = 100; // 最大国家数量const int INF = INT_MAX; // 用于标记无穷大int n, a[maxn], tmp[maxn &lt;&lt; 1]; // tmp数组大小为a的两倍// 比赛函数，返回获胜的战力值位置int winner(int pos1, int pos2) { int u = pos1 &gt;= n ? pos1 : tmp[pos1]; int v = pos2 &gt;= n ? pos2 : tmp[pos2]; if (tmp[u] &gt;= tmp[v]) return u; return v;}void create_tree(int &amp;champion, int &amp;runner_up) { // 将国家的战力值复制到 tmp 数组的后半部分 for (int i = 0; i &lt; n; i++) tmp[n + i] = a[i]; // 从底层向上构建淘汰树 for (int i = 2 * n - 1; i &gt; 1; i -= 2) { int k = i / 2; int j = i - 1; tmp[k] = winner(i, j); } champion = tmp[tmp[1]]; // 找到亚军：在tmp[2]和tmp[3]中较小的值 int pos2 = 2, pos3 = 3; int final_pos2 = (tmp[pos2] &gt;= n) ? tmp[pos2] : tmp[tmp[pos2]]; int final_pos3 = (tmp[pos3] &gt;= n) ? tmp[pos3] : tmp[tmp[pos3]]; runner_up = (tmp[final_pos2 ] &gt; tmp[final_pos3 ]) ? tmp[final_pos3] : tmp[final_pos2];}int main() { cout &lt;&lt; &quot;请输入国家数量: &quot;; cin &gt;&gt; n; cout &lt;&lt; &quot;请输入各国家的战力值: &quot;; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; a[i]; } int champion_value, runner_up_value; create_tree(champion_value, runner_up_value); cout &lt;&lt; &quot;冠军的战力值是: &quot; &lt;&lt; champion_value &lt;&lt; endl; cout &lt;&lt; &quot;亚军的战力值是: &quot; &lt;&lt; runner_up_value &lt;&lt; endl; return 0;} 代码解释这段代码实现了一个比赛淘汰树，用来找出一组国家中的冠军和亚军。以下是对代码的详细解释： 引入头文件和命名空间123#include &lt;iostream&gt;#include &lt;climits&gt;using namespace std; 引入标准输入输出库&lt;iostream&gt;，以及&lt;climits&gt;用于获取整型的最大值。 使用std命名空间，方便后续代码编写。 定义常量和变量1234const int maxn = 100; // 最大国家数量const int INF = INT_MAX; // 用于标记无穷大int n, a[maxn], tmp[maxn &lt;&lt; 1]; // tmp数组大小为a的两倍 maxn定义了最多可以有100个国家。 INF表示无穷大，使用系统提供的INT_MAX。 n表示国家的数量，a数组存储每个国家的战力值，tmp数组是a数组大小的两倍，用于构建淘汰树。 比赛函数123456int winner(int pos1, int pos2) { int u = pos1 &gt;= n ? pos1 : tmp[pos1]; int v = pos2 &gt;= n ? pos2 : tmp[pos2]; if (tmp[u] &gt;= tmp[v]) return u; return v;} winner函数用于返回两个位置中战力值较大的那个。 如果位置大于等于n，说明已经在tmp数组后半部分，直接取pos1或pos2的值，否则取tmp中的值。 比较两个值，返回较大的那个位置。 构建淘汰树并找出冠军和亚军1234567891011121314void create_tree(int &amp;champion, int &amp;runner_up) { for (int i = 0; i &lt; n; i++) tmp[n + i] = a[i]; for (int i = 2 * n - 1; i &gt; 1; i -= 2) { int k = i / 2; int j = i - 1; tmp[k] = winner(i, j); } champion = tmp[tmp[1]]; int pos2 = 2, pos3 = 3; int final_pos2 = (tmp[pos2] &gt;= n) ? tmp[pos2] : tmp[tmp[pos2]]; int final_pos3 = (tmp[pos3] &gt;= n) ? tmp[pos3] : tmp[tmp[pos3]]; runner_up = (tmp[final_pos2] &gt; tmp[final_pos3]) ? tmp[final_pos3] : tmp[final_pos2];} 首先，将国家的战力值复制到tmp数组的后半部分。 然后，从底层向上构建淘汰树。每次取两个位置进行比较，存储较大值的位置到上一级位置。 最后，找到冠军，即tmp[1]所对应的值。 找到亚军的方法：在tmp[2]和tmp[3]中较小的值，即冠军的左右子树中次优的那个值。 主函数1234567891011121314151617int main() { cout &lt;&lt; &quot;请输入国家数量: &quot;; cin &gt;&gt; n; cout &lt;&lt; &quot;请输入各国家的战力值: &quot;; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; a[i]; } int champion_value, runner_up_value; create_tree(champion_value, runner_up_value); cout &lt;&lt; &quot;冠军的战力值是: &quot; &lt;&lt; champion_value &lt;&lt; endl; cout &lt;&lt; &quot;亚军的战力值是: &quot; &lt;&lt; runner_up_value &lt;&lt; endl; return 0;} 主函数负责读取输入，并调用create_tree函数找出冠军和亚军。 读取国家数量n和各国家的战力值a。 调用create_tree函数，并输出冠军和亚军的战力值。 这段代码通过构建一棵淘汰树，高效地找出了冠军和亚军的战力值。","link":"/2024/08/06/%E5%8E%A6%E9%97%A8%E5%A4%A7%E5%AD%A6%E5%A4%8F%E4%BB%A4%E8%90%A5%E6%9C%BA%E8%AF%95%E7%AC%AC%E4%B8%89%E9%A2%98-%E6%AF%94%E8%B5%9B/"},{"title":"厦门大学夏令营机试第四题-13位ISBN号的校验码计算和输出","text":"题目描述编写一个程序，根据输入的13位ISBN书号（可能包含分隔符“-”）求出对应的校验码，并用校验码替换最后一位书号，最后输出替换后的书号（输出中保留原有的分隔符）。 13位ISBN校验码计算方法如下： 移除输入中所有的分隔符“-”。 将前12位数字从左到右依次标记为 \\( d_1, d_2, \\ldots, d_{12} \\)。 计算校验和：\\[ S = d_1 + 3 \\cdot d_2 + d_3 + 3 \\cdot d_4 + \\ldots + d_{11} + 3 \\cdot d_{12} \\] 校验码为：\\[C=(10-(S\\%10))\\% 10\\] 用校验码替换书号的最后一位数字。 输出带有分隔符的ISBN书号。 题解 从输入中读取13位ISBN书号，并移除其中的所有分隔符“-”。 计算前12位数字的校验和。 根据校验和计算校验码。 将校验码替换书号的最后一位。 输出带有分隔符的替换后的书号。 代码实现下面是实现上述逻辑的C++代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;// 移除ISBN中的分隔符string remove_hyphens(const string&amp; isbn) { string clean_isbn; for (char c : isbn) { if (c != '-') { clean_isbn += c; } } return clean_isbn;}// 计算13位ISBN的校验码int calculate_checksum(const string&amp; isbn) { int sum = 0; for (int i = 0; i &lt; 12; ++i) { int digit = isbn[i] - '0'; if (i % 2 == 0) { sum += digit; } else { sum += 3 * digit; } } int checksum = (10 - (sum % 10)) % 10; return checksum;}// 替换最后一位校验码string replace_checksum(string isbn) { int checksum = calculate_checksum(isbn); isbn[12] = '0' + checksum; return isbn;}// 恢复原始ISBN格式，只替换校验码string format_isbn(const string&amp; original, char checksum_char) { string formatted_isbn = original; formatted_isbn[original.size() - 1] = checksum_char; return formatted_isbn;}int main() { vector&lt;string&gt; isbns; string isbn; cout &lt;&lt; &quot;请输入13位ISBN号（可能包含分隔符'-'），输入完毕后输入'EXIT'：&quot; &lt;&lt; endl; // 连续输入ISBN号 while (true) { cin &gt;&gt; isbn; if (isbn == &quot;EXIT&quot;) { break; } isbns.push_back(isbn); } // 处理并输出每个ISBN的结果 for (const string&amp; isbn : isbns) { // 移除分隔符 string clean_isbn = remove_hyphens(isbn); if (clean_isbn.length() != 13) { cout &lt;&lt; &quot;输入的ISBN号长度不正确，移除分隔符后必须是13位: &quot; &lt;&lt; isbn &lt;&lt; endl; continue; } int checksum = calculate_checksum(clean_isbn); char checksum_char = '0' + checksum; string formatted_isbn = format_isbn(isbn, checksum_char); cout &lt;&lt; &quot;原始ISBN号: &quot; &lt;&lt; isbn &lt;&lt; &quot; -&gt; 新的ISBN号是: &quot; &lt;&lt; formatted_isbn &lt;&lt; endl; } return 0;} 示例1输入： 1234输入13位ISBN号（可能包含分隔符'-'），输入完毕后输入'结束'：978-0-306-40615-3978-0-306-40615-7EXIT 输出： 12原始ISBN号: 978-0-306-40615-3 -&gt; 新的ISBN号是: 978-0-306-40615-7原始ISBN号: 978-0-306-40615-7 -&gt; 新的ISBN号是: 978-0-306-40615-7","link":"/2024/08/07/%E5%8E%A6%E9%97%A8%E5%A4%A7%E5%AD%A6%E5%A4%8F%E4%BB%A4%E8%90%A5%E6%9C%BA%E8%AF%95%E7%AC%AC%E5%9B%9B%E9%A2%98-13%E4%BD%8DISBN%E5%8F%B7%E7%9A%84%E6%A0%A1%E9%AA%8C%E7%A0%81%E8%AE%A1%E7%AE%97%E5%92%8C%E8%BE%93%E5%87%BA/"},{"title":"cin 和getline还有sacanf 输入字符串的区别","text":"C++ 输入方法的区别：cin, getline 和 scanf在 C++ 中，cin、getline 和 scanf 都可以用于从输入中读取字符串，但它们在处理输入时有一些显著的区别。了解这些区别可以帮助你在不同情况下选择合适的输入方法。以下是它们的详细对比： cincin 是 C++ 标准输入流，通常用于读取输入数据。 特点： cin 会忽略前导空白字符（空格、制表符和换行符）。 cin 读取字符串时，以空白字符（空格、制表符和换行符）作为分隔符，只读取第一个单词。 cin 可以链式调用，多次读取多个数据。 示例： 12345678910#include &lt;iostream&gt;using namespace std;int main() { string input; cout &lt;&lt; &quot;请输入字符串: &quot;; cin &gt;&gt; input; // 只读取到第一个空格或换行符之前的内容 cout &lt;&lt; &quot;输入的是: &quot; &lt;&lt; input &lt;&lt; endl; return 0;} 输入：Hello World 输出：输入的是: Hello getlinegetline 是一个全局函数，用于从输入流中读取一整行，包括空白字符。特点： getline 读取整行输入，直到遇到换行符为止（换行符不包括在读取的内容中）。 getline 不会忽略前导空白字符。示例1234567891011#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() { string input; cout &lt;&lt; &quot;请输入字符串: &quot;; getline(cin, input); // 读取整行输入，包括空格 cout &lt;&lt; &quot;输入的是: &quot; &lt;&lt; input &lt;&lt; endl; return 0;} 输入：Hello World 输出： 输入的是: Hello World scanfscanf 是 C 标准库中的函数，用于格式化输入。特点： scanf 使用格式化字符串，支持多种数据类型的输入。 scanf 读取字符串时，以空白字符（空格、制表符和换行符）作为分隔符，只读取第一个单词。 需要手动处理输入缓冲区的问题。 示例 12345678910#include &lt;cstdio&gt;using namespace std;int main() { char input[100]; printf(&quot;请输入字符串: &quot;); scanf(&quot;%s&quot;, input); // 只读取到第一个空格或换行符之前的内容 printf(&quot;输入的是: %s\\n&quot;, input); return 0;} 输入：Hello World 输出： 输入的是: Hello 总结cin：适用于简单的、无空格的输入。如果需要读取多个数据类型，可以链式使用。适合读取单个单词或数值。getline：适用于需要读取包含空格的整行输入。对于需要处理整行数据的情况是最好的选择。scanf：适用于格式化输入，可以读取不同的数据类型。适合需要精确控制输入格式的场景，但在处理字符串时，只能读取到第一个空格或换行符之前的内容。根据你具体的输入需求，选择合适的输入方式。例如，在处理需要读取整行输入（包括空格）的场景时，getline 是最好的选择。在处理简单单词或数值输入时，cin 更为简便。而在需要格式化输入时，可以使用 scanf。","link":"/2024/08/07/cin-%E5%92%8Cgetline%E8%BF%98%E6%9C%89sacanf-%E8%BE%93%E5%85%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"title":"C++中cin的用法","text":"C++ 中 cin 的用法在 C++ 编程中，cin 是标准输入流对象，通常用于从标准输入设备（键盘）读取数据。cin 是标准输入流（std::cin）的一个实例，用于读取用户输入并将其存储到变量中。本文将详细介绍 cin 的用法，包括基本用法、常用操作和一些高级用法。 基本用法使用 cin 读取输入数据非常简单，通常使用提取运算符（&gt;&gt;）将数据从输入流提取到变量中： 1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;int main() { int a; double b; string c; cout &lt;&lt; &quot;请输入一个整数: &quot;; cin &gt;&gt; a; cout &lt;&lt; &quot;您输入的整数是: &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;请输入一个小数: &quot;; cin &gt;&gt; b; cout &lt;&lt; &quot;您输入的小数是: &quot; &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; &quot;请输入一个字符串: &quot;; cin &gt;&gt; c; cout &lt;&lt; &quot;您输入的字符串是: &quot; &lt;&lt; c &lt;&lt; endl; return 0;} 连续输入多个值可以在一行中连续输入多个值，中间用空格分隔： 123456789101112#include &lt;iostream&gt;using namespace std;int main() { int x, y; cout &lt;&lt; &quot;请输入两个整数: &quot;; cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; &quot;您输入的整数是: &quot; &lt;&lt; x &lt;&lt; &quot; 和 &quot; &lt;&lt; y &lt;&lt; endl; return 0;} 处理字符串输入使用 cin 读取字符串时，默认以空白字符（空格、制表符、换行符）作为分隔符。如果希望读取包含空格的整行字符串，可以使用 getline 函数： 1234567891011121314#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() { string line; cout &lt;&lt; &quot;请输入一行文本: &quot;; cin.ignore(); // 忽略之前输入流中的残留换行符 getline(cin, line); cout &lt;&lt; &quot;您输入的文本是: &quot; &lt;&lt; line &lt;&lt; endl; return 0;} 处理输入错误在读取输入时，可能会遇到输入错误的情况，例如输入类型不匹配。可以使用 cin.fail() 来检测输入错误，并采取适当的处理措施： 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;int main() { int num; cout &lt;&lt; &quot;请输入一个整数: &quot;; cin &gt;&gt; num; if (cin.fail()) { cout &lt;&lt; &quot;输入错误，请输入一个整数。&quot; &lt;&lt; endl; cin.clear(); // 清除错误标志 cin.ignore(numeric_limits&lt;streamsize&gt;::max(), '\\n'); // 忽略错误输入 } else { cout &lt;&lt; &quot;您输入的整数是: &quot; &lt;&lt; num &lt;&lt; endl; } return 0;} 忽略输入流中的字符有时候需要忽略输入流中的某些字符，可以使用 cin.ignore() 函数： 12345678910111213#include &lt;iostream&gt;using namespace std;int main() { char ch; cout &lt;&lt; &quot;请输入一个字符: &quot;; cin &gt;&gt; ch; cin.ignore(100, '\\n'); // 忽略输入流中的剩余字符，最多忽略100个，直到遇到换行符 cout &lt;&lt; &quot;您输入的字符是: &quot; &lt;&lt; ch &lt;&lt; endl; return 0;} 常用函数 cin.get(): 从输入流中读取一个字符。 cin.getline(): 从输入流中读取一行字符。 cin.peek(): 返回下一个输入字符，但不提取它。 cin.ignore(): 忽略输入流中的字符。 cin.clear(): 清除输入流的错误标志。 示例代码以下是一个综合示例，展示了 cin 的各种基本操作： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;limits&gt;using namespace std;int main() { int a; double b; string c; cout &lt;&lt; &quot;请输入一个整数: &quot;; cin &gt;&gt; a; if (cin.fail()) { cout &lt;&lt; &quot;输入错误，请输入一个整数。&quot; &lt;&lt; endl; cin.clear(); cin.ignore(numeric_limits&lt;streamsize&gt;::max(), '\\n'); } else { cout &lt;&lt; &quot;您输入的整数是: &quot; &lt;&lt; a &lt;&lt; endl; } cout &lt;&lt; &quot;请输入一个小数: &quot;; cin &gt;&gt; b; if (cin.fail()) { cout &lt;&lt; &quot;输入错误，请输入一个小数。&quot; &lt;&lt; endl; cin.clear(); cin.ignore(numeric_limits&lt;streamsize&gt;::max(), '\\n'); } else { cout &lt;&lt; &quot;您输入的小数是: &quot; &lt;&lt; b &lt;&lt; endl; } cout &lt;&lt; &quot;请输入一个字符串: &quot;; cin &gt;&gt; c; cout &lt;&lt; &quot;您输入的字符串是: &quot; &lt;&lt; c &lt;&lt; endl; cout &lt;&lt; &quot;请输入一行文本: &quot;; cin.ignore(); // 忽略之前输入流中的残留换行符 string line; getline(cin, line); cout &lt;&lt; &quot;您输入的文本是: &quot; &lt;&lt; line &lt;&lt; endl; return 0;} 结语cin 是 C++ 中进行输入操作的标准方式，通过合理使用 cin 提取运算符和相关函数，可以方便地读取各种类型的输入数据。在实际编程中，掌握 cin 的用法对于处理用户输入、进行交互式编程至关重要。","link":"/2024/08/08/C-%E4%B8%ADcin%E7%9A%84%E7%94%A8%E6%B3%95/"},{"title":"C++中repalace函数的用法","text":"C++ 中 replace 函数的用法在 C++ 编程中，replace 是一个非常有用的函数，它允许你在字符串或容器中替换某些元素或子字符串。本文将详细介绍 replace 函数的用法，包括在字符串和容器中的应用。 在字符串中使用 replace在 C++ 标准库中，std::string 类提供了一个成员函数 replace，用于替换字符串中的子字符串。 基本用法replace 函数有多种重载形式，以下是常见的用法： 123456789101112131415161718#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() { string str = &quot;Hello World&quot;; // 替换从索引 6 开始的 5 个字符为 &quot;Universe&quot; str.replace(6, 5, &quot;Universe&quot;); cout &lt;&lt; str &lt;&lt; endl; // 输出: Hello Universe // 替换从索引 6 开始的 8 个字符为 &quot;Everyone&quot; str.replace(6, 8, &quot;Everyone&quot;); cout &lt;&lt; str &lt;&lt; endl; // 输出: Hello Everyone return 0;} 参数说明 str.replace(pos, len, new_str); pos：要替换的子字符串的起始索引。 len：要替换的子字符串的长度。 new_str：用于替换的新字符串。 更多示例 替换子字符串： 1234567891011121314151617#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() { string str = &quot;C++ programming is fun&quot;; // 替换 &quot;fun&quot; 为 &quot;awesome&quot; size_t pos = str.find(&quot;fun&quot;); if (pos != string::npos) { str.replace(pos, 3, &quot;awesome&quot;); } cout &lt;&lt; str &lt;&lt; endl; // 输出: C++ programming is awesome return 0;} 替换字符串中的所有出现的子字符串： 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() { string str = &quot;foo bar foo baz foo&quot;; // 替换所有的 &quot;foo&quot; 为 &quot;qux&quot; string from = &quot;foo&quot;; string to = &quot;qux&quot;; size_t start_pos = 0; while ((start_pos = str.find(from, start_pos)) != string::npos) { str.replace(start_pos, from.length(), to); start_pos += to.length(); // 移动到下一个可能的位置 } cout &lt;&lt; str &lt;&lt; endl; // 输出: qux bar qux baz qux return 0;} 在容器中使用 replace在 C++ 标准模板库（STL）中，std::replace 是一个算法，用于在容器中替换某些元素。需要包含头文件 &lt;algorithm&gt;。 基本用法std::replace 的原型如下： 1void replace(ForwardIterator first, ForwardIterator last, const T&amp; old_value, const T&amp; new_value); first：容器的起始迭代器。 last：容器的结束迭代器。 old_value：要被替换的旧值。 new_value：替换后的新值。 示例代码1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main() { vector&lt;int&gt; vec = {1, 2, 3, 1, 2, 3}; // 将所有的 1 替换为 10 replace(vec.begin(), vec.end(), 1, 10); // 输出替换后的容器内容 for (int val : vec) { cout &lt;&lt; val &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; // 输出: 10 2 3 10 2 3 return 0;} 总结replace 函数在 C++ 中有多种用途，既可以用于字符串的替换，也可以用于容器元素的替换。通过灵活使用 replace 函数，可以方便地进行各种替换操作，提升代码的可读性和效率。希望这篇文章能够帮助你更好地理解和使用 replace 函数。","link":"/2024/08/08/C-%E4%B8%ADrepalace%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95/"},{"title":"vector的用法","text":"C++ 中 vector 的用法在C++编程中，vector 是一个非常重要且常用的容器。它是标准模板库（STL）的一部分，提供了动态数组的功能，可以根据需要自动调整其大小。本文将详细介绍 vector 的用法，包括其基本操作、常用方法以及一些高级用法。 什么是 vector？vector 是一个动态数组，它可以在运行时根据需要自动扩展或收缩。与普通数组不同，vector 的大小不是固定的。它提供了一些方便的函数来管理存储和访问元素。 引入 vector在使用 vector 之前，需要包含头文件 &lt;vector&gt;： 1#include &lt;vector&gt; 同时，为了方便使用标准库的功能，可以加入以下命名空间声明： 1using namespace std; 一、vector 的初始化可以有五种方式，举例如下： vector&lt;int&gt; a(10); 定义了 10 个整型元素的向量，但没有给出初值，其值是不确定的。 vector&lt;int&gt; a(10, 1); 定义了 10 个整型元素的向量，且给出每个元素的初值为 1。 vector&lt;int&gt; a(b); 用 b 向量来创建 a 向量，整体复制赋值。 vector&lt;int&gt; a(b.begin(), b.begin() + 3); 定义了 a 的值为 b 中第 0 个到第 2 个（共 3 个）元素。 从数组中获得初值： 12int b[7] = {1, 2, 3, 4, 5, 9, 8};vector&lt;int&gt; a(b, b + 7); 二、vector 对象的几个重要操作 a.assign(b.begin(), b.begin() + 3); 将 b 的 0 ~ 2 个元素构成的向量赋给 a。 a.assign(4, 2); 使 a 只含 4 个元素，且每个元素为 2。 a.back(); 返回 a 的最后一个元素。 a.front(); 返回 a 的第一个元素。 a[i]; 返回 a 的第 i 个元素，当且仅当 a[i] 存在。 a.clear(); 清空 a 中的元素。 a.empty(); 判断 a 是否为空，空则返回 true，不空则返回 false。 a.pop_back(); 删除 a 向量的最后一个元素。 a.erase(a.begin() + 1, a.begin() + 3); 删除 a 中第 1 个到第 2 个元素。 a.push_back(5); 在 a 的最后一个位置插入一个元素，值为 5。 a.insert(a.begin() + 1, 5); 在 a 的第 1 个位置插入数值 5。 a.insert(a.begin() + 1, 3, 5); 在 a 的第 1 个位置插入 3 个值为 5 的元素。 a.insert(a.begin() + 1, b + 3, b + 6); 在 a 的第 1 个位置插入 b 的第 3 个到第 5 个元素。 a.size(); 返回 a 中元素的个数。 a.capacity(); 返回 a 在内存中总共可以容纳的元素个数。 a.resize(10); 将 a 的现有元素个数调整至 10 个，多则删，少则补，其值随机。 a.resize(10, 2); 将 a 的现有元素个数调整至 10 个，多则删，少则补，其值为 2。 a.reserve(100); 将 a 的容量扩充至 100。 a.swap(b); 将 a 中的元素和 b 中的元素进行整体交换。 a == b; 比较两个向量是否相等，向量的比较操作还有 !=, &gt;=, &lt;=, &gt;, &lt;。 三、顺序访问 vector 的几种方式 向向量 a 中添加元素： 123vector&lt;int&gt; a;for (int i = 0; i &lt; 10; i++) a.push_back(i); 从数组中选择元素向向量中添加： 1234int a[6] = {1, 2, 3, 4, 5, 6};vector&lt;int&gt; b;for (int i = 1; i &lt;= 4; i++) b.push_back(a[i]); 从现有向量中选择元素向向量中添加： 12345int a[6] = {1, 2, 3, 4, 5, 6};vector&lt;int&gt; b;vector&lt;int&gt; c(a, a + 4);for (vector&lt;int&gt;::iterator it = c.begin(); it &lt; c.end(); it++) b.push_back(*it); 从文件中读取元素向向量中添加： 1234ifstream in(&quot;data.txt&quot;);vector&lt;int&gt; a;for (int i; in &gt;&gt; i;) a.push_back(i); 四、几种重要的算法使用时需要包含头文件 &lt;algorithm&gt;： sort(a.begin(), a.end()); 对 a 中的元素进行从小到大排列。 reverse(a.begin(), a.end()); 对 a 中的元素倒置，但不排序。 copy(a.begin(), a.end(), b.begin() + 1); 把 a 中的元素复制到 b 中，从 b.begin() + 1 的位置开始。 find(a.begin(), a.end(), 10); 在 a 中查找 10，若存在返回其在向量中的位置。 示例代码以下是一个综合示例，展示了 vector 的各种基本操作： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main() { // 创建和初始化vector vector&lt;int&gt; v = {1, 2, 3, 4}; // 访问和修改元素 cout &lt;&lt; &quot;第一个元素: &quot; &lt;&lt; v[0] &lt;&lt; endl; v[1] = 10; cout &lt;&lt; &quot;修改后的第二个元素: &quot; &lt;&lt; v.at(1) &lt;&lt; endl; // 添加和删除元素 v.push_back(5); v.insert(v.begin(), 0); v.erase(v.begin() + 2); v.pop_back(); // 遍历vector cout &lt;&lt; &quot;遍历vector: &quot;; for (int x : v) { cout &lt;&lt; x &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; // 使用常用的方法 cout &lt;&lt; &quot;vector的大小: &quot; &lt;&lt; v.size() &lt;&lt; endl; cout &lt;&lt; &quot;vector是否为空: &quot; &lt;&lt; (v.empty() ? &quot;是&quot; : &quot;否&quot;) &lt;&lt; endl; v.clear(); cout &lt;&lt; &quot;清空后vector的大小: &quot; &lt;&lt; v.size() &lt;&lt; endl; // 使用算法 vector&lt;int&gt; a = {4, 2, 3, 1}; sort(a.begin(), a.end()); cout &lt;&lt; &quot;排序后的vector: &quot;; for (int x : a) { cout &lt;&lt; x &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; reverse(a.begin(), a.end()); cout &lt;&lt; &quot;倒置后的vector: &quot;; for (int x : a) { cout &lt;&lt; x &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; return 0;} 结语vector 是 C++ 中非常强大的一个容器，它提供了动态数组的功能，能够方便地进行元素的添加、删除和访问。在实际编程中，vector 被广泛应用于各种场景，掌握 vector 的用法对提升 C++ 编程能力非常有帮助。希望这篇文章能够帮助你更好地理解和使用 vector。","link":"/2024/08/08/vector%E7%9A%84%E7%94%A8%E6%B3%95/"},{"title":"算法模拟题","text":"以下是一些经典的算法模拟题目，涵盖了不同类型的算法和数据结构问题，适合练习和提升编程能力： 1. 跳跃游戏（Jump Game）问题描述：给定一个非负整数数组 nums，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。 输入：nums = [2, 3, 1, 1, 4]输出：True解释：从位置 0 跳跃 1 步到达位置 1，然后从位置 1 跳跃 3 步到达最后一个位置。 2. 旋转排序数组的最小值（Find Minimum in Rotated Sorted Array）问题描述：假设按照升序排序的数组在预先未知的某个点进行了旋转（例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2]）。请找出数组中的最小元素。你可以假设数组中不存在重复元素。 输入：nums = [4, 5, 6, 7, 0, 1, 2]输出：0 3. 子集生成（Subsets Generation）问题描述：给定一个整数数组 nums，所有元素互不相同，求所有可能的子集（即幂集）。 输入：nums = [1, 2, 3]输出：[[], [1], [2], [1,2], [3], [1,3], [2,3], [1,2,3]] 4. 最长有效括号（Longest Valid Parentheses）问题描述：给定一个只包含字符 ‘(‘ 和 ‘)’ 的字符串，找出最长的有效（格式正确且连续）括号子串的长度。 输入：s = &quot;(()&quot;输出：2解释：最长有效括号子串为 &quot;()&quot;。 5. 岛屿数量（Number of Islands）问题描述：给定一个由 ‘1’（陆地）和 ‘0’（水）组成的二维网格，计算其中的岛屿数量。岛屿总是被水包围，并且每个岛屿只能由水平方向或垂直方向相邻的陆地连接形成。 输入： 12345678910111213141516171819202122232425262728293031grid = [ ['1', '1', '0', '0', '0'], ['1', '1', '0', '0', '0'], ['0', '0', '1', '0', '0'], ['0', '0', '0', '1', '1'] ] ``` **输出**：`3` **解释**：分别有三个岛屿。### 6. 无重复字符的最长子串（Longest Substring Without Repeating Characters）**问题描述**：给定一个字符串 `s`，请你找出其中不含有重复字符的最长子串的长度。**输入**：`s = &quot;abcabcbb&quot;` **输出**：`3` **解释**：答案是 `&quot;abc&quot;`，长度为 3。### 7. 编辑距离（Edit Distance）**问题描述**：给定两个单词 `word1` 和 `word2`，计算将 `word1` 转换为 `word2` 所使用的最少操作数。你可以对一个单词进行以下三种操作：插入一个字符、删除一个字符、替换一个字符。**输入**：`word1 = &quot;horse&quot;, word2 = &quot;ros&quot;` **输出**：`3` **解释**： 1. 将 &quot;horse&quot; 变为 &quot;rorse&quot; （替换 'h' 为 'r'） 2. 将 &quot;rorse&quot; 变为 &quot;rose&quot; （删除 'r'） 3. 将 &quot;rose&quot; 变为 &quot;ros&quot; （删除 'e'） ### 8. 最大矩形（Maximal Rectangle）**问题描述**：给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。**输入**： matrix = [ [‘1’, ‘0’, ‘1’, ‘0’, ‘0’], [‘1’, ‘0’, ‘1’, ‘1’, ‘1’], [‘1’, ‘1’, ‘1’, ‘1’, ‘1’], [‘1’, ‘0’, ‘0’, ‘1’, ‘0’]] **输出**：`6` **解释**：最大矩形包含 6 个 1。 ### 9. 字符串的全排列（Permutations of a String） **问题描述**：给定一个字符串 `s`，求出该字符串的所有可能的排列。 **输入**：`s = &quot;abc&quot;` **输出**：`[&quot;abc&quot;, &quot;acb&quot;, &quot;bac&quot;, &quot;bca&quot;, &quot;cab&quot;, &quot;cba&quot;]` ### 10. 零钱兑换（Coin Change） **问题描述**：给定不同面额的硬币和一个总金额，计算凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。 **输入**：`coins = [1, 2, 5], amount = 11` **输出**：`3` **解释**：11 = 5 + 5 + 1 这些问题涵盖了动态规划、回溯、贪心、图算法、字符串处理等不同类型的经典算法问题，非常适合用于面试准备和编程能力的提升。","link":"/2024/09/15/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%8B%9F%E9%A2%98/"},{"title":"c++ stl对应代码","text":"下面是每个题目对应的 C++ 代码，使用了 std 命名空间： 1. 基础题目：题目1：使用 std::vector 实现动态数组1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main() { vector&lt;int&gt; nums; int n, input; cout &lt;&lt; &quot;Enter the number of elements: &quot;; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { cout &lt;&lt; &quot;Enter a number: &quot;; cin &gt;&gt; input; nums.push_back(input); } sort(nums.begin(), nums.end()); cout &lt;&lt; &quot;Sorted numbers: &quot;; for (int num : nums) { cout &lt;&lt; num &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; return 0;} 题目2：使用 std::list 实现链表12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;list&gt;using namespace std;int main() { list&lt;int&gt; numbers; numbers.push_back(10); numbers.push_back(20); numbers.push_front(5); auto it = numbers.begin(); advance(it, 1); // 指向第二个元素 numbers.insert(it, 15); cout &lt;&lt; &quot;List elements: &quot;; for (int num : numbers) { cout &lt;&lt; num &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; numbers.erase(it); // 删除刚才插入的15 cout &lt;&lt; &quot;List after erasing an element: &quot;; for (int num : numbers) { cout &lt;&lt; num &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; return 0;} 题目3：使用 std::set 实现唯一元素集合1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;int main() { set&lt;int&gt; unique_numbers; int n, input; cout &lt;&lt; &quot;Enter the number of elements: &quot;; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { cout &lt;&lt; &quot;Enter a number: &quot;; cin &gt;&gt; input; unique_numbers.insert(input); // 自动去重 } cout &lt;&lt; &quot;Unique sorted numbers: &quot;; for (int num : unique_numbers) { cout &lt;&lt; num &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; return 0;} 题目4：使用 std::map 实现简单的词频统计1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;sstream&gt;using namespace std;int main() { map&lt;string, int&gt; word_count; string input, word; cout &lt;&lt; &quot;Enter a sentence: &quot;; getline(cin, input); stringstream ss(input); while (ss &gt;&gt; word) { word_count[word]++; } cout &lt;&lt; &quot;Word frequencies:&quot; &lt;&lt; endl; for (auto pair : word_count) { cout &lt;&lt; pair.first &lt;&lt; &quot;: &quot; &lt;&lt; pair.second &lt;&lt; endl; } return 0;} 2. 进阶题目：题目5：使用 std::priority_queue 实现任务调度123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;struct Task { string name; int priority; bool operator&lt;(const Task&amp; other) const { return priority &lt; other.priority; // 优先级高的任务排在队列前 }};int main() { priority_queue&lt;Task&gt; tasks; tasks.push({&quot;Task 1&quot;, 1}); tasks.push({&quot;Task 2&quot;, 5}); tasks.push({&quot;Task 3&quot;, 3}); while (!tasks.empty()) { Task t = tasks.top(); tasks.pop(); cout &lt;&lt; &quot;Executing &quot; &lt;&lt; t.name &lt;&lt; &quot; with priority &quot; &lt;&lt; t.priority &lt;&lt; endl; } return 0;} 题目6：用 std::stack 实现括号匹配12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;bool isValid(string s) { stack&lt;char&gt; st; for (char c : s) { if (c == '(' || c == '{' || c == '[') { st.push(c); } else { if (st.empty()) return false; if (c == ')' &amp;&amp; st.top() != '(') return false; if (c == '}' &amp;&amp; st.top() != '{') return false; if (c == ']' &amp;&amp; st.top() != '[') return false; st.pop(); } } return st.empty();}int main() { string s; cout &lt;&lt; &quot;Enter a string of brackets: &quot;; cin &gt;&gt; s; if (isValid(s)) { cout &lt;&lt; &quot;Valid&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;Invalid&quot; &lt;&lt; endl; } return 0;} 题目7：实现 LRU 缓存机制12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;unordered_map&gt;using namespace std;class LRUCache {private: int capacity; list&lt;pair&lt;int, int&gt;&gt; cacheList; unordered_map&lt;int, list&lt;pair&lt;int, int&gt;&gt;::iterator&gt; cacheMap;public: LRUCache(int cap) : capacity(cap) {} int get(int key) { if (cacheMap.find(key) == cacheMap.end()) return -1; auto it = cacheMap[key]; int value = it-&gt;second; cacheList.erase(it); cacheList.push_front({key, value}); cacheMap[key] = cacheList.begin(); return value; } void put(int key, int value) { if (cacheMap.find(key) != cacheMap.end()) { cacheList.erase(cacheMap[key]); } else if (cacheList.size() == capacity) { int oldKey = cacheList.back().first; cacheList.pop_back(); cacheMap.erase(oldKey); } cacheList.push_front({key, value}); cacheMap[key] = cacheList.begin(); }};int main() { LRUCache cache(2); // 缓存容量为2 cache.put(1, 1); cache.put(2, 2); cout &lt;&lt; cache.get(1) &lt;&lt; endl; // 返回1 cache.put(3, 3); // 移除键2 cout &lt;&lt; cache.get(2) &lt;&lt; endl; // 返回-1 cache.put(4, 4); // 移除键1 cout &lt;&lt; cache.get(1) &lt;&lt; endl; // 返回-1 cout &lt;&lt; cache.get(3) &lt;&lt; endl; // 返回3 cout &lt;&lt; cache.get(4) &lt;&lt; endl; // 返回4 return 0;} 3. 高级题目：题目8：使用 std::unordered_map 实现字典树（Trie）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;unordered_map&gt;using namespace std;class TrieNode {public: unordered_map&lt;char, TrieNode*&gt; children; bool isEndOfWord; TrieNode() : isEndOfWord(false) {}};class Trie {private: TrieNode* root;public: Trie() { root = new TrieNode(); } void insert(string word) { TrieNode* node = root; for (char c : word) { if (node-&gt;children.find(c) == node-&gt;children.end()) { node-&gt;children[c] = new TrieNode(); } node = node-&gt;children[c]; } node-&gt;isEndOfWord = true; } bool search(string prefix) { TrieNode* node = root; for (char c : prefix) { if (node-&gt;children.find(c) == node-&gt;children.end()) { return false; } node = node-&gt;children[c]; } return true; }};int main() { Trie trie; trie.insert(&quot;apple&quot;); trie.insert(&quot;app&quot;); cout &lt;&lt; trie.search(&quot;app&quot;) &lt;&lt; endl; // 返回 true cout &lt;&lt; trie.search(&quot;apple&quot;) &lt;&lt; endl; // 返回 true cout &lt;&lt; trie.search(&quot;appl&quot;) &lt;&lt; endl; // 返回 false return 0;} 题目9：基于 std::multimap 实现的多重映射123456789101112131415161718#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;int main() { multimap&lt;int, string&gt; students; students.insert({90, &quot;Alice&quot;}); students.insert({85, &quot;Bob&quot;}); students.insert({90, &quot;Charlie&quot;}); cout &lt;&lt; &quot;Students and their scores: &quot; &lt;&lt; endl; for (auto&amp; [score, name] : students) { cout &lt;&lt; name &lt;&lt; &quot; - &quot; &lt;&lt; score &lt;&lt; endl; } return 0;} 题目10：用 std::deque 实现滑动窗口最大值1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;deque&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) { deque&lt;int&gt; dq; vector&lt;int&gt; result; for (int i = 0; i &lt; nums.size(); ++i) { if (!dq.empty() &amp;&amp; dq.front() == i - k) { dq.pop_front(); } while (!dq.empty() &amp;&amp; nums[dq.back()] &lt; nums[i]) { dq.pop_back(); } dq.push_back(i); if (i &gt;= k - 1) { result.push_back(nums[dq.front()]); } } return result;}int main() { vector&lt;int&gt; nums = {1, 3, -1, -3, 5, 3, 6, 7}; int k = 3; vector&lt;int&gt; result = maxSlidingWindow(nums, k); cout &lt;&lt; &quot;Sliding window maximums: &quot;; for (int maxVal : result) { cout &lt;&lt; maxVal &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; return 0;} 这些代码覆盖了容器相关的基础和进阶问题，能帮助你更好地理解和运用 C++ 的标准模板库 (STL)。如果需要进一步解释某个题目或代码细节，可以随时讨论！","link":"/2024/09/20/c-stl%E5%AF%B9%E5%BA%94%E4%BB%A3%E7%A0%81/"},{"title":"c++stl相关","text":"以下是一些与容器相关的 C++ 题目，这些题目涵盖了标准模板库（STL）中的常用容器，如 vector、list、set、map 等，涉及容器的基本使用、遍历、操作以及高级特性。 1. 基础题目：题目1：使用 std::vector 实现动态数组编写一个函数，接受若干整数输入并存储在 std::vector 中，然后对该数组进行排序，并输出排序后的结果。 要求： 使用 std::vector 动态存储输入的整数。 使用 std::sort 对数组进行升序排序。 使用 for-each 循环输出结果。 题目2：使用 std::list 实现链表编写一个函数，使用 std::list 存储一系列整数，插入、删除某些特定位置的元素，并按从前向后的顺序输出链表中的所有元素。 要求： 使用 std::list 容器存储整数。 能够在链表头和尾插入数据，删除指定位置的数据。 遍历链表输出结果。 题目3：使用 std::set 实现唯一元素集合编写一个函数，接受一组整数输入，使用 std::set 来自动过滤掉重复的元素，并输出结果。 要求： 使用 std::set 存储输入的整数，自动去重。 按照升序顺序输出集合中的元素。 题目4：使用 std::map 实现简单的词频统计编写一个函数，接受一段字符串，使用 std::map 对字符串中的每个单词进行词频统计，并输出每个单词出现的次数。 要求： 使用 std::map 存储单词和它们出现的次数。 按照字母顺序输出单词及其词频。 2. 进阶题目：题目5：使用 std::priority_queue 实现任务调度编写一个任务调度器，任务具有不同的优先级，使用 std::priority_queue 对任务进行优先级调度，优先级高的任务先执行。 要求： 使用 std::priority_queue 存储任务，每个任务包含一个名称和一个优先级。 模拟任务的执行顺序，优先级高的任务先执行。 题目6：用 std::stack 实现括号匹配编写一个函数，检查给定的字符串中的括号是否成对匹配（即 {}, [], ()）。使用 std::stack 进行括号匹配。 要求： 使用 std::stack 来存储括号。 字符串中的括号类型有三种：()、[]、{}。 返回一个布尔值表示括号是否正确匹配。 题目7：实现 LRU 缓存机制编写一个 LRU（Least Recently Used）缓存类，使用 std::list 和 std::unordered_map 实现缓存替换算法。 要求： 缓存容量固定，当缓存容量超出时，移除最久未使用的数据。 实现 get(key) 和 put(key, value) 方法： get(key)：如果键存在，返回值；否则返回 -1。 put(key, value)：将键值对插入缓存，若键已存在则更新其值，否则插入新的键值对，当缓存超出容量时移除最少使用的键。 3. 高级题目：题目8：使用 std::unordered_map 实现字典树（Trie）编写一个字典树类，支持插入单词和查找单词前缀的操作，使用 std::unordered_map 作为字典树的节点数据结构。 要求： 实现 insert(word) 和 search(prefix) 方法： insert(word)：向字典树中插入一个单词。 search(prefix)：检查字典树中是否存在以给定前缀开头的单词。 题目9：基于 std::multimap 实现的多重映射编写一个学生信息管理系统，使用 std::multimap 存储多个学生的姓名和成绩，并按分数排序输出学生信息。 要求： 使用 std::multimap 存储多个学生的姓名和成绩（允许分数相同的学生）。 能够按升序输出所有学生的姓名和成绩。 题目10：用 std::deque 实现滑动窗口最大值给定一个整数数组 nums 和一个滑动窗口大小 k，请找出所有滑动窗口中的最大值。使用 std::deque 实现。 要求： 滑动窗口大小为 k，每次窗口右移一位。 使用 std::deque 维护滑动窗口中的最大值。 输出所有窗口的最大值。 这些题目能够帮助你熟悉和掌握 C++ STL 容器的基本使用及其常见的操作方式，并且涉及一些经典的算法和数据结构问题。如果需要更详细的解题思路或进一步的解释，随时可以讨论！","link":"/2024/09/20/c-stl%E7%9B%B8%E5%85%B3/"},{"title":"C++处理字符串","text":"以下是一些关于C++字符串处理的题目，可以帮助你练习和提高字符串处理的能力。这些题目涵盖了不同的难度层次，包括基本操作、高级操作和算法实现。 基础题目 字符串长度编写一个函数，输入一个字符串，输出其长度。 字符串反转编写一个函数，输入一个字符串，输出其反转后的字符串。示例： 12输入: &quot;hello&quot;输出: &quot;olleh&quot; 字符串比较编写一个函数，比较两个字符串是否相等。要求不得使用C++自带的字符串比较函数。示例： 12输入: &quot;abc&quot;, &quot;abc&quot;输出: true 统计字符串中的字符个数编写一个程序，输入一个字符串，统计并输出每个字符出现的次数。示例： 12输入: &quot;hello&quot;输出: h:1, e:1, l:2, o:1 大写字母转小写编写一个函数，输入一个字符串，将其中的大写字母转换为小写字母。示例： 12输入: &quot;HeLLo&quot;输出: &quot;hello&quot; 进阶题目 查找子串编写一个函数，判断一个字符串是否包含另一个子串，若包含，返回子串在主串中的起始位置；否则返回 -1。示例： 12输入: &quot;hello&quot;, &quot;ll&quot;输出: 2 字符串旋转编写一个函数，将字符串中的字符按给定步数进行循环右移。示例： 12输入: &quot;abcdef&quot;, 2输出: &quot;efabcd&quot; 统计单词数量编写一个函数，统计一个字符串中单词的个数。假设单词之间用空格隔开。示例： 12输入: &quot;hello world, how are you&quot;输出: 5 删除特定字符编写一个程序，输入一个字符串，删除指定的字符。示例： 12输入: &quot;hello world&quot;, 'l'输出: &quot;heo word&quot; 回文判断编写一个函数，判断输入的字符串是否为回文字符串（正读和反读相同）。示例： 12输入: &quot;madam&quot;输出: true 算法题目 最长公共前缀编写一个函数，输入一个字符串数组，返回数组中字符串的最长公共前缀。示例： 12输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]输出: &quot;fl&quot; 字符串压缩编写一个程序，将字符串中连续重复出现的字符用该字符加出现次数来压缩。示例： 12输入: &quot;aabcccccaaa&quot;输出: &quot;a2b1c5a3&quot; 最长不重复子串编写一个函数，找到一个字符串中最长的不含重复字符的子串，并返回其长度。示例： 12输入: &quot;abcabcbb&quot;输出: 3 (&quot;abc&quot;) 字符串排列编写一个函数，打印输入字符串的所有排列组合。示例： 12输入: &quot;abc&quot;输出: &quot;abc&quot;, &quot;acb&quot;, &quot;bac&quot;, &quot;bca&quot;, &quot;cab&quot;, &quot;cba&quot; 字符串中的第一个唯一字符编写一个程序，找到字符串中第一个不重复的字符，并返回它的索引。如果不存在，返回 -1。示例： 12输入: &quot;leetcode&quot;输出: 0 这些题目可以帮助你从基础到进阶全面掌握C++字符串处理的技能。你可以根据自己的掌握情况，从简单到复杂依次进行练习。","link":"/2024/09/24/C-%E5%A4%84%E7%90%86%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"title":"处理字符串对应的代码","text":"好的！下面是对每道题目的C++代码实现，帮助你练习和理解字符串的操作。 1. 字符串长度1234567891011#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() { string str; cout &lt;&lt; &quot;请输入字符串: &quot;; getline(cin, str); cout &lt;&lt; &quot;字符串长度为: &quot; &lt;&lt; str.length() &lt;&lt; endl; return 0;} 2. 字符串反转12345678910111213#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;int main() { string str; cout &lt;&lt; &quot;请输入字符串: &quot;; getline(cin, str); reverse(str.begin(), str.end()); cout &lt;&lt; &quot;反转后的字符串: &quot; &lt;&lt; str &lt;&lt; endl; return 0;} 3. 字符串比较123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;bool compareStrings(string str1, string str2) { if (str1.length() != str2.length()) return false; for (int i = 0; i &lt; str1.length(); i++) { if (str1[i] != str2[i]) return false; } return true;}int main() { string str1, str2; cout &lt;&lt; &quot;请输入第一个字符串: &quot;; getline(cin, str1); cout &lt;&lt; &quot;请输入第二个字符串: &quot;; getline(cin, str2); if (compareStrings(str1, str2)) cout &lt;&lt; &quot;两个字符串相等&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;两个字符串不相等&quot; &lt;&lt; endl; return 0;} 4. 统计字符串中的字符个数1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;string&gt;using namespace std;int main() { string str; cout &lt;&lt; &quot;请输入字符串: &quot;; getline(cin, str); map&lt;char, int&gt; charCount; for (char ch : str) { charCount[ch]++; } for (auto &amp;pair : charCount) { cout &lt;&lt; pair.first &lt;&lt; &quot;: &quot; &lt;&lt; pair.second &lt;&lt; endl; } return 0;} 5. 大写字母转小写12345678910111213#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;int main() { string str; cout &lt;&lt; &quot;请输入字符串: &quot;; getline(cin, str); transform(str.begin(), str.end(), str.begin(), ::tolower); cout &lt;&lt; &quot;转换后的字符串: &quot; &lt;&lt; str &lt;&lt; endl; return 0;} 6. 查找子串12345678910111213141516171819#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() { string str, substr; cout &lt;&lt; &quot;请输入主字符串: &quot;; getline(cin, str); cout &lt;&lt; &quot;请输入子字符串: &quot;; getline(cin, substr); int pos = str.find(substr); if (pos != string::npos) { cout &lt;&lt; &quot;子串起始位置: &quot; &lt;&lt; pos &lt;&lt; endl; } else { cout &lt;&lt; &quot;子串未找到&quot; &lt;&lt; endl; } return 0;} 7. 字符串旋转123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;string rotateString(string str, int steps) { int n = str.length(); steps = steps % n; return str.substr(n - steps) + str.substr(0, n - steps);}int main() { string str; int steps; cout &lt;&lt; &quot;请输入字符串: &quot;; getline(cin, str); cout &lt;&lt; &quot;请输入右移步数: &quot;; cin &gt;&gt; steps; cout &lt;&lt; &quot;旋转后的字符串: &quot; &lt;&lt; rotateString(str, steps) &lt;&lt; endl; return 0;} 8. 统计单词数量123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;sstream&gt;using namespace std;int main() { string str; cout &lt;&lt; &quot;请输入一句话: &quot;; getline(cin, str); stringstream ss(str); string word; int count = 0; while (ss &gt;&gt; word) { count++; } cout &lt;&lt; &quot;单词数量: &quot; &lt;&lt; count &lt;&lt; endl; return 0;} 9. 删除特定字符1234567891011121314151617#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() { string str; char ch; cout &lt;&lt; &quot;请输入字符串: &quot;; getline(cin, str); cout &lt;&lt; &quot;请输入要删除的字符: &quot;; cin &gt;&gt; ch; str.erase(remove(str.begin(), str.end(), ch), str.end()); cout &lt;&lt; &quot;删除后的字符串: &quot; &lt;&lt; str &lt;&lt; endl; return 0;} 10. 回文判断1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;bool isPalindrome(string str) { int i = 0, j = str.length() - 1; while (i &lt; j) { if (str[i] != str[j]) return false; i++; j--; } return true;}int main() { string str; cout &lt;&lt; &quot;请输入字符串: &quot;; getline(cin, str); if (isPalindrome(str)) { cout &lt;&lt; &quot;是回文字符串&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;不是回文字符串&quot; &lt;&lt; endl; } return 0;} 11. 最长公共前缀1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;string longestCommonPrefix(vector&lt;string&gt;&amp; strs) { if (strs.empty()) return &quot;&quot;; string prefix = strs[0]; for (int i = 1; i &lt; strs.size(); i++) { while (strs[i].find(prefix) != 0) { prefix = prefix.substr(0, prefix.length() - 1); if (prefix.empty()) return &quot;&quot;; } } return prefix;}int main() { vector&lt;string&gt; strs = {&quot;flower&quot;, &quot;flow&quot;, &quot;flight&quot;}; cout &lt;&lt; &quot;最长公共前缀为: &quot; &lt;&lt; longestCommonPrefix(strs) &lt;&lt; endl; return 0;} 12. 字符串压缩12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;string compressString(string str) { string result = &quot;&quot;; int count = 1; for (int i = 1; i &lt;= str.length(); i++) { if (i &lt; str.length() &amp;&amp; str[i] == str[i-1]) { count++; } else { result += str[i-1]; result += to_string(count); count = 1; } } return result.length() &lt; str.length() ? result : str;}int main() { string str; cout &lt;&lt; &quot;请输入字符串: &quot;; getline(cin, str); cout &lt;&lt; &quot;压缩后的字符串: &quot; &lt;&lt; compressString(str) &lt;&lt; endl; return 0;} 13. 最长不重复子串12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;unordered_map&gt;using namespace std;int lengthOfLongestSubstring(string str) { unordered_map&lt;char, int&gt; charIndex; int maxLength = 0, start = 0; for (int i = 0; i &lt; str.length(); i++) { if (charIndex.find(str[i]) != charIndex.end() &amp;&amp; charIndex[str[i]] &gt;= start) { start = charIndex[str[i]] + 1; } charIndex[str[i]] = i; maxLength = max(maxLength, i - start + 1); } return maxLength;}int main() { string str; cout &lt;&lt; &quot;请输入字符串: &quot;; getline(cin, str); cout &lt;&lt; &quot;最长不重复子串的长度: &quot; &lt;&lt; lengthOfLongestSubstring(str) &lt;&lt; endl; return 0;} 14. 字符串排列12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;void permute(string str, int l, int r) { if (l == r) cout &lt;&lt; str &lt;&lt; endl; else { for (int i = l; i &lt;= r; i++) { swap(str[l], str[i]); permute(str, l + 1, r); swap(str[l], str[i]); // 回溯 } }}int main() { string str; cout &lt;&lt; &quot;请输入字符串: &quot;; getline(cin, str); permute(str, 0, str.length() - 1); return 0;} 15. 字符串中的第一个唯一字符1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;unordered_map&gt;#include &lt;string&gt;using namespace std;int firstUniqueChar(string str) { unordered_map&lt;char, int&gt; charCount; for (char ch : str) { charCount[ch]++; } for (int i = 0; i &lt; str.length(); i++) { if (charCount[str[i]] == 1) { return i; } } return -1;}int main() { string str; cout &lt;&lt; &quot;请输入字符串: &quot;; getline(cin, str); int index = firstUniqueChar(str); if (index != -1) cout &lt;&lt; &quot;第一个唯一字符的索引是: &quot; &lt;&lt; index &lt;&lt; endl; else cout &lt;&lt; &quot;没有唯一字符&quot; &lt;&lt; endl; return 0;}","link":"/2024/09/24/%E5%A4%84%E7%90%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E5%BA%94%E7%9A%84%E4%BB%A3%E7%A0%81/"},{"title":"transformer","text":"假设我们有以下句子：“我去东北大学。” 在这个句子中，我们想要理解“去”这个动作与句子中其他部分的关系。在注意力机制中，我们通常会为句子中的每个单词生成q、k、v向量。 查询向量（q）：这是当前单词的表示，用于查询其他单词的相关性。如果我们正在处理“去”这个单词，那么“去”的嵌入向量就是q。 键向量（k）：这是其他单词的表示，用于与q进行比较，以确定它们与当前单词的相关性。在这个例子中，我们可以为“东北大学”生成一个k向量。 值向量（v）：这是其他单词的表示，用于在确定了相关性之后提供信息。同样地，“东北大学”的嵌入向量可以是v。 现在，让我们通过一个具体的例子来理解这个过程： 假设我们有以下简化的向量表示： “去”的q向量：[0.2, 0.3, 0.5] “东北大学”的k向量：[0.1, 0.4, 0.5] “东北大学”的v向量：[0.5, 0.2, 0.3] 注意力机制通过计算q和k之间的相似度来工作。一种常见的方法是使用点积来计算相似度，然后通过softmax函数进行归一化，得到一个注意力分数： [ \\text{Attention}(q, k) = \\text{softmax}\\left(\\frac{q \\cdot k^T}{\\sqrt{d_k}}\\right) ] 其中 (d_k) 是k向量的维度。 对于我们的例子： [ \\text{Attention}([0.2, 0.3, 0.5], [0.1, 0.4, 0.5]) = \\text{softmax}\\left(\\frac{0.20.1 + 0.30.4 + 0.5*0.5}{\\sqrt{3}}\\right) ] 计算这个值，我们得到一个注意力分数，这个分数告诉我们“去”与“东北大学”的相关性有多强。 最后，我们使用这个注意力分数来加权v向量，以得到最终的输出： [ \\text{Output} = \\text{Attention} \\cdot v ] 在这个例子中，输出将是一个加权的“东北大学”的表示，这个表示考虑了“去”与“东北大学”之间的关系。 通过这种方式，注意力机制允许模型动态地关注输入序列的不同部分，这对于理解句子的语义非常有帮助。 在Transformer的注意力机制中，Q（Query）、K（Key）和V（Value）的生成并不是直接与特定的单词一一对应的，而是通过将输入序列中的所有词向量（如嵌入表示）通过线性变换映射得到的。 但如果我们尝试从理解注意力机制的角度，对这句话进行编码，并假设 “去” 是 Q（Query） 的一部分，那么我们可以试着解释一下在这种上下文中的 K 和 V 分别代表什么。 假设： Q（Query） 是“去”，代表我们要寻找与动作“去”相关的信息。 K（Key） 是每个词的“键值”，用于帮助找到相关的上下文信息，与查询Q进行比较，用来决定哪些词是重要的。 V（Value） 是每个词对应的信息“值”，这些值通过注意力机制中的权重加权后，决定最终输出的表示。 在 “我去东北大学” 这句话中，假设“去”是我们的 Query，可以这样推测： K（Key）： 每个词都被映射为K，包括“我”、“去”、“东北大学”。Key代表这些词的特征向量，它们会与Q（“去”）做点积运算，计算每个词与“去”的相关性。 在这种情况下，可能“东北大学”的Key会与“去”的Query更加相关，因为“东北大学”是地点，与“去”的动作密切相关。 V（Value）： 每个词都有一个对应的Value（值），这些值携带了词本身的信息。 通过注意力机制，Key和Query的相似度（相关性）会被用于加权各个词的Value。假如“东北大学”的Key与“去”的Query有较高的相似度，那么它的Value（“东北大学”的语义信息）会得到较高的权重，进而在最后的输出中起到较大的作用。 小结： Q（Query）：我们希望找到与动作“去”相关的信息（“去”对应的查询向量）。 K（Key）：每个词的Key（包括“我”、“去”、“东北大学”），用于与Query（“去”）比较，计算相关性。 V（Value）：每个词的Value，携带词的语义信息，最终通过注意力权重来决定哪些词对输出的影响较大。 在这种简单的解释下，“去”作为Query会关注“东北大学”这个地点，因此在注意力机制中，模型可能会给“东北大学”的Key较高的权重，并从它的Value中提取出与“去”动作最相关的信息。","link":"/2024/09/29/transformer/"},{"title":"transformer中位置编码的计算方法","text":"在 Transformer 模型中，位置编码（Positional Encoding, PE）是通过正弦和余弦函数生成的。它为输入的每个位置添加位置信息，确保模型能够利用序列的位置信息。这个过程在原始论文 Attention is All You Need 中的公式如下： [PE_{(pos, 2i)} = \\sin\\left(\\frac{pos}{10000^{\\frac{2i}{d_{\\text{model}}}}}\\right)][PE_{(pos, 2i+1)} = \\cos\\left(\\frac{pos}{10000^{\\frac{2i}{d_{\\text{model}}}}}\\right)]其中： ( pos ) 表示词的位置。 ( i ) 是嵌入维度的索引。 ( d_{\\text{model}} ) 是词嵌入的维度。 奇数索引的位置使用正弦函数，偶数索引的位置使用余弦函数。 具体步骤 确定维度和序列位置：假设我们有一个嵌入维度 ( d_{\\text{model}} = 4 )（简化，实际中通常是 512），输入句子长度为 5（例如，英文句子有5个词）。我们需要计算每个位置的向量，并为每个维度使用上述公式生成正弦和余弦值。 按照公式计算位置编码：我们需要分别计算每个位置 ( pos ) 和每个维度 ( i ) 上的正弦和余弦值。 示例：假设 ( d_{\\text{model}} = 4 )，序列长度为 5。 对于每个位置 ( pos = 0, 1, 2, 3, 4 )，计算它在每个维度 ( i ) 上的编码。 计算公式细化对嵌入维度 ( d_{\\text{model}} = 4 )： 偶数位置 ( 2i )：使用正弦函数 ( \\sin ) 奇数位置 ( 2i+1 )：使用余弦函数 ( \\cos ) 我们来逐个计算每个位置 ( pos = 0, 1, 2, 3, 4 ) 的位置编码。 3. 具体计算对于 ( pos = 0 )：[PE_{(0, 0)} = \\sin\\left(\\frac{0}{10000^{\\frac{0}{4}}}\\right) = \\sin(0) = 0][PE_{(0, 1)} = \\cos\\left(\\frac{0}{10000^{\\frac{0}{4}}}\\right) = \\cos(0) = 1][PE_{(0, 2)} = \\sin\\left(\\frac{0}{10000^{\\frac{2}{4}}}\\right) = \\sin(0) = 0][PE_{(0, 3)} = \\cos\\left(\\frac{0}{10000^{\\frac{2}{4}}}\\right) = \\cos(0) = 1] 因此，位置 ( pos = 0 ) 的位置编码向量为：[[0, 1, 0, 1]] 对于 ( pos = 1 )：[PE_{(1, 0)} = \\sin\\left(\\frac{1}{10000^{\\frac{0}{4}}}\\right) = \\sin(1)][PE_{(1, 1)} = \\cos\\left(\\frac{1}{10000^{\\frac{0}{4}}}\\right) = \\cos(1)][PE_{(1, 2)} = \\sin\\left(\\frac{1}{10000^{\\frac{2}{4}}}\\right) = \\sin\\left(\\frac{1}{100}\\right)][PE_{(1, 3)} = \\cos\\left(\\frac{1}{10000^{\\frac{2}{4}}}\\right) = \\cos\\left(\\frac{1}{100}\\right)] 对于 ( pos = 1 ) 的具体数值：[\\sin(1) \\approx 0.8415, \\quad \\cos(1) \\approx 0.5403][\\sin\\left(\\frac{1}{100}\\right) \\approx 0.01, \\quad \\cos\\left(\\frac{1}{100}\\right) \\approx 0.99995] 因此，位置 ( pos = 1 ) 的位置编码向量为：[[0.8415, 0.5403, 0.01, 0.99995]] 对于 ( pos = 2 )：[PE_{(2, 0)} = \\sin\\left(\\frac{2}{10000^{\\frac{0}{4}}}\\right) = \\sin(2)][PE_{(2, 1)} = \\cos\\left(\\frac{2}{10000^{\\frac{0}{4}}}\\right) = \\cos(2)][PE_{(2, 2)} = \\sin\\left(\\frac{2}{10000^{\\frac{2}{4}}}\\right) = \\sin\\left(\\frac{2}{100}\\right)][PE_{(2, 3)} = \\cos\\left(\\frac{2}{10000^{\\frac{2}{4}}}\\right) = \\cos\\left(\\frac{2}{100}\\right)] 对于 ( pos = 2 ) 的具体数值：[\\sin(2) \\approx 0.9093, \\quad \\cos(2) \\approx -0.4161][\\sin\\left(\\frac{2}{100}\\right) \\approx 0.02, \\quad \\cos\\left(\\frac{2}{100}\\right) \\approx 0.9998] 因此，位置 ( pos = 2 ) 的位置编码向量为：[[0.9093, -0.4161, 0.02, 0.9998]] 对于 ( pos = 3 )：[PE_{(3, 0)} = \\sin\\left(\\frac{3}{10000^{\\frac{0}{4}}}\\right) = \\sin(3)][PE_{(3, 1)} = \\cos\\left(\\frac{3}{10000^{\\frac{0}{4}}}\\right) = \\cos(3)][PE_{(3, 2)} = \\sin\\left(\\frac{3}{10000^{\\frac{2}{4}}}\\right) = \\sin\\left(\\frac{3}{100}\\right)][PE_{(3, 3)} = \\cos\\left(\\frac{3}{10000^{\\frac{2}{4}}}\\right) = \\cos\\left(\\frac{3}{100}\\right)] 对于 ( pos = 3 ) 的具体数值：[\\sin(3) \\approx 0.1411, \\quad \\cos(3) \\approx -0.9899][\\sin\\left(\\frac{3}{100}\\right) \\approx 0.03, \\quad \\cos\\left(\\frac{3}{100}\\right) \\approx 0.99955] 因此，位置 ( pos = 3 ) 的位置编码向量为：[[0.1411, -0.9899, 0.03, 0.99955]] 对于 ( pos = 4 )：[PE_{(4, 0)} = \\sin\\left(\\frac{4}{10000^{\\frac{0}{4}}}\\right) = \\sin(4)][PE_{(4, 1)} = \\cos\\left(\\frac{4}{10000^{\\frac{0}{4}}}\\right) = \\cos(4)][PE_{(4, 2)} = \\sin\\left(\\frac{4}{10000^{\\frac{2}{4}}}\\right) = \\sin\\left(\\frac{4}{100}\\right)][PE_{(4, 3)} = \\cos\\left(\\frac{4}{10000^{\\frac{2}{4}}}\\right) = \\cos\\left(\\frac{4}{100}\\right)] 对于 ( pos = 4 ) 的具体数值：[\\sin(4) \\approx -0.7568, \\quad \\cos(4) \\approx -0.6536][\\sin\\left(\\frac{4}{100}\\right) \\approx 0.04, \\quad \\cos\\left(\\frac{4}{100}\\right) \\approx 0.9992] 因此，位置 ( pos = 4 ) 的位置编码向量为：[[-0.7568, -0.6536, 0.04, 0.9992]] 4. 总结最终，对于一个 5 个词组成的句子，其位置编码矩阵为：[PE = \\begin{bmatrix}0 &amp; 1 &amp; 0 &amp; 1 \\0.8415 &amp; 0.5403 &amp; 0.01 &amp; 0.99995 \\0.9093 &amp; -0.4161 &amp; 0.02 &amp; 0.9998 \\0.1411 &amp; -0.9899 &amp; 0.03 &amp; 0.99955 \\-0.7568 &amp; -0.6536 &amp; 0.04 &amp; 0.9992\\end{bmatrix}] 这个位置编码矩阵将与词嵌入矩阵相加，注入位置信息后用于 Transformer 的输入。","link":"/2024/09/30/transformer%E4%B8%AD%E4%BD%8D%E7%BD%AE%E7%BC%96%E7%A0%81%E7%9A%84%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/"},{"title":"transformer具体计算","text":"为了详细说明 Transformer 模型在机器翻译中的向量计算过程，我们将从输入的英文句子 “I went to Northeastern University” 和对应的中文标注 “我去东北大学” 入手，介绍从词嵌入、注意力计算、解码器中的多头注意力到最终生成的详细步骤。为了让具体过程更具可操作性，我将向量的维度和数量缩小化，以便说明整个过程。 1. 词嵌入（Embedding）假设我们的模型使用了词嵌入向量的维度 ( d_{\\text{model}} = 4 )（简化，实际中通常是 512 或 1024），句子中的每个词通过嵌入层映射为长度为 4 的向量。以下是简化的词嵌入向量（这些向量在实际中是通过预训练或模型学习得到的）： 英文句子： “I”: ( \\mathbf{E}_{I} = [0.1, 0.3, 0.2, 0.4] ) “went”: ( \\mathbf{E}_{went} = [0.5, 0.6, 0.7, 0.8] ) “to”: ( \\mathbf{E}_{to} = [0.9, 0.1, 0.3, 0.5] ) “Northeastern”: ( \\mathbf{E}_{Northeastern} = [0.2, 0.4, 0.6, 0.8] ) “University”: ( \\mathbf{E}_{University} = [0.3, 0.2, 0.1, 0.5] ) 这些向量组合成一个矩阵，表示整个句子的嵌入表示：[\\mathbf{E}_{\\text{英}} = \\begin{bmatrix}0.1 &amp; 0.3 &amp; 0.2 &amp; 0.4 \\0.5 &amp; 0.6 &amp; 0.7 &amp; 0.8 \\0.9 &amp; 0.1 &amp; 0.3 &amp; 0.5 \\0.2 &amp; 0.4 &amp; 0.6 &amp; 0.8 \\0.3 &amp; 0.2 &amp; 0.1 &amp; 0.5\\end{bmatrix}]维度：(5 \\times 4) (5个词，每个词的嵌入维度是4) 中文句子： “我”: ( \\mathbf{E}_{我} = [0.3, 0.1, 0.2, 0.5] ) “去”: ( \\mathbf{E}_{去} = [0.6, 0.3, 0.4, 0.7] ) “东北大学”: ( \\mathbf{E}_{东北大学} = [0.8, 0.5, 0.6, 0.9] ) 中文句子嵌入为：[\\mathbf{E}_{\\text{中}} = \\begin{bmatrix}0.3 &amp; 0.1 &amp; 0.2 &amp; 0.5 \\0.6 &amp; 0.3 &amp; 0.4 &amp; 0.7 \\0.8 &amp; 0.5 &amp; 0.6 &amp; 0.9\\end{bmatrix}]维度：(3 \\times 4) (3个词，每个词的嵌入维度是4) 2. 位置编码（Positional Encoding）为了注入序列信息，加入位置编码（Positional Encoding）。假设我们的位置编码矩阵如下： 对于5个英文词：[\\mathbf{P}_{\\text{英}} = \\begin{bmatrix}0.1 &amp; 0.2 &amp; 0.3 &amp; 0.4 \\0.2 &amp; 0.3 &amp; 0.4 &amp; 0.5 \\0.3 &amp; 0.4 &amp; 0.5 &amp; 0.6 \\0.4 &amp; 0.5 &amp; 0.6 &amp; 0.7 \\0.5 &amp; 0.6 &amp; 0.7 &amp; 0.8\\end{bmatrix}] 对于3个中文词：[\\mathbf{P}_{\\text{中}} = \\begin{bmatrix}0.1 &amp; 0.2 &amp; 0.3 &amp; 0.4 \\0.2 &amp; 0.3 &amp; 0.4 &amp; 0.5 \\0.3 &amp; 0.4 &amp; 0.5 &amp; 0.6\\end{bmatrix}] 经过位置编码后，最终的输入是词嵌入向量与位置编码的逐元素相加： 英文向量 + 位置编码：[\\mathbf{E}{\\text{英}} + \\mathbf{P}{\\text{英}} = \\begin{bmatrix}0.1+0.1 &amp; 0.3+0.2 &amp; 0.2+0.3 &amp; 0.4+0.4 \\0.5+0.2 &amp; 0.6+0.3 &amp; 0.7+0.4 &amp; 0.8+0.5 \\0.9+0.3 &amp; 0.1+0.4 &amp; 0.3+0.5 &amp; 0.5+0.6 \\0.2+0.4 &amp; 0.4+0.5 &amp; 0.6+0.6 &amp; 0.8+0.7 \\0.3+0.5 &amp; 0.2+0.6 &amp; 0.1+0.7 &amp; 0.5+0.8\\end{bmatrix} = \\begin{bmatrix}0.2 &amp; 0.5 &amp; 0.5 &amp; 0.8 \\0.7 &amp; 0.9 &amp; 1.1 &amp; 1.3 \\1.2 &amp; 0.5 &amp; 0.8 &amp; 1.1 \\0.6 &amp; 0.9 &amp; 1.2 &amp; 1.5 \\0.8 &amp; 0.8 &amp; 0.8 &amp; 1.3\\end{bmatrix}] 中文向量 + 位置编码：[\\mathbf{E}{\\text{中}} + \\mathbf{P}{\\text{中}} = \\begin{bmatrix}0.3+0.1 &amp; 0.1+0.2 &amp; 0.2+0.3 &amp; 0.5+0.4 \\0.6+0.2 &amp; 0.3+0.3 &amp; 0.4+0.4 &amp; 0.7+0.5 \\0.8+0.3 &amp; 0.5+0.4 &amp; 0.6+0.5 &amp; 0.9+0.6\\end{bmatrix} = \\begin{bmatrix}0.4 &amp; 0.3 &amp; 0.5 &amp; 0.9 \\0.8 &amp; 0.6 &amp; 0.8 &amp; 1.2 \\1.1 &amp; 0.9 &amp; 1.1 &amp; 1.5\\end{bmatrix}] 3. 编码器的多头自注意力机制进入 编码器，每个词的向量会分别通过三个线性变换得到 Query (Q)、Key (K) 和 Value (V) 向量。假设每个向量的维度仍然是 4。 例如，对于“went”这个词，假设我们通过线性变换矩阵 ( W_Q )、( W_K )、( W_V ) 生成 Q, K, V： [Q_{\\text{went}} = W_Q \\cdot \\mathbf{E}{went}, \\quad K{\\text{went}} = W_K \\cdot \\mathbf{E}{went}, \\quad V{\\text{went}} = W_V \\cdot \\mathbf{E}_{went}] 假设 ( W_Q ), ( W_K ), ( W_V ) 的维度为 ( 4 \\times 4 )，比如：[W_Q = \\begin{bmatrix}0.2 &amp; 0.1 &amp; 0.3 &amp; 0.5 \\0.6 &amp; 0.4 &amp; 0.1 &amp; 0.7 \\0.3 &amp; 0.8 &amp; 0.2 &amp; 0.4 \\0.5 &amp; 0.9 &amp; 0.6 &amp; 0.1\\end{bmatrix}] 那么：[Q_{\\text{went}} = W_Q \\cdot [0.7, 0.9, 1.1, 1.3] = \\begin{bmatrix} 0.2 &amp; 0.1 &amp; 0.3 &amp; 0.5 \\ 0.6 &amp; 0.4 &amp; 0.1 &amp; 0.7 \\ 0.3 &amp; 0.8 &amp; 0.2 &amp; 0.4 \\ 0.5 &amp; 0.9 &amp; 0.6 &amp; 0.1 \\end{bmatrix} \\cdot \\begin{bmatrix} 0.7 \\ 0.9 \\ 1.1 \\ 1.3 \\end{bmatrix} = \\begin{bmatrix} 1.27 \\ 1.84 \\ 1.51 \\ 1.61 \\end{bmatrix}] 通过类似的过程，可以计算出所有词的 Q, K, V。 4. 注意力计算对于每个词，计算 Q 与所有其他词的 K 进行点积，生成注意力权重矩阵。然后用这些权重对 V 进行加权求和。 假设对于“went”，与其他词的 K 点积计算如下：[\\text{Attention}{went} = \\frac{Q{\\text{went}} \\cdot K_{\\text{其他词}}}{\\sqrt{d_k}}] 具体注意力计算可以按照这个过程逐步实现。 整个过程需要多次矩阵乘法与注意力加权，最终解码器生成的词汇是基于这些计算生成的。","link":"/2024/09/30/transformer%E5%85%B7%E4%BD%93%E8%AE%A1%E7%AE%97/"}],"tags":[{"name":"日常","slug":"日常","link":"/tags/%E6%97%A5%E5%B8%B8/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"字符串","slug":"字符串","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"Computer","slug":"Computer","link":"/tags/Computer/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"面经1-swimtransformer","slug":"面经1-swimtransformer","link":"/tags/%E9%9D%A2%E7%BB%8F1-swimtransformer/"},{"name":"面经2-attention(注意力机制)","slug":"面经2-attention-注意力机制","link":"/tags/%E9%9D%A2%E7%BB%8F2-attention-%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/"},{"name":"面试真题","slug":"面试真题","link":"/tags/%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/"},{"name":"算法设计概念","slug":"算法设计概念","link":"/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%A6%82%E5%BF%B5/"},{"name":"算法设计","slug":"算法设计","link":"/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"},{"name":"代码","slug":"代码","link":"/tags/%E4%BB%A3%E7%A0%81/"},{"name":"代码实现","slug":"代码实现","link":"/tags/%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/"},{"name":"C语言","slug":"C语言","link":"/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"编程","slug":"编程","link":"/tags/%E7%BC%96%E7%A8%8B/"},{"name":"字符处理","slug":"字符处理","link":"/tags/%E5%AD%97%E7%AC%A6%E5%A4%84%E7%90%86/"},{"name":"数学函数","slug":"数学函数","link":"/tags/%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0/"},{"name":"字符串处理","slug":"字符串处理","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"},{"name":"算法设计、动态规划","slug":"算法设计、动态规划","link":"/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E3%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"算法设计证明题","slug":"算法设计证明题","link":"/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E8%AF%81%E6%98%8E%E9%A2%98/"},{"name":"证明","slug":"证明","link":"/tags/%E8%AF%81%E6%98%8E/"},{"name":"证明题","slug":"证明题","link":"/tags/%E8%AF%81%E6%98%8E%E9%A2%98/"},{"name":"面经","slug":"面经","link":"/tags/%E9%9D%A2%E7%BB%8F/"},{"name":"面试经验","slug":"面试经验","link":"/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"排序","slug":"排序","link":"/tags/%E6%8E%92%E5%BA%8F/"},{"name":"堆栈","slug":"堆栈","link":"/tags/%E5%A0%86%E6%A0%88/"},{"name":"输入方法","slug":"输入方法","link":"/tags/%E8%BE%93%E5%85%A5%E6%96%B9%E6%B3%95/"},{"name":"transformer","slug":"transformer","link":"/tags/transformer/"}],"categories":[{"name":"算法题解","slug":"算法题解","link":"/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"},{"name":"编程语言","slug":"编程语言","link":"/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"编程语言/C","link":"/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"}],"pages":[]}