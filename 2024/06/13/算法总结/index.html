<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>算法总结 - Blogs</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#ffffff"><meta name="application-name" content="Edward&#039;s Blogs"><meta name="msapplication-TileImage" content="/source/icon.jpg"><meta name="msapplication-TileColor" content="#ffffff"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Edward&#039;s Blogs"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="总结了acwing上的基础算法..."><meta property="og:type" content="blog"><meta property="og:title" content="算法总结"><meta property="og:url" content="https://mr-xiongyq.github.io/2024/06/13/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"><meta property="og:site_name" content="Blogs"><meta property="og:description" content="总结了acwing上的基础算法..."><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://mr-xiongyq.github.io/img/og_image.png"><meta property="article:published_time" content="2024-06-13T12:15:51.000Z"><meta property="article:modified_time" content="2024-06-27T11:08:23.503Z"><meta property="article:author" content="Xiongyuqi"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://mr-xiongyq.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://mr-xiongyq.github.io/2024/06/13/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"},"headline":"算法总结","image":["https://mr-xiongyq.github.io/img/og_image.png"],"datePublished":"2024-06-13T12:15:51.000Z","dateModified":"2024-06-27T11:08:23.503Z","author":{"@type":"Person","name":"Xiongyuqi"},"publisher":{"@type":"Organization","name":"Blogs","logo":{"@type":"ImageObject","url":"https://mr-xiongyq.github.io/img/logo.svg"}},"description":"总结了acwing上的基础算法..."}</script><link rel="canonical" href="https://mr-xiongyq.github.io/2024/06/13/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/6.0.0/css/all.min.css"><link rel="stylesheet" href="https://npm.elemecdn.com/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.lug.ustc.edu.cn/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://npm.elemecdn.com/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://npm.elemecdn.com/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://npm.elemecdn.com/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.1.1"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Blogs" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" target="_blank" rel="noopener" href="https://github.com/Mr-xiongyq">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="GitHub上下载" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-06-13T12:15:51.000Z" title="2024/6/13 20:15:51">2024-06-13</time>发表</span><span class="level-item"><time dateTime="2024-06-27T11:08:23.503Z" title="2024/6/27 19:08:23">2024-06-27</time>更新</span><span class="level-item">2 小时读完 (大约19469个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">算法总结</h1><div class="content"><p>目录</p>
<p>一、基础算法	3</p>
<p>快速排序算法模板	3</p>
<p>归并排序算法模板	4</p>
<p>逆序对数量	5</p>
<p>整数二分算法模板	6</p>
<p>浮点数二分算法模板	7</p>
<p>高精度加法	7</p>
<p>高精度减法	8</p>
<p>高精度比大小（cmp函数）	8</p>
<p>高精度乘低精度	8</p>
<p>高精度乘高精度	9</p>
<p>高精度除低精度	9</p>
<p>高精度除高精度	10</p>
<p>一维前缀和	11</p>
<p>二维前缀和	11</p>
<p>一维差分	12</p>
<p>二维差分	13</p>
<p>位运算	14</p>
<p>双指针算法	14</p>
<p>离散化	14</p>
<p>区间合并	16</p>
<p>二、数据结构	17</p>
<p>单链表	17</p>
<p>双链表	18</p>
<p>栈	19</p>
<p>队列	20</p>
<p>循环队列	21</p>
<p>单调栈	22</p>
<p>单调队列	23</p>
<p>KMP字符串匹配	24</p>
<p>二叉树的存储与遍历	25</p>
<p>Trie树	28</p>
<p>并查集	29</p>
<p>堆	32</p>
<p>一般hash	33</p>
<p>字符串哈希	34</p>
<p>三、搜索与图论	37</p>
<p>树与图的存储	38</p>
<p>邻接矩阵	38</p>
<p>邻接表	38</p>
<p>树与图的遍历	38</p>
<p>应用：数字全排列	39</p>
<p>应用：树的重心	39</p>
<p>应用：n-皇后问题	41</p>
<p>宽度优先遍历	42</p>
<p>应用：走迷宫	42</p>
<p>应用：八数码	43</p>
<p>拓扑排序	44</p>
<p>Dijkstra算法	46</p>
<p>Bellman-Ford算法	49</p>
<p>SPFA算法（队列优化的Bellman-Ford算法）	52</p>
<p>floyd算法	55</p>
<p>最短路算法总结	57</p>
<p>prim算法	57</p>
<p>Kruskal算法	59</p>
<p>染色法判别二分图	62</p>
<p>匈牙利算法	64</p>
<p>四、数学知识	67</p>
<p>试除法判定质数	68</p>
<p>试除法分解质因数	68</p>
<p>埃氏筛法求质数	68</p>
<p>线性筛法求质数	69</p>
<p>试除法求所有约数	69</p>
<p>约数个数	69</p>
<p>约数之和	70</p>
<p>欧几里得算法(求最大公约数)	71</p>
<p>最小公倍数	72</p>
<p>求欧拉函数	72</p>
<p>线性筛法求欧拉函数	73</p>
<p>快速幂	74</p>
<p>扩展欧几里得算法	74</p>
<p>中国剩余定理	75</p>
<p>扩展中国剩余定理	76</p>
<p>高斯消元法	76</p>
<p>求组合数	79</p>
<p>Lucas定理求组合数	81</p>
<p>分解质因数法求组合数	83</p>
<p>容斥原理应用	87</p>
<p>博弈论	88</p>
<p>五、动态规划	91</p>
<p>闫式dp分析法.jpg	91</p>
<p>背包问题	91</p>
<p>区间DP	100</p>
<p>计数类DP	102</p>
<p>数位统计DP	102</p>
<p>状态压缩DP	104</p>
<p>树形DP	106</p>
<p>记忆化搜索	108</p>
<p>六、贪心	109</p>
<p>区间问题	109</p>
<p>区间选点	109</p>
<p>区间分组	111</p>
<p>排序不等式	112</p>
<p>排队打水	112</p>
<h2 id="一、基础算法"><a href="#一、基础算法" class="headerlink" title="一、基础算法"></a>一、基础算法</h2><h3 id="快速排序算法模板"><a href="#快速排序算法模板" class="headerlink" title="快速排序算法模板"></a>快速排序算法模板</h3><p>void quick_sort(int q[], int l, int r)</p>
<p>{</p>
<pre><code>//递归的终止情况

if (l &gt;= r) return;



 //选取分界线。这里选数组中间那个数

int i = l - 1, j = r + 1, x = q[l + r &gt;&gt; 1];

//划分成左右两个部分

while (i &lt; j)

&#123;

    do i ++ ; while (q[i] &lt; x);

    do j -- ; while (q[j] &gt; x);

    if (i &lt; j) swap(q[i], q[j]);

&#125;

//对左右部分排序

quick_sort(q, l, j), quick_sort(q, j + 1, r);
</code></pre>
<p>}</p>
<p>边界问题：因为边界问题只有这两种组合，不能随意搭配</p>
<p>1.x不能取q[l]和q[l+r&gt;&gt;1];</p>
<p>quick_sort(q,l,i-1),quick_sort(q,i,r);</p>
<p>2.x不能取q[r]和q[(l+r+1)&gt;&gt;1];</p>
<p>quick_sort(q,l,j),quick_sort(q,j+1,r);</p>
<h3 id="归并排序算法模板"><a href="#归并排序算法模板" class="headerlink" title="归并排序算法模板"></a>归并排序算法模板</h3><p>void merge_sort(int q[], int l, int r)</p>
<p>{</p>
<pre><code>//递归的终止情况

if (l &gt;= r) return;

//第一步：分成子问题

int mid = l + r &gt;&gt; 1;

//第二步：递归处理子问题

merge_sort(q, l, mid);

merge_sort(q, mid + 1, r);



//第三步：合并子问题

int k = 0, i = l, j = mid + 1;

while (i &lt;= mid &amp;&amp; j &lt;= r)

    if (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];

    else tmp[k ++ ] = q[j ++ ];



while (i &lt;= mid) tmp[k ++ ] = q[i ++ ];

while (j &lt;= r) tmp[k ++ ] = q[j ++ ];

//第四步：复制回原数组

for (i = l, j = 0; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];
</code></pre>
<p>}</p>
<h3 id="逆序对数量"><a href="#逆序对数量" class="headerlink" title="逆序对数量"></a>逆序对数量</h3><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。</p>
<p>思路：归并排序</p>
<p>举个例子：</p>
<p>在合并 {4 ,5} {1 , 2} 的时候，首先我们判断 1 &lt; 4，我们即可统计出逆序对为2，为什么呢？这利用了数组的部分有序性。因为我们知道 {4 ,5} 这个数组必然是有序的，因为是合并上来的。此时当 1比4小的时候，证明4以后的数也都比1大，此时就构成了从4开始到 {4,5}这个数组结束，这么多个逆序对（2个），此时利用一个临时数组，将1存放起来，接着比较2和4的大小，同样可以得到有2个逆序对，于是将2也放进临时数组中，此时右边数组已经完全没有元素了，则将左边剩余的元素全部放进临时元素中，最后将临时数组中的元素放进原数组对应的位置。</p>
<p>最后接着向上合并~</p>
<p>逆序对数量.png</p>
<p>归并排序求逆序对.gif</p>
<p>using namespace std;</p>
<p>typedef long long  LL;</p>
<p>const int N &#x3D; 100010;</p>
<p>int n;</p>
<p>int q[N], tmp[N];</p>
<p>LL merge_sort(int l, int r) {</p>
<pre><code>if (l &gt;= r)return 0;

int mid = (l + r) &gt;&gt; 1;

LL res = merge_sort(l, mid) + merge_sort(mid + 1, r);

// 归并的过程

int k = 0, i = l, j = mid + 1;

while (i &lt;= mid &amp;&amp; j &lt;= r)

    if (q[i] &lt;= q[j])tmp[k++] = q[i++];

    else &#123;

        tmp[k++] = q[j++];

        res += mid - i + 1;

    &#125;

//扫尾

while (i &lt;= mid)tmp[k++] = q[i++];

while (j &lt;= r)tmp[k++] = q[j++];

//物归原主

for (i = l, j = 0; i &lt;= r; j++, i++)q[i] = tmp[j];

return res;
</code></pre>
<p>}</p>
<p>int main() {</p>
<pre><code>cin &gt;&gt; n;

for (int i = 0; i &lt; n; i++)cin &gt;&gt; q[i];

cout &lt;&lt; merge_sort(0, n - 1) &lt;&lt; endl;

return 0;
</code></pre>
<p>}</p>
<h3 id="整数二分算法模板"><a href="#整数二分算法模板" class="headerlink" title="整数二分算法模板"></a>整数二分算法模板</h3><p>对lower_bound来说，它寻找的就是第一个满足条件“值大于等于x”的元素的位置；对upper_bound函数来说，它寻找的是第一个满足“值大于 x”的元素的位置。</p>
<p>bool check(int x) {&#x2F;* … *&#x2F;} &#x2F;&#x2F; 检查x是否满足某种性质</p>
<p>&#x2F;&#x2F; 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</p>
<p>int bsearch_1(int l, int r)</p>
<p>{</p>
<pre><code>while (l &lt; r)

&#123;

    int mid = l + r &gt;&gt; 1;

    if (check(mid)) r = mid;    // check()判断mid是否满足性质

    else l = mid + 1;//左加右减

&#125;

return l;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</p>
<p>int bsearch_2(int l, int r)</p>
<p>{</p>
<pre><code>while (l &lt; r)

&#123;

    int mid = l + r + 1 &gt;&gt; 1;//如果下方else后面是l则这里加1

    if (check(mid)) l = mid;

    else r = mid - 1;//左加右减

&#125;

return l;
</code></pre>
<p>}</p>
<h3 id="浮点数二分算法模板"><a href="#浮点数二分算法模板" class="headerlink" title="浮点数二分算法模板"></a>浮点数二分算法模板</h3><p>bool check(double x) {&#x2F;* … *&#x2F;} &#x2F;&#x2F; 检查x是否满足某种性质</p>
<p>double bsearch_3(double l, double r)</p>
<p>{</p>
<pre><code>const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求

while (r - l &gt; eps)

&#123;

    double mid = (l + r) / 2;

    if (check(mid)) r = mid;

    else l = mid;

&#125;

return l;
</code></pre>
<p>}</p>
<h3 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h3><p>&#x2F;&#x2F; C &#x3D; A + B, A &gt;&#x3D; 0, B &gt;&#x3D; 0</p>
<p>vector<int> add(vector<int> &amp;a,vector<int> &amp;b){</p>
<pre><code>//c为答案

vector&lt;int&gt; c;

//t为进位

int t=0;

for(int i=0;i&lt;a.size()||i&lt;b.size();i++)&#123;

    //不超过a的范围添加a[i]

    if(i&lt;a.size())t+=a[i];

    //不超过b的范围添加b[i]

    if(i&lt;b.size())t+=b[i];

    //取当前位的答案

    c.push_back(t%10);

    //是否进位

    t/=10;

&#125;

//如果t!=0的话向后添加1

if(t)c.push_back(1);

return c;
</code></pre>
<p>}</p>
<h3 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h3><p>&#x2F;&#x2F; C &#x3D; A - B, 满足A &gt;&#x3D; B, A &gt;&#x3D; 0, B &gt;&#x3D; 0</p>
<p>vector<int> sub(vector<int> &amp;A, vector<int> &amp;B)</p>
<p>{</p>
<pre><code>//答案

vector&lt;int&gt; C;

//遍历最大的数

for (int i = 0, t = 0; i &lt; A.size(); i ++ )

&#123;

    //t为进位

    t = A[i] - t;

    //不超过B的范围t=A[i]-B[i]-t;

    if (i &lt; B.size()) t -= B[i];

    //合二为一，取当前位的答案

    C.push_back((t + 10) % 10);

    //t&lt;0则t=1

    if (t &lt; 0) t = 1;

    //t&gt;=0则t=0

    else t = 0;

&#125;

//去除前导零

while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();

return C;
</code></pre>
<p>}</p>
<h3 id="高精度比大小（cmp函数）"><a href="#高精度比大小（cmp函数）" class="headerlink" title="高精度比大小（cmp函数）"></a>高精度比大小（cmp函数）</h3><p>&#x2F;&#x2F;高精度比大小</p>
<p>bool cmp(vector<int> &amp;A, vector<int> &amp;B) {</p>
<pre><code>if (A.size() != B.size())

    return A.size() &gt; B.size();

for (int i = A.size() - 1; i &gt;= 0; i -- )

    if (A[i] != B[i])

        return A[i] &gt; B[i];

return true;
</code></pre>
<p>}</p>
<h3 id="高精度乘低精度"><a href="#高精度乘低精度" class="headerlink" title="高精度乘低精度"></a>高精度乘低精度</h3><p>&#x2F;&#x2F; C &#x3D; A * b, A &gt;&#x3D; 0, b &gt;&#x3D; 0</p>
<p>vector<int> mul(vector<int> &amp;A, int b)</p>
<p>{</p>
<pre><code>//类似于高精度加法

vector&lt;int&gt; C;

//t为进位

int t = 0;

for (int i = 0; i &lt; A.size() || t; i ++ )

&#123;

    //不超过A的范围t=t+A[i]*b

    if (i &lt; A.size()) t += A[i] * b;

    //取当前位的答案

    C.push_back(t % 10);

    //进位

    t /= 10;

&#125;

//去除前导零

while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();



return C;
</code></pre>
<p>}</p>
<h3 id="高精度乘高精度"><a href="#高精度乘高精度" class="headerlink" title="高精度乘高精度"></a>高精度乘高精度</h3><p><strong>高精度加减乘除</strong>：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1LA411v7mt/">https://www.bilibili.com/video/BV1LA411v7mt/</a></p>
<p>vector<int> mul(vector<int> &amp;A, vector<int> &amp;B) {</p>
<pre><code>vector&lt;int&gt; C(A.size() + B.size()); // 初始化为 0，C的size可以大一点



for (int i = 0; i &lt; A.size(); i++)

    for (int j = 0; j &lt; B.size(); j++)

        C[i + j] += A[i] * B[j];

for (int i = 0, t = 0; i &lt; C.size(); i++) &#123; // i = C.size() - 1时 t 一定小于 10

    t += C[i];

    C[i] = t % 10;

    t /= 10;

&#125;



while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); // 必须要去前导 0，因为最高位很可能是 0

return C;
</code></pre>
<p>}</p>
<h3 id="高精度除低精度"><a href="#高精度除低精度" class="headerlink" title="高精度除低精度"></a>高精度除低精度</h3><p>&#x2F;&#x2F; A &#x2F; b &#x3D; C … r, A &gt;&#x3D; 0, b &gt; 0</p>
<p>vector<int> div(vector<int> &amp;A, int b, int &amp;r)&#x2F;&#x2F;高精度A，低精度b，余数r</p>
<p>{</p>
<pre><code>vector&lt;int&gt; C;//答案

r = 0;

for (int i = A.size() - 1; i &gt;= 0; i -- )

&#123;

    r = r * 10 + A[i];//补全r&gt;=b

    C.push_back(r / b);//取当前位的答案

    r %= b;//r%b为下一次计算

&#125;

reverse(C.begin(), C.end());//倒序为答案

while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();//去除前导零

return C;
</code></pre>
<p>}</p>
<h3 id="高精度除高精度"><a href="#高精度除高精度" class="headerlink" title="高精度除高精度"></a>高精度除高精度</h3><p><strong>高精度加减乘除</strong>：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1LA411v7mt/">https://www.bilibili.com/video/BV1LA411v7mt/</a></p>
<p>vector<int> div(vector<int> &amp;A, vector<int> &amp;B, vector<int> &amp;r) {</p>
<pre><code>vector&lt;int&gt; C;

if (!cmp(A, B)) &#123;

    C.push_back(0);

    r.assign(A.begin(), A.end());

    return C;

&#125;

int j = B.size();

r.assign(A.end() - j, A.end());

while (j &lt;= A.size()) &#123;

    int k = 0;

    while (cmp(r, B)) &#123;

        r = sub(r, B);

        k ++;

    &#125;

    C.push_back(k);

    if (j &lt; A.size())

        r.insert(r.begin(), A[A.size() - j - 1]);

    if (r.size() &gt; 1 &amp;&amp; r.back() == 0)

        r.pop_back();

    j++;

&#125;

reverse(C.begin(), C.end());

while (C.size() &gt; 1 &amp;&amp; C.back() == 0)

    C.pop_back();

return C;
</code></pre>
<p>}</p>
<h3 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h3><p>前缀和可以用于快速计算一个序列的区间和，也有很多问题里不是直接用前缀和，但是借用了前缀和的思想。</p>
<p>预处理:s[i]&#x3D;a[i]+a[i-1]</p>
<p>求区间[l,r]:sum&#x3D;s[r]-s[l-1]</p>
<p>“前缀和数组”和”原数组”可以合二为一</p>
<p>应用</p>
<p>const int N&#x3D;100010;</p>
<p>int a[N];</p>
<p>int main(){</p>
<pre><code>int n,m;

scanf(&quot;%d&quot;,&amp;n);

for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]);

for(int i=1;i&lt;=n;i++)a[i]=a[i-1]+a[i];

scanf(&quot;%d&quot;,&amp;m);

while(m--)&#123;

    int l,r;

    scanf(&quot;%d%d&quot;,&amp;l,&amp;r);

    printf(&quot;%d\n&quot;,a[r]-a[l-1]);

&#125;

return 0;
</code></pre>
<p>}</p>
<h3 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h3><p>计算矩阵的前缀和：s[x][y] &#x3D; s[x - 1][y] + s[x][y -1] - s[x-1][y-1] + a[x][y]</p>
<p>以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：</p>
<p>计算子矩阵的和：s &#x3D; s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 -1]</p>
<p>应用</p>
<p>int s[1010][1010];</p>
<p>int n,m,q;</p>
<p>int main(){</p>
<pre><code>scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;q);

for(int i=1;i&lt;=n;i++)

    for(int j=1;j&lt;=m;j++)

        scanf(&quot;%d&quot;,&amp;s[i][j]);

for(int i=1;i&lt;=n;i++)

    for(int j=1;j&lt;=m;j++)

        s[i][j]+=s[i-1][j]+s[i][j-1]-s[i-1][j-1];

while(q--)&#123;

    int x1,y1,x2,y2;

    scanf(&quot;%d%d%d%d&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2);

    printf(&quot;%d\n&quot;,s[x2][y2]-s[x2][y1-1]-s[x1-1][y2]+s[x1-1][y1-1]);

&#125;

return 0;
</code></pre>
<p>}</p>
<h3 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h3><p>差分是前缀和的逆运算，对于一个数组a，其差分数组b的每一项都是a [ i ]和前一项a [ i − 1 ]的差。</p>
<p>注意：差分数组和原数组必须分开存放！！！！</p>
<p>给区间[l, r]中的每个数加上c：B[l] +&#x3D; c, B[r + 1] -&#x3D; c</p>
<p>应用</p>
<p>using namespace std;</p>
<p>int a[100010],s[100010];</p>
<p>int main(){</p>
<pre><code>int n,m;

cin&gt;&gt;n&gt;&gt;m;

for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i];   

for(int i=1;i&lt;=n;i++)s[i]=a[i]-a[i-1];// 读入并计算差分数组

while(m--)&#123;

    int l,r,c;

    cin&gt;&gt;l&gt;&gt;r&gt;&gt;c;

    s[l]+=c;

    s[r+1]-=c;// 在原数组中将区间[l, r]加上c

&#125;

for(int i=1;i&lt;=n;i++)&#123;

    s[i]+=s[i-1];

    cout&lt;&lt;s[i]&lt;&lt;&#39; &#39;;

&#125;// 给差分数组计算前缀和，就求出了原数组

return 0;
</code></pre>
<p>}</p>
<h3 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h3><p>给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：</p>
<p>S[x1, y1] +&#x3D; c, S[x2 + 1, y1] -&#x3D; c, S[x1, y2 + 1] -&#x3D; c, S[x2 + 1, y2 + 1] +&#x3D; c</p>
<p>应用</p>
<p>const int N &#x3D; 1e3 + 10;</p>
<p>int a[N][N], b[N][N];</p>
<p>void insert(int x1, int y1, int x2, int y2, int c)</p>
<p>{</p>
<pre><code>b[x1][y1] += c;

b[x2 + 1][y1] -= c;

b[x1][y2 + 1] -= c;

b[x2 + 1][y2 + 1] += c;
</code></pre>
<p>}</p>
<p>int main()</p>
<p>{</p>
<pre><code>int n, m, q;

cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;

for (int i = 1; i &lt;= n; i++)

    for (int j = 1; j &lt;= m; j++)

        cin &gt;&gt; a[i][j];

for (int i = 1; i &lt;= n; i++)

&#123;

    for (int j = 1; j &lt;= m; j++)

    &#123;

        insert(i, j, i, j, a[i][j]);      //构建差分数组

    &#125;

&#125;

while (q--)

&#123;

    int x1, y1, x2, y2, c;

    cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c;

    insert(x1, y1, x2, y2, c);//加c

&#125;

for (int i = 1; i &lt;= n; i++)

&#123;

    for (int j = 1; j &lt;= m; j++)

    &#123;

        b[i][j] += b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1];  //二维前缀和

    &#125;

&#125;

for (int i = 1; i &lt;= n; i++)

&#123;

    for (int j = 1; j &lt;= m; j++)

    &#123;

        printf(&quot;%d &quot;, b[i][j]);

    &#125;

    printf(&quot;\n&quot;);

&#125;

return 0;
</code></pre>
<p>}</p>
<p>关于前缀和与差分的相关博客链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39757593/article/details/129219491">https://blog.csdn.net/qq_39757593/article/details/129219491</a></p>
<h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>求n的第k位数字: n &gt;&gt; k &amp; 1</p>
<p>返回n的最后一位1：lowbit(n) &#x3D; n &amp; -n</p>
<h3 id="双指针算法"><a href="#双指针算法" class="headerlink" title="双指针算法"></a>双指针算法</h3><p>for (int i &#x3D; 0, j &#x3D; 0; i &lt; n; i ++ )</p>
<p>{</p>
<pre><code>while (j &lt; i &amp;&amp; check(i, j)) j ++ ;

// 具体问题的逻辑
</code></pre>
<p>}</p>
<p>常见问题分类：</p>
<pre><code>(1) 对于一个序列，用两个指针维护一段区间

(2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作
</code></pre>
<h3 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h3><p>离散化的本质是建立了一段数列到自然数之间的映射关系（value -&gt; index)，通过建立新索引，来缩小目标区间，使得可以进行一系列连续数组可以进行的操作比如二分，前缀和等…</p>
<p>离散化首先需要排序去重：</p>
<p>1.排序：sort(alls.begin(),alls.end())</p>
<p>2.去重：alls.earse(unique(alls.begin(),alls.end()),alls.end());</p>
<p>vector<int> alls; &#x2F;&#x2F; 存储所有待离散化的值</p>
<p>sort(alls.begin(), alls.end()); &#x2F;&#x2F; 将所有值排序</p>
<p>alls.erase(unique(alls.begin(), alls.end()), alls.end());   &#x2F;&#x2F; 去掉重复元素</p>
<p>&#x2F;&#x2F; 二分求出x对应的离散化的值</p>
<p>int find(int x) &#x2F;&#x2F; 找到第一个大于等于x的位置</p>
<p>{</p>
<pre><code>int l = 0, r = alls.size() - 1;

while (l &lt; r)

&#123;

    int mid = l + r &gt;&gt; 1;

    if (alls[mid] &gt;= x) r = mid;

    else l = mid + 1;

&#125;

return r + 1; // 映射到1, 2, ...n
</code></pre>
<p>}</p>
<p>应用</p>
<p>typedef pair&lt;int, int&gt; PII;</p>
<p>const int N &#x3D; 300010;</p>
<p>int n, m;</p>
<p>int a[N], s[N];</p>
<p>vector<int> alls;&#x2F;&#x2F;存入下标容器</p>
<p>vector<PII> add, query;&#x2F;&#x2F;add增加容器，存入对应下标和增加的值的大小</p>
<p>&#x2F;&#x2F;query存入需要计算下标区间和的容器</p>
<p>int find(int x)</p>
<p>{</p>
<pre><code>int l = 0, r = alls.size() - 1;

while (l &lt; r)//查找大于等于x的最小的值的下标

&#123;

    int mid = l + r &gt;&gt; 1;

    if (alls[mid] &gt;= x) r = mid;

    else l = mid + 1;

&#125;

return r + 1;//因为使用前缀和，其下标要+1可以不考虑边界问题
</code></pre>
<p>}</p>
<p>int main()</p>
<p>{</p>
<pre><code>cin &gt;&gt; n &gt;&gt; m;

for (int i = 0; i &lt; n; i ++ )

&#123;

    int x, c;

    cin &gt;&gt; x &gt;&gt; c;

    add.push_back(&#123;x, c&#125;);//存入下标即对应的数值c



    alls.push_back(x);//存入数组下标x=add.first

&#125;



for (int i = 0; i &lt; m; i ++ )

&#123;

    int l, r;

    cin &gt;&gt; l &gt;&gt; r;

    query.push_back(&#123;l, r&#125;);//存入要求的区间



    alls.push_back(l);//存入区间左右下标

    alls.push_back(r);

&#125;



// 区间去重

sort(alls.begin(), alls.end());

alls.erase(unique(alls.begin(), alls.end()), alls.end());



// 处理插入

for (auto item : add)

&#123;

    int x = find(item.first);//将add容器的add.secend值存入数组a[]当中，

    a[x] += item.second;//在去重之后的下标集合alls内寻找对应的下标并添加数值

&#125;



// 预处理前缀和

for (int i = 1; i &lt;= alls.size(); i ++ ) s[i] = s[i - 1] + a[i];



// 处理询问

for (auto item : query)

&#123;

    int l = find(item.first), r = find(item.second);//在下标容器中查找对应的左右两端[l~r]下标，然后通过下标得到前缀和相减再得到区间a[l~r]的和

    cout &lt;&lt; s[r] - s[l - 1] &lt;&lt; endl;

&#125;



return 0;
</code></pre>
<p>}</p>
<h3 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h3><p>&#x2F;&#x2F; 将所有存在交集的区间合并</p>
<p>void merge(vector<PII> &amp;segs)</p>
<p>{</p>
<pre><code>vector&lt;PII&gt; res;



sort(segs.begin(), segs.end());



int st = -2e9, ed = -2e9;

for (auto seg : segs)

    if (ed &lt; seg.first)

    &#123;

        if (st != -2e9) res.push_back(&#123;st, ed&#125;);

        st = seg.first, ed = seg.second;

    &#125;

    else ed = max(ed, seg.second);



if (st != -2e9) res.push_back(&#123;st, ed&#125;);



segs = res;
</code></pre>
<p>}</p>
<h2 id="二、数据结构"><a href="#二、数据结构" class="headerlink" title="二、数据结构"></a>二、数据结构</h2><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>const int N&#x3D;100010;</p>
<p>int head,e[N],ne[N],idx;</p>
<p>&#x2F;&#x2F;初始化</p>
<p>void init(){</p>
<pre><code>head=-1;

idx=0;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F;在链表头部添加节点</p>
<p>void add_to_head(int x){</p>
<pre><code>e[idx]=x,ne[idx]=head,head=idx++;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F;在位置k添加节点x</p>
<p>void add(int k,int x){</p>
<pre><code>e[idx]=x,ne[idx]=ne[k],ne[k]=idx++;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F;删除位置k的节点</p>
<p>void remove(int k){</p>
<pre><code>ne[k]=ne[ne[k]];
</code></pre>
<p>}</p>
<p>应用</p>
<p>int main(){</p>
<pre><code>int m;

init();

cin&gt;&gt;m;

while(m--)&#123;

    int k,x;

    char op;

    cin&gt;&gt;op;

    if(op==&#39;H&#39;)&#123;

        cin&gt;&gt;x;

        add_to_head(x);

    &#125;else if(op==&#39;D&#39;)&#123;

        cin&gt;&gt;k;

        if(!k)head=ne[head];

        remove(k-1);

    &#125;else &#123;

        cin&gt;&gt;k&gt;&gt;x;

        add(k-1,x);

    &#125;

&#125;

for(int i=head;i!=-1;i=ne[i])cout&lt;&lt;e[i]&lt;&lt;&#39; &#39;;

cout&lt;&lt;endl;

return 0;
</code></pre>
<p>}</p>
<h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><p>const int N&#x3D;100010;</p>
<p>int e[N],l[N],r[N],idx;</p>
<p>&#x2F;&#x2F;初始化</p>
<p>void init(){</p>
<pre><code>l[1]=0;

r[0]=1;

idx=2;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F;在节点a的右边插入一个数x</p>
<p>void insert(int a,int x){</p>
<pre><code>e[idx]=x;

l[idx]=a,r[idx]=r[a];

l[r[a]]=idx,r[a]=idx++;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F;删除节点a</p>
<p>void remove(int a){</p>
<pre><code>l[r[a]]=l[a];

r[l[a]]=r[a];
</code></pre>
<p>}</p>
<p>应用</p>
<p>int main(){</p>
<pre><code>int m;

cin&gt;&gt;m;

init();

while(m--)&#123;

    string op;

    cin&gt;&gt;op;

    int k,x;

    if(op==&quot;L&quot;)&#123;//在最左端插入数x

        cin&gt;&gt;x;

        insert(0,x);

    &#125;else if(op==&quot;R&quot;)&#123;//在最右端插入数x

        cin&gt;&gt;x;

        insert(l[1],x);

    &#125;else if(op==&quot;D&quot;)&#123;//删除第k个插入的数

        cin&gt;&gt;k;

        remove(k+1);

    &#125;else if(op==&quot;IL&quot;)&#123;//在第k个位置的左侧插入一个数

        cin&gt;&gt;k&gt;&gt;x;

        insert(l[k+1],x);

    &#125;else if(op==&quot;LR&quot;)&#123;//在第k个位置的右侧插入一个数

        cin&gt;&gt;k&gt;&gt;x;

        insert(k+1,x);

    &#125;

&#125;

for(int i=r[0];i!=1;i=r[i])printf(&quot;%d &quot;,e[i]);

cout&lt;&lt;endl;

return 0;
</code></pre>
<p>}</p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>&#x2F;&#x2F; tt表示栈顶</p>
<p>int stk[N], tt &#x3D; 0;</p>
<p>&#x2F;&#x2F; 向栈顶插入一个数</p>
<p>stk[ ++ tt] &#x3D; x;</p>
<p>&#x2F;&#x2F; 从栈顶弹出一个数</p>
<p>tt – ;</p>
<p>&#x2F;&#x2F; 栈顶的值</p>
<p>stk[tt];</p>
<p>&#x2F;&#x2F; 判断栈是否为空，如果 tt &gt; 0，则表示不为空</p>
<p>if (tt &gt; 0)</p>
<p>{</p>
<p>}</p>
<p>应用</p>
<p>const int N&#x3D;100010;</p>
<p>int stk[N],tt;</p>
<p>int main(){</p>
<pre><code>int m;

cin&gt;&gt;m;

while(m--)&#123;

    string op;

    int x;

    cin&gt;&gt;op;

    if(op==&quot;push&quot;)&#123;

        cin&gt;&gt;x;

        stk[tt++]=x;

    &#125;else if(op==&quot;pop&quot;)&#123;

        tt--;

    &#125;else if(op==&quot;query&quot;)&#123;

        cout&lt;&lt;stk[tt-1]&lt;&lt;endl;

    &#125;else&#123;

        if(!tt)cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;

        else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;

    &#125;

&#125;

return 0;
</code></pre>
<p>}</p>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>普通队列</p>
<p>&#x2F;&#x2F; hh 表示队头，tt表示队尾</p>
<p>int q[N], hh &#x3D; 0, tt &#x3D; -1;</p>
<p>&#x2F;&#x2F; 向队尾插入一个数</p>
<p>q[ ++ tt] &#x3D; x;</p>
<p>&#x2F;&#x2F; 从队头弹出一个数</p>
<p>hh ++ ;</p>
<p>&#x2F;&#x2F; 队头的值</p>
<p>q[hh];</p>
<p>&#x2F;&#x2F; 判断队列是否为空，如果 hh &lt;&#x3D; tt，则表示不为空</p>
<p>if (hh &lt;&#x3D; tt)</p>
<p>{</p>
<p>}</p>
<p>应用</p>
<p>int const N&#x3D;100010;</p>
<p>int que[N],hh,tt&#x3D;-1;</p>
<p>int main(){</p>
<pre><code>int m;

cin&gt;&gt;m;

while(m--)&#123;

    string op;

    int x;

    cin&gt;&gt;op;

    if(op==&quot;push&quot;)&#123;

        cin&gt;&gt;x;

        que[++tt]=x;

    &#125;else if(op==&quot;query&quot;)&#123;

        cout&lt;&lt;que[hh]&lt;&lt;endl;

    &#125;else if(op==&quot;pop&quot;)&#123;

        hh++;

    &#125;else&#123;

        if(hh&gt;tt)cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;

        else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;

    &#125;

&#125;

return 0;
</code></pre>
<p>}</p>
<h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>&#x2F;&#x2F; hh 表示队头，tt表示队尾的后一个位置</p>
<p>int q[N], hh &#x3D; 0, tt &#x3D; 0;</p>
<p>&#x2F;&#x2F; 向队尾插入一个数</p>
<p>q[tt ++ ] &#x3D; x;</p>
<p>if (tt &#x3D;&#x3D; N) tt &#x3D; 0;</p>
<p>&#x2F;&#x2F; 从队头弹出一个数</p>
<p>hh ++ ;</p>
<p>if (hh &#x3D;&#x3D; N) hh &#x3D; 0;</p>
<p>&#x2F;&#x2F; 队头的值</p>
<p>q[hh];</p>
<p>&#x2F;&#x2F; 判断队列是否为空，如果hh !&#x3D; tt，则表示不为空</p>
<p>if (hh !&#x3D; tt)</p>
<p>{</p>
<p>}</p>
<h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p>常见模型：找出每个数左边离它最近的比它大&#x2F;小的数</p>
<p>int tt &#x3D; 0;</p>
<p>for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )</p>
<p>{</p>
<pre><code>while (tt &amp;&amp; check(stk[tt], i)) tt -- ;

stk[ ++ tt] = i;
</code></pre>
<p>}</p>
<p>应用</p>
<p>找出每个数左边离它最近的比它大&#x2F;小的数</p>
<p>stack<int> stk;</p>
<p>int main(){</p>
<pre><code>int n;

cin &gt;&gt; n;

stk.push(-1);

for (int i = 0; i &lt; n; i ++)&#123;

    int x; 

    cin &gt;&gt; x;

    while (stk.size() &amp;&amp; stk.top() &gt;= x) stk.pop();

    cout &lt;&lt; stk.top() &lt;&lt; &quot; &quot;;

    stk.push(x);

&#125;

return 0;
</code></pre>
<p>}</p>
<h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><p>常见模型：找出滑动窗口中的最大值&#x2F;最小值</p>
<p>int hh &#x3D; 0, tt &#x3D; -1;</p>
<p>for (int i &#x3D; 0; i &lt; n; i ++ )</p>
<p>{</p>
<pre><code>while (hh &lt;= tt &amp;&amp; check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口

while (hh &lt;= tt &amp;&amp; check(q[tt], i)) tt -- ;

q[ ++ tt] = i;
</code></pre>
<p>}</p>
<p>const int N &#x3D; 1000010;</p>
<p>int a[N];</p>
<p>int main()</p>
<p>{</p>
<pre><code>int n, k;

cin &gt;&gt; n &gt;&gt; k;

for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; a[i];//读入数据

deque&lt;int&gt; q;

for(int i = 1; i &lt;= n; i++)

&#123;

    while(q.size() &amp;&amp; q.back() &gt; a[i]) //新进入窗口的值小于队尾元素，则队尾出队列

        q.pop_back();

    q.push_back(a[i]);//将新进入的元素入队

    if(i - k &gt;= 1 &amp;&amp; q.front() == a[i - k])//若队头是否滑出了窗口，队头出队 

        q.pop_front();

    if(i &gt;= k)//当窗口形成，输出队头对应的值

        cout &lt;&lt; q.front() &lt;&lt;&quot; &quot;;

&#125;

q.clear();

cout &lt;&lt; endl;



//最大值亦然

for(int i = 1; i &lt;= n; i++)

&#123;

    while(q.size() &amp;&amp; q.back() &lt; a[i]) q.pop_back();

    q.push_back(a[i]);

    if(i - k &gt;= 1 &amp;&amp; a[i - k] == q.front()) q.pop_front(); 

    if(i &gt;= k) cout &lt;&lt; q.front() &lt;&lt; &quot; &quot;;



&#125;
</code></pre>
<p>}</p>
<h3 id="KMP字符串匹配"><a href="#KMP字符串匹配" class="headerlink" title="KMP字符串匹配"></a>KMP字符串匹配</h3><p>视频讲解：[最浅显易懂的 KMP 算法讲解_哔哩哔哩_bilibili]：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1AY4y157yL">https://www.bilibili.com/video/BV1AY4y157yL</a></p>
<p>下标从1开始的kmp算法</p>
<p>const int N &#x3D; 100010, M &#x3D; 1000010;</p>
<p>int n, m;</p>
<p>int ne[N];</p>
<p>char s[M], p[N];</p>
<p>int main()</p>
<p>{</p>
<pre><code>cin &gt;&gt; n &gt;&gt; p + 1 &gt;&gt; m &gt;&gt; s + 1;

for (int i = 2, j = 0; i &lt;= n; i ++ )

&#123;

    while (j &amp;&amp; p[i] != p[j + 1]) j = ne[j];

    if (p[i] == p[j + 1]) j ++ ;

    ne[i] = j;

&#125;//处理ne数组

for (int i = 1, j = 0; i &lt;= m; i ++ )

&#123;

    while (j &amp;&amp; s[i] != p[j + 1]) j = ne[j];

    if (s[i] == p[j + 1]) j ++ ;

    if (j == n)

    &#123;

        printf(&quot;%d &quot;, i - n);

        j = ne[j];

    &#125;

&#125;//匹配算法

return 0;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; s[]是长文本，p[]是模式串，n是s的长度，m是p的长度</p>
<p>求模式串的Next数组：</p>
<p>for (int i &#x3D; 2, j &#x3D; 0; i &lt;&#x3D; m; i ++ )</p>
<p>{</p>
<pre><code>while (j &amp;&amp; p[i] != p[j + 1]) j = ne[j];

if (p[i] == p[j + 1]) j ++ ;

ne[i] = j;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; 匹配</p>
<p>for (int i &#x3D; 1, j &#x3D; 0; i &lt;&#x3D; n; i ++ )</p>
<p>{</p>
<pre><code>while (j &amp;&amp; s[i] != p[j + 1]) j = ne[j];

if (s[i] == p[j + 1]) j ++ ;

if (j == m)

&#123;

    j = ne[j];

    // 匹配成功后的逻辑

&#125;
</code></pre>
<p>}</p>
<p>下标从0开始的kmp算法</p>
<p>const int N &#x3D; 1000010;</p>
<p>int n, m;</p>
<p>char s[N], p[N];</p>
<p>int ne[N];</p>
<p>int main()</p>
<p>{</p>
<pre><code>cin &gt;&gt; m &gt;&gt; p &gt;&gt; n &gt;&gt; s;

ne[0] = -1;

for (int i = 1, j = -1; i &lt; m; i ++ )

&#123;

    while (j &gt;= 0 &amp;&amp; p[j + 1] != p[i]) j = ne[j];

    if (p[j + 1] == p[i]) j ++ ;

    ne[i] = j;

&#125;

for (int i = 0, j = -1; i &lt; n; i ++ )

&#123;

    while (j != -1 &amp;&amp; s[i] != p[j + 1]) j = ne[j];

    if (s[i] == p[j + 1]) j ++ ;

    if (j == m - 1)

    &#123;

        cout &lt;&lt; i - j &lt;&lt; &#39; &#39;;

        j = ne[j];

    &#125;

&#125;

return 0;
</code></pre>
<p>}</p>
<h3 id="二叉树的存储与遍历"><a href="#二叉树的存储与遍历" class="headerlink" title="二叉树的存储与遍历"></a>二叉树的存储与遍历</h3><p>const int N &#x3D; 1e6 + 10;</p>
<p>&#x2F;&#x2F; 二叉树的存储,l数组为左节点,r数组为右结点</p>
<p>int l[N], r[N];</p>
<p>&#x2F;&#x2F; 存储节点的数据</p>
<p>char w[N];</p>
<p>&#x2F;&#x2F; 节点的下标指针</p>
<p>int idx &#x3D; 0;</p>
<p>&#x2F;&#x2F; 先序创建</p>
<p>int pre_create(int n) {</p>
<pre><code>cin &gt;&gt; w[n];

if (w[n] == &#39;#&#39;) return -1;

l[n] = pre_create(++idx);

r[n] = pre_create(++idx);

return n;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; 中序创建</p>
<p>int in_create(int n) {</p>
<pre><code>if (w[n] == &#39;#&#39;) return -1;

l[n] = in_create(++idx);

cin &gt;&gt; w[n];

r[n] = in_create(++idx);

return n;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; 后序创建</p>
<p>int back_create(int n) {</p>
<pre><code>if (w[n] == &#39;#&#39;) return -1;

l[n] = back_create(++idx);

r[n] = back_create(++idx);

cin &gt;&gt; w[n];

return n;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; 先序遍历</p>
<p>void pre_print(int n){</p>
<pre><code>if (w[n] != &#39;#&#39;) cout &lt;&lt; w[n] &lt;&lt; &#39; &#39;;

if (l[n] &gt; 0) pre_print(l[n]);

if (r[n] &gt; 0) pre_print(r[n]);
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; 中序遍历</p>
<p>void in_print(int n){</p>
<pre><code>if (l[n] &gt; 0) in_print(l[n]);

if (w[n] != &#39;#&#39;) cout &lt;&lt; w[n] &lt;&lt; &#39; &#39;;

if (r[n] &gt; 0) in_print(r[n]);
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; 后序遍历</p>
<p>void back_print(int n){</p>
<pre><code>if (l[n] &gt; 0) back_print(l[n]);

if (r[n] &gt; 0) back_print(r[n]);

if (w[n] != &#39;#&#39;) cout &lt;&lt; w[n] &lt;&lt; &#39; &#39;;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; 层序遍历</p>
<p>void bfs(int root){</p>
<pre><code>queue&lt;int&gt; que;

que.push(root);

while (!que.empty()) &#123;

    int t = que.front();

    cout &lt;&lt; w[t] &lt;&lt; &#39; &#39;;

    que.pop();

    if (l[t] &gt; 0 &amp;&amp; w[l[t]] != &#39;#&#39;)

        que.push(l[t]);

    if (r[t] &gt; 0 &amp;&amp; w[r[t]] != &#39;#&#39;)

        que.push(r[t]);

&#125;
</code></pre>
<p>}</p>
<p>应用</p>
<p>int main(){</p>
<pre><code>// 先序创建

pre_create(++idx);

// 中序创建

// in_create(++idx);

// 后序创建

// back_create(++idx);

// 先序遍历

pre_print(1);

// 中序遍历

in_print(1);

// 后序遍历

back_print(1);

// 层序遍历

bfs(1);

// 测试数据abc##de#g##f###

// 输出如下：

// a b c d e g f 

// c b e g d f a 

// c g e f d b a 

// a b c d e f g 

return 0;
</code></pre>
<p>}</p>
<h3 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h3><p>Trie 树是一种多叉树的结构，每个节点保存一个字符，一条路径表示一个字符串。</p>
<p>相关链接：<a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/27771/">https://www.acwing.com/solution/content/27771/</a></p>
<p>int son[N][26], cnt[N], idx;</p>
<p>&#x2F;&#x2F; 0号点既是根节点，又是空节点</p>
<p>&#x2F;&#x2F; son[][]存储树中每个节点的子节点</p>
<p>&#x2F;&#x2F; cnt[]存储以每个节点结尾的单词数量</p>
<p>&#x2F;&#x2F; 插入一个字符串</p>
<p>void insert(char *str)</p>
<p>{</p>
<pre><code>int p = 0;

for (int i = 0; str[i]; i ++ )

&#123;

    int u = str[i] - &#39;a&#39;;

    if (!son[p][u]) son[p][u] = ++ idx;

    p = son[p][u];

&#125;

cnt[p] ++ ;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; 查询字符串出现的次数</p>
<p>int query(char *str)</p>
<p>{</p>
<pre><code>int p = 0;

for (int i = 0; str[i]; i ++ )

&#123;

    int u = str[i] - &#39;a&#39;;

    if (!son[p][u]) return 0;

    p = son[p][u];

&#125;

return cnt[p];
</code></pre>
<p>}</p>
<p>const int N &#x3D; 100010;</p>
<p>int son[N][26], cnt[N], idx;</p>
<p>char str[N];</p>
<p>void insert(char *str)</p>
<p>{</p>
<pre><code>int p = 0;

for (int i = 0; str[i]; i ++ )

&#123;

    int u = str[i] - &#39;a&#39;;

    if (!son[p][u]) son[p][u] = ++ idx;

    p = son[p][u];

&#125;

cnt[p] ++ ;
</code></pre>
<p>}&#x2F;&#x2F;插入</p>
<p>int query(char *str)</p>
<p>{</p>
<pre><code>int p = 0;

for (int i = 0; str[i]; i ++ )

&#123;

    int u = str[i] - &#39;a&#39;;

    if (!son[p][u]) return 0;

    p = son[p][u];

&#125;

return cnt[p];
</code></pre>
<p>}&#x2F;&#x2F;查询</p>
<p>int main()</p>
<p>{</p>
<pre><code>int n;

scanf(&quot;%d&quot;, &amp;n);

while (n -- )

&#123;

    char op[2];

    scanf(&quot;%s%s&quot;, op, str);

    if (*op == &#39;I&#39;) insert(str);

    else printf(&quot;%d\n&quot;, query(str));

&#125;



return 0;
</code></pre>
<p>}</p>
<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>(1)朴素并查集：</p>
<pre><code>int p[N]; //存储每个点的祖宗节点



// 返回x的祖宗节点

int find(int x)

&#123;

    if (p[x] != x) p[x] = find(p[x]);

    return p[x];

&#125;



// 初始化，假定节点编号是1~n

for (int i = 1; i &lt;= n; i ++ ) p[i] = i;



// 合并a和b所在的两个集合：

p[find(a)] = find(b);
</code></pre>
<p>(2)维护size的并查集：</p>
<pre><code>int p[N], size[N];

//p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量



// 返回x的祖宗节点

int find(int x)

&#123;

    if (p[x] != x) p[x] = find(p[x]);

    return p[x];

&#125;



// 初始化，假定节点编号是1~n

for (int i = 1; i &lt;= n; i ++ )

&#123;

    p[i] = i;

    size[i] = 1;

&#125;



// 合并a和b所在的两个集合：

size[find(b)] += size[find(a)];

p[find(a)] = find(b);
</code></pre>
<p>(3)维护到祖宗节点距离的并查集：</p>
<pre><code>int p[N], d[N];

//p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离



// 返回x的祖宗节点

int find(int x)

&#123;

    if (p[x] != x)

    &#123;

        int u = find(p[x]);

        d[x] += d[p[x]];

        p[x] = u;

    &#125;

    return p[x];

&#125;



// 初始化，假定节点编号是1~n

for (int i = 1; i &lt;= n; i ++ )

&#123;

    p[i] = i;

    d[i] = 0;

&#125;



// 合并a和b所在的两个集合：

p[find(a)] = find(b);

d[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量
</code></pre>
<p>应用</p>
<p>const int N&#x3D;100010;</p>
<p>int p[N],n,m;</p>
<p>int find(int x){&#x2F;&#x2F;找到祖宗节点+路径压缩</p>
<pre><code>if(p[x]!=x)p[x]=find(p[x]);

return p[x];
</code></pre>
<p>}</p>
<p>int main(){</p>
<pre><code>scanf(&quot;%d%d&quot;,&amp;n,&amp;m);

for(int i=1;i&lt;=n;i++)p[i]=i;

while(m--)&#123;

    char op[2];

    int a,b;

    scanf(&quot;%s%d%d&quot;,op,&amp;a,&amp;b);

    if(op[0]==&#39;M&#39;)p[find(a)]=find(b);

    else &#123;

        if(find(a)==find(b))puts(&quot;Yes&quot;);

        else puts(&quot;No&quot;);

    &#125;

&#125;

return 0;
</code></pre>
<p>}</p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>&#x2F;&#x2F; h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1</p>
<p>&#x2F;&#x2F; ph[k]存储第k个插入的点在堆中的位置</p>
<p>&#x2F;&#x2F; hp[k]存储堆中下标是k的点是第几个插入的</p>
<p>int h[N], ph[N], hp[N], size;</p>
<p>&#x2F;&#x2F; 交换两个点，及其映射关系</p>
<p>void heap_swap(int a, int b)</p>
<p>{</p>
<pre><code>swap(ph[hp[a]],ph[hp[b]]);

swap(hp[a], hp[b]);

swap(h[a], h[b]);
</code></pre>
<p>}</p>
<p>void down(int u)</p>
<p>{</p>
<pre><code>int t = u;

if (u * 2 &lt;= size &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2;

if (u * 2 + 1 &lt;= size &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1;

if (u != t)

&#123;

    heap_swap(u, t);

    down(t);

&#125;
</code></pre>
<p>}</p>
<p>void up(int u)</p>
<p>{</p>
<pre><code>while (u / 2 &amp;&amp; h[u] &lt; h[u / 2])

&#123;

    heap_swap(u, u / 2);

    u &gt;&gt;= 1;

&#125;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; O(n)建堆</p>
<p>for (int i &#x3D; n &#x2F; 2; i; i – ) down(i);</p>
<p>应用：堆排序</p>
<p>const int N&#x3D;100010;</p>
<p>int heap[N],cnt;</p>
<p>void down(int u){</p>
<pre><code>int t=u;

if(u*2&lt;=cnt&amp;&amp;heap[u*2]&lt;=heap[t])t=u*2;

if(u*2+1&lt;=cnt&amp;&amp;heap[u*2+1]&lt;=heap[t])t=u*2+1;

if(t!=u)&#123;

    swap(heap[t],heap[u]);

    down(t);

&#125;
</code></pre>
<p>}&#x2F;&#x2F;down操作</p>
<p>void up(int u){</p>
<pre><code>while(u/2&amp;&amp;heap[u/2]&gt;heap[u])&#123;

    swap(heap[u/2],heap[u]);

    u&gt;&gt;=1;

&#125;
</code></pre>
<p>}&#x2F;&#x2F;up操作</p>
<p>int main(){</p>
<pre><code>int n,m;

scanf(&quot;%d%d&quot;,&amp;n,&amp;m);

for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;heap[i]);

cnt=n;

for(int i=n/2;i;i--)down(i);

while(m--)&#123;

    printf(&quot;%d &quot;,heap[1]);

    heap[1]=heap[cnt--];

    down(1);

&#125;

return 0;
</code></pre>
<p>}</p>
<h3 id="一般hash"><a href="#一般hash" class="headerlink" title="一般hash"></a>一般hash</h3><p>(1) 拉链法</p>
<pre><code>int h[N], e[N], ne[N], idx;



// 向哈希表中插入一个数

void insert(int x)

&#123;

    int k = (x % N + N) % N;

    e[idx] = x;

    ne[idx] = h[k];

    h[k] = idx ++ ;

&#125;



// 在哈希表中查询某个数是否存在

bool find(int x)

&#123;

    int k = (x % N + N) % N;

    for (int i = h[k]; i != -1; i = ne[i])

        if (e[i] == x)

            return true;



    return false;

&#125;
</code></pre>
<p>(2) 开放寻址法</p>
<pre><code>int h[N];



// 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置

int find(int x)

&#123;

    int t = (x % N + N) % N;

    while (h[t] != null &amp;&amp; h[t] != x)

    &#123;

        t ++ ;

        if (t == N) t = 0;

    &#125;

    return t;

&#125;
</code></pre>
<h3 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h3><p>核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低</p>
<p>小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果</p>
<p>typedef unsigned long long ULL;</p>
<p>ULL h[N], p[N]; &#x2F;&#x2F; h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64</p>
<p>&#x2F;&#x2F; 初始化</p>
<p>p[0] &#x3D; 1;</p>
<p>for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )</p>
<p>{</p>
<pre><code>h[i] = h[i - 1] * P + str[i];

p[i] = p[i - 1] * P;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; 计算子串 str[l ~ r] 的哈希值</p>
<p>ULL get(int l, int r)</p>
<p>{</p>
<pre><code>return h[r] - h[l - 1] * p[r - l + 1];
</code></pre>
<p>}</p>
<h3 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h3><p>STL容器.png</p>
<p>视频讲解：[100 STL 容器_哔哩哔哩_bilibili]：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1tF411G73c/">https://www.bilibili.com/video/BV1tF411G73c/</a></p>
<p>vector, 变长数组，倍增的思想</p>
<pre><code>size()  返回元素个数

empty()  返回是否为空

clear()  清空

front()/back()

push_back()/pop_back()

begin()/end()

[]

支持比较运算，按字典序
</code></pre>
<p>pair&lt;int, int&gt;</p>
<pre><code>first, 第一个元素

second, 第二个元素

支持比较运算，以first为第一关键字，以second为第二关键字（字典序）
</code></pre>
<p>string，字符串</p>
<pre><code>size()/length()  返回字符串长度

empty()

clear()

substr(起始下标，(子串长度))  返回子串

c_str()  返回字符串所在字符数组的起始地址
</code></pre>
<p>queue, 队列</p>
<pre><code>size()

empty()

push()  向队尾插入一个元素

front()  返回队头元素

back()  返回队尾元素

pop()  弹出队头元素
</code></pre>
<p>priority_queue, 优先队列，默认是大根堆</p>
<pre><code>size()

empty()

push()  插入一个元素

top()  返回堆顶元素

pop()  弹出堆顶元素

定义成小根堆的方式：priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;
</code></pre>
<p>stack, 栈</p>
<pre><code>size()

empty()

push()  向栈顶插入一个元素

top()  返回栈顶元素

pop()  弹出栈顶元素
</code></pre>
<p>deque, 双端队列</p>
<pre><code>size()

empty()

clear()

front()/back()

push_back()/pop_back()

push_front()/pop_front()

begin()/end()

[]
</code></pre>
<p>set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列</p>
<pre><code>size()

empty()

clear()

begin()/end()

++, -- 返回前驱和后继，时间复杂度 O(logn)



set/multiset

    insert()  插入一个数

    find()  查找一个数

    count()  返回某一个数的个数

    erase()

        (1) 输入是一个数x，删除所有x   O(k + logn)

        (2) 输入一个迭代器，删除这个迭代器

    lower_bound()/upper_bound()

        lower_bound(x)  返回大于等于x的最小的数的迭代器

        upper_bound(x)  返回大于x的最小的数的迭代器

map/multimap

    insert()  插入的数是一个pair

    erase()  输入的参数是pair或者迭代器

    find()

    []  注意multimap不支持此操作。 时间复杂度是 O(logn)

    lower_bound()/upper_bound()
</code></pre>
<p>unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表</p>
<pre><code>和上面类似，增删改查的时间复杂度是 O(1)

不支持 lower_bound()/upper_bound()， 迭代器的++，--
</code></pre>
<p>bitset, 圧位</p>
<pre><code>bitset&lt;10000&gt; s;

~, &amp;, |, ^

&gt;&gt;, &lt;&lt;

==, !=

[]



count()  返回有多少个1



any()  判断是否至少有一个1

none()  判断是否全为0



set()  把所有位置成1

set(k, v)  将第k位变成v

reset()  把所有位变成0

flip()  等价于~

flip(k) 把第k位取反
</code></pre>
<h2 id="三、搜索与图论"><a href="#三、搜索与图论" class="headerlink" title="三、搜索与图论"></a>三、搜索与图论</h2><h3 id="树与图的存储"><a href="#树与图的存储" class="headerlink" title="树与图的存储"></a>树与图的存储</h3><p>树是一种特殊的图，与图的存储方式相同。</p>
<p>对于无向图中的边ab，存储两条有向边a-&gt;b, b-&gt;a。</p>
<p>因此我们可以只考虑有向图的存储。</p>
<h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>邻接矩阵：g[a][b] 存储边a-&gt;b的距离</p>
<h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>&#x2F;&#x2F; 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点</p>
<p>int h[N], e[N], ne[N], idx;</p>
<p>&#x2F;&#x2F; 添加一条边a-&gt;b </p>
<p>void add(int a, int b)</p>
<p>{</p>
<pre><code>//存下b的值，b下一个指向a的下个一节点，a的下一个节点指向b

e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; 初始化</p>
<p>idx &#x3D; 0;</p>
<p>memset(h, -1, sizeof h);</p>
<h3 id="树与图的遍历"><a href="#树与图的遍历" class="headerlink" title="树与图的遍历"></a>树与图的遍历</h3><p>时间复杂度O(n+m)，n表示点数，m表示边数</p>
<p>深度优先遍历</p>
<p>int dfs(int u)</p>
<p>{</p>
<pre><code>st[u] = true; // st[u] 表示点u已经被遍历过



for (int i = h[u]; i != -1; i = ne[i])

&#123;

    int j = e[i];

    if (!st[j]) dfs(j);

&#125;
</code></pre>
<p>}</p>
<h3 id="应用：数字全排列"><a href="#应用：数字全排列" class="headerlink" title="应用：数字全排列"></a>应用：数字全排列</h3><p>#include <iostream></p>
<p>using namespace std;</p>
<p>int res[10],b[10],n;</p>
<p>void dfs(int k){</p>
<pre><code>if(k==n)&#123;//k==n则输出n个数字

    for(int i=0;i&lt;n;i++)printf(&quot;%d &quot;,res[i]);

    cout&lt;&lt;endl;

&#125;

for(int i=1;i&lt;=n;i++)&#123;

    if(!b[i])&#123;//判断是否被用过

        res[k]=i;//当前k位存入位置

        b[i]=1;//表示被占用

        dfs(k+1);

        b[i]=0;//恢复现场

    &#125;

&#125;
</code></pre>
<p>}</p>
<p>int main(){</p>
<pre><code>cin&gt;&gt;n;

dfs(0);//从0开始枚举

return 0;
</code></pre>
<p>}</p>
<h3 id="应用：树的重心"><a href="#应用：树的重心" class="headerlink" title="应用：树的重心"></a>应用：树的重心</h3><p>#include <cstdio></p>
<p>#include <cstring></p>
<p>#include <iostream></p>
<p>#include <algorithm></p>
<p>using namespace std;</p>
<p>const int N &#x3D; 100010, M &#x3D; N * 2;&#x2F;&#x2F;无向图n条边时，最多2n个idx，因为每条边在邻接表中会出现两次</p>
<p>int n;&#x2F;&#x2F;n个结点,n-1条边</p>
<p>int h[N], e[M], ne[M], idx;&#x2F;&#x2F;n个链表头，e每一个结点的值，ne每一个结点的next指针</p>
<p>int ans &#x3D; N;&#x2F;&#x2F;最小的最大值</p>
<p>bool st[N];&#x2F;&#x2F;状态数组，防止子节点搜索父节点</p>
<p>void add(int a, int b)&#x2F;&#x2F;a-&gt;b</p>
<p>{&#x2F;&#x2F;e记录当前点的值(地址-&gt;值),ne下一点的地址(地址-&gt;地址)，h记录指向的第一个点的地址(值-&gt;地址)</p>
<pre><code>e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
</code></pre>
<p>}&#x2F;&#x2F;头插法</p>
<p>int dfs(int u)&#x2F;&#x2F;通过h数组找到子结点的向</p>
<p>{</p>
<pre><code>st[u] = true;//st标记当前点被搜过



int size = 0, sum = 0;

//size删掉元素后各个子连通块的最大值

//sum当前子树大小，遍历叶节点时，返回1



for (int i = h[u]; i != -1; i = ne[i])//遍历单链表，链表末端初始化为-1

&#123;

    int j=e[i];

    if(st[j])continue;//此处防逆向dfs

    int s = dfs(j);//s各个子连通块的大小

    size = max(size, s);//size删掉元素后各个连通块的最大值

    sum += s;//各个连通块大小之和

&#125;



size = max(size, n - sum - 1);//判断最大子连通块与父连通块的最大值

ans = min(ans, size);//全局变量ans存最小的最大值
</code></pre>
<p>&#x2F;&#x2F;注意：本题若求最大的最大值，则只需去除任意叶节点即可，即n-1</p>
<pre><code>return sum + 1;//各个子连通块，当前结点之和
</code></pre>
<p>}</p>
<p>int main()</p>
<p>{</p>
<pre><code>scanf(&quot;%d&quot;, &amp;n);



memset(h, -1, sizeof h);//n个头节点全部指向-1



for (int i = 0; i &lt; n - 1; i ++ )//n个结点，n-1条边

&#123;

    int a, b;

    scanf(&quot;%d%d&quot;, &amp;a, &amp;b);

    add(a, b), add(b, a);//不知道子节点还是父节点，所以需要建两条边可以双向查找

&#125;



dfs(1);//结点编号为1~n且可能只有一个结点，则参数只能为1

printf(&quot;%d\n&quot;, ans);

return 0;
</code></pre>
<p>}</p>
<h3 id="应用：n-皇后问题"><a href="#应用：n-皇后问题" class="headerlink" title="应用：n-皇后问题"></a>应用：n-皇后问题</h3><p>n皇后搜索图示</p>
<p>using namespace std;</p>
<p>const int N &#x3D; 11;</p>
<p>char q[N][N];&#x2F;&#x2F;存储棋盘</p>
<p>bool dg[N * 2], udg[N * 2], cor[N];&#x2F;&#x2F;点对应的两个斜线以及列上是否有皇后</p>
<p>int n;</p>
<p>void dfs(int r)</p>
<p>{</p>
<pre><code>if(r == n)//放满了棋盘，输出棋盘

&#123;

    for(int i = 0; i &lt; n; i++)

    &#123;

        for(int j = 0; j &lt; n; j++)

            cout &lt;&lt; q[i][j];

        cout &lt;&lt; endl;

    &#125;

    cout &lt;&lt; endl;

    return;

&#125;



for(int i = 0; i &lt; n; i++)//第 r 行，第 i 列 是否放皇后

&#123;

    if(!cor[i] &amp;&amp; !dg[i + r] &amp;&amp; !udg[n - i + r])//不冲突，放皇后

    &#123;

        q[r][i] = &#39;Q&#39;;

        cor[i] = dg[i + r] = udg[n - i + r] = 1;//对应的 列， 斜线 状态改变

        dfs(r + 1);//处理下一行

        cor[i] = dg[i + r] = udg[n - i + r] = 0;//恢复现场

        q[r][i] = &#39;.&#39;;

    &#125;

&#125;
</code></pre>
<p>}</p>
<p>int main()</p>
<p>{</p>
<pre><code>cin &gt;&gt; n;

for (int i = 0; i &lt; n; i ++ )

    for (int j = 0; j &lt; n; j ++ )

        q[i][j] = &#39;.&#39;;

dfs(0);

return 0;
</code></pre>
<p>}</p>
<h3 id="宽度优先遍历"><a href="#宽度优先遍历" class="headerlink" title="宽度优先遍历"></a>宽度优先遍历</h3><p>queue<int> q;</p>
<p>st[1] &#x3D; true; &#x2F;&#x2F; 表示1号点已经被遍历过</p>
<p>q.push(1);</p>
<p>while (q.size())</p>
<p>{</p>
<pre><code>int t = q.front();

q.pop();



for (int i = h[t]; i != -1; i = ne[i])

&#123;

    int j = e[i];

    if (!st[j])

    &#123;

        st[j] = true; // 表示点j已经被遍历过

        q.push(j);

    &#125;

&#125;
</code></pre>
<p>}</p>
<h3 id="应用：走迷宫"><a href="#应用：走迷宫" class="headerlink" title="应用：走迷宫"></a>应用：走迷宫</h3><p>typedef pair&lt;int,int&gt; PII;&#x2F;&#x2F;声明pair时候必须要在代码前面写上using namespace std;</p>
<p>const int N&#x3D;110;</p>
<p>int g[N][N],f[N][N],n,m;</p>
<p>int bfs(int x,int y){</p>
<pre><code>queue&lt;PII&gt; que;

que.push(&#123;x,y&#125;);

int dx[4]=&#123;0,1,0,-1&#125;,dy[4]=&#123;1,0,-1,0&#125;;

while(!que.empty())&#123;

    PII t=que.front();

    que.pop();

    g[t.first][t.second]=1;

    for(int i=0;i&lt;4;i++)&#123;

        int a=t.first+dx[i],b=t.second+dy[i];

        if(a&gt;=0&amp;&amp;b&gt;=0&amp;&amp;a&lt;n&amp;&amp;b&lt;m&amp;&amp;!g[a][b])&#123;

            g[a][b]=1;

            f[a][b]=f[t.first][t.second]+1;

            que.push(&#123;a,b&#125;);

        &#125;

    &#125;

&#125;

return f[n-1][m-1];
</code></pre>
<p>}</p>
<p>int main(){</p>
<pre><code>scanf(&quot;%d%d&quot;,&amp;n,&amp;m);

for(int i=0;i&lt;n;i++)

    for(int j=0;j&lt;m;j++)

        scanf(&quot;%d&quot;,&amp;g[i][j]);

cout&lt;&lt;bfs(0,0)&lt;&lt;endl;

return 0;
</code></pre>
<p>}</p>
<h3 id="应用：八数码"><a href="#应用：八数码" class="headerlink" title="应用：八数码"></a>应用：八数码</h3><p>using namespace std;</p>
<p>int bfs(string state) {</p>
<pre><code>queue&lt;string&gt; q;

unordered_map&lt;string, int&gt; d;



int dx[4] = &#123;-1, 0, 1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;;

string ed = &quot;12345678x&quot;;

q.push(state);

d[state] = 0;



while (q.size()) &#123;

    auto t = q.front();

    q.pop();

    if (t == ed)//等于结果就输出步数

        return d[t];

    int distance = d[t];

    int k = t.find(&#39;x&#39;);//寻找x

    int x = k / 3, y = k % 3;//计算下标

    for (int i = 0; i &lt; 4; i ++ ) &#123;

        int a = x + dx[i], b = y + dy[i];

        if (a &gt;= 0 &amp;&amp; a &lt; 3 &amp;&amp; b &gt;= 0 &amp;&amp; b &lt; 3) &#123;

            swap(t[a * 3 + b], t[k]);//交换

            if (!d.count(t)) &#123;//不存在就入队

                d[t] = distance + 1;

                q.push(t);

            &#125;

            swap(t[a * 3 + b], t[k]);//还原

        &#125;

    &#125;

&#125;

return -1;
</code></pre>
<p>}</p>
<p>int main() {</p>
<pre><code>char s[2];

string state;

for (int i = 0; i &lt; 9; i ++ ) &#123;

    cin &gt;&gt; s;

    state += *s;

&#125;

cout&lt;&lt;bfs(state)&lt;&lt;endl;

return 0;
</code></pre>
<p>}</p>
<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>啥是拓扑排序？</p>
<p>一个有向图，如果图中有入度为 0 的点，就把这个点删掉，同时也删掉这个点所连的边。</p>
<p>一直进行上面出处理，如果所有点都能被删掉，则这个图可以进行拓扑排序。</p>
<h4 id="纯净版"><a href="#纯净版" class="headerlink" title="纯净版"></a>纯净版</h4><p>bool topsort()</p>
<p>{</p>
<pre><code>int hh = 0, tt = -1;



// d[i] 存储点i的入度

for (int i = 1; i &lt;= n; i ++ )

    if (!d[i])

        q[ ++ tt] = i;



while (hh &lt;= tt)

&#123;

    int t = q[hh ++ ];



    for (int i = h[t]; i != -1; i = ne[i])

    &#123;

        int j = e[i];

        if (-- d[j] == 0)

            q[ ++ tt] = j;

    &#125;

&#125;



// 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。

return tt == n - 1;
</code></pre>
<p>}</p>
<h4 id="解说版"><a href="#解说版" class="headerlink" title="解说版"></a>解说版</h4><p>using namespace std;</p>
<p>const int N &#x3D; 100010;</p>
<p>int e[N], ne[N], idx; &#x2F;&#x2F;邻接表存储图</p>
<p>int h[N];&#x2F;&#x2F;邻接表的每个头链表</p>
<p>int q[N], hh &#x3D; 0, tt &#x3D; -1; &#x2F;&#x2F;队列保存入度为0的点，也就是能够输出的点</p>
<p>int n, m; &#x2F;&#x2F;保存图的点数和边数</p>
<p>int d[N];&#x2F;&#x2F;保存各个点的入度</p>
<p>void add(int a, int b) {</p>
<pre><code>e[idx] = b, ne[idx] = h[a], h[a] = idx++;
</code></pre>
<p>}</p>
<p>void topsort() {</p>
<pre><code>for (int i = 1; i &lt;= n; i++) &#123;//遍历一遍顶点的入度。

    if (!d[i])//如果入度为0，则可以入队列

        q[++tt] = i;

&#125;

while (tt &gt;= hh) &#123; //循环处理队列中点的

    int a = q[hh++];

    for (int i = h[a]; i != -1; i = ne[i]) &#123;

        int b = e[i]; //a 有一条边指向b

        d[b]--;//删除边后，b的入度减1

        if (!d[b])//如果b的入度减为 0,则 b 可以输出，入队列

            q[++tt] = b;

    &#125;

&#125;

if (tt == n - 1) &#123;//如果队列中的点的个数与图中点的个数相同，则可以进行拓扑排序

    for (int i = 0; i &lt; n; i++)//队列中保存了所有入度为0的点，依次输出

        printf(&quot;%d &quot;, q[i]);

&#125; else//如果队列中的点的个数与图中点的个数不相同，则可以进行拓扑排序

    cout &lt;&lt; -1;
</code></pre>
<p>}</p>
<p>int main() {</p>
<pre><code>cin &gt;&gt; n &gt;&gt; m; //保存点的个数和边的个数

memset(h, -1, sizeof h); //初始化领接矩阵

while (m--) &#123; //依次读入边

    int a, b;

    cin &gt;&gt; a &gt;&gt; b;

    d[b]++;//顶点b的入度+1

    add(a, b); //添加到邻接矩阵

&#125;

topsort();//进行拓扑排序

return 0;
</code></pre>
<p>}</p>
<h3 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h3><h4 id="朴素版"><a href="#朴素版" class="headerlink" title="朴素版"></a>朴素版</h4><p>时间复杂是O(n2+m)</p>
<p>，n表示点数，m表示边数</p>
<p>int g[N][N];  &#x2F;&#x2F; 存储每条边</p>
<p>int dist[N];  &#x2F;&#x2F; 存储1号点到每个点的最短距离</p>
<p>bool st[N];   &#x2F;&#x2F; 存储每个点的最短路是否已经确定</p>
<p>&#x2F;&#x2F; 求1号点到n号点的最短路，如果不存在则返回-1</p>
<p>int dijkstra()</p>
<p>{</p>
<pre><code>memset(dist, 0x3f, sizeof dist);

dist[1] = 0;



for (int i = 0; i &lt; n - 1; i ++ )

&#123;

    int t = -1;     // 在还未确定最短路的点中，寻找距离最小的点

    for (int j = 1; j &lt;= n; j ++ )

        if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))

            t = j;



    // 用t更新其他点的距离

    for (int j = 1; j &lt;= n; j ++ )

        dist[j] = min(dist[j], dist[t] + g[t][j]);



    st[t] = true;

&#125;



if (dist[n] == 0x3f3f3f3f) return -1;

return dist[n];
</code></pre>
<p>}</p>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>const int N &#x3D; 510, M &#x3D; 100010;</p>
<p>int h[N], e[M], ne[M], w[M], idx;&#x2F;&#x2F;邻接表存储图</p>
<p>int state[N];&#x2F;&#x2F;state 记录是否找到了源点到该节点的最短距离</p>
<p>int dist[N];&#x2F;&#x2F;dist 数组保存源点到其余各个节点的距离</p>
<p>int n, m;&#x2F;&#x2F;图的节点个数和边数</p>
<p>void add(int a, int b, int c)&#x2F;&#x2F;插入边</p>
<p>{</p>
<pre><code>e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
</code></pre>
<p>}</p>
<p>void Dijkstra()</p>
<p>{</p>
<pre><code>memset(dist, 0x3f, sizeof(dist));//dist 数组的各个元素为无穷大

dist[1] = 0;//源点到源点的距离为置为 0

for (int i = 0; i &lt; n; i++)

&#123;

    int t = -1;

    for (int j = 1; j &lt;= n; j++)//遍历 dist 数组，找到没有确定最短路径的节点中距离源点最近的点t

    &#123;

        if (!state[j] &amp;&amp; (t == -1 || dist[j] &lt; dist[t]))

            t = j;

    &#125;



    state[t] = 1;//state[i] 置为 1。



    for (int j = h[t]; j != -1; j = ne[j])//遍历 t 所有可以到达的节点 i

    &#123;

        int i = e[j];

        dist[i] = min(dist[i], dist[t] + w[j]);//更新 dist[j]

    &#125;





&#125;
</code></pre>
<p>}</p>
<p>int main()</p>
<p>{</p>
<pre><code>memset(h, -1, sizeof(h));//邻接表初始化



cin &gt;&gt; n &gt;&gt; m;

while (m--)//读入 m 条边

&#123;

    int a, b, w;

    cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;

    add(a, b, w);

&#125;



Dijkstra();

if (dist[n] != 0x3f3f3f3f)//如果dist[n]被更新了，则存在路径

    cout &lt;&lt; dist[n];

else

    cout &lt;&lt; &quot;-1&quot;;
</code></pre>
<p>}</p>
<h4 id="堆优化版"><a href="#堆优化版" class="headerlink" title="堆优化版"></a>堆优化版</h4><p>时间复杂度O(mlogn)</p>
<p>，n表示点数，m表示边数</p>
<p>typedef pair&lt;int, int&gt; PII;</p>
<p>int n;      &#x2F;&#x2F; 点的数量</p>
<p>int h[N], w[N], e[N], ne[N], idx;       &#x2F;&#x2F; 邻接表存储所有边</p>
<p>int dist[N];        &#x2F;&#x2F; 存储所有点到1号点的距离</p>
<p>bool st[N];     &#x2F;&#x2F; 存储每个点的最短距离是否已确定</p>
<p>&#x2F;&#x2F; 求1号点到n号点的最短距离，如果不存在，则返回-1</p>
<p>int dijkstra(){</p>
<pre><code>memset(dist,0x3f,sizeof dist);//距离初始化为无穷大

dist[1]=0;//1-&gt;1的节点距离为0

priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt; heap;//小根堆

heap.push(&#123;0,1&#125;);//插入距离和节点编号



while(heap.size())&#123;

    auto t=heap.top();//取距离源点最近的点

    heap.pop();



    int ver=t.second,distance=t.first;//ver：节点编号，distance源点距离ver

    if(st[ver])continue;//如果距离已经确定，则跳过该点

    st[ver]=true;

    for(int i=h[ver];i!=-1;i=ne[i])//更新ver所指向的节点距离

    &#123;

        int j=e[i];

        if(dist[j]&gt;dist[ver]+w[i])&#123;

            dist[j]=dist[ver]+w[i];

            heap.push(&#123;dist[j],j&#125;);//距离变小，则入堆

        &#125;

    &#125;

&#125;

if(dist[n]==0x3f3f3f3f)return -1;

return dist[n];
</code></pre>
<p>}</p>
<h4 id="关于Dijkstra的相关博客链接："><a href="#关于Dijkstra的相关博客链接：" class="headerlink" title="关于Dijkstra的相关博客链接："></a>关于Dijkstra的相关博客链接：</h4><p>[AcWing 849. Dijkstra求最短路 I：图解 详细代码（图解） - AcWing：<a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/38318/">https://www.acwing.com/solution/content/38318/</a></p>
<p>[AcWing 850. Dijkstra求最短路 II：详解+代码注释 - AcWing]：<a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/38323/">https://www.acwing.com/solution/content/38323/</a></p>
<h3 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman-Ford算法"></a>Bellman-Ford算法</h3><p>时间复杂度O(nm)，n表示点数，m表示边数</p>
<p>注意在模板题中需要对下面的模板稍作修改，加上备份数组，详情见模板题。</p>
<p>Bellman-ford算法动态规划图示.png</p>
<p>上图为Bellman-ford草稿图</p>
<p>int n, m;       &#x2F;&#x2F; n表示点数，m表示边数</p>
<p>int dist[N],backup[N];        &#x2F;&#x2F; dist[x]存储1到x的最短路距离</p>
<p>struct Edge     &#x2F;&#x2F; 边，a表示出点，b表示入点，w表示边的权重</p>
<p>{</p>
<pre><code>int a, b, w;
</code></pre>
<p>}edges[M];</p>
<p>&#x2F;&#x2F; 求1到n的最短路距离，如果无法从1走到n，则返回-1。</p>
<p>int bellman_ford()</p>
<p>{</p>
<pre><code>memset(dist, 0x3f, sizeof dist);

dist[1] = 0;



// 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。

for (int i = 0; i &lt; n; i ++ )

&#123;

    memcpy(back,dist,sizeof dist);

    for (int j = 0; j &lt; m; j ++ )

    &#123;

        int a = edges[j].a, b = edges[j].b, w = edges[j].w;

        if (dist[b] &gt; backup[a] + w)

            dist[b] = backup[a] + w;

    &#125;

&#125;



if (dist[n] &gt; 0x3f3f3f3f / 2) return -1;

return dist[n];
</code></pre>
<p>}</p>
<h4 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h4><p>int n,m,k;</p>
<p>const int N&#x3D;512,M&#x3D;10012;</p>
<p>struct Edge{</p>
<pre><code>int a,b,w;
</code></pre>
<p>}e[M];</p>
<p>int dist[N];</p>
<p>int back[N];</p>
<p>void bellman_ford(){</p>
<pre><code>memset(dist,0x3f,sizeof dist);

dist[1]=0;

for(int i=0;i&lt;k;i++)&#123;

    memcpy(back,dist,sizeof dist);

    for(int j=0;j&lt;m;j++)&#123;

        int a=e[j].a,b=e[j].b,c=e[j].w;

        dist[b]=min(dist[b],back[a]+c);

    &#125;

&#125;
</code></pre>
<p>}</p>
<p>int main(){</p>
<pre><code>scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k);

for(int i=0;i&lt;m;i++)&#123;

    int a,b,w;

    scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;w);

    e[i]=&#123;a,b,w&#125;;

&#125;

bellman_ford();

if(dist[n]&gt;0x3f3f3f3f/2)cout&lt;&lt;&quot;impossible&quot;&lt;&lt;endl;

else cout&lt;&lt;dist[n]&lt;&lt;endl;

return 0;
</code></pre>
<p>}</p>
<p>问题：为什么把每一条边用不等式刷k次就是k条件下的值？</p>
<p>你可以想象这个图是1-&gt;2-&gt;3-&gt;4….-&gt;n这样一条直线。比如说第一次迭代，为什么只有与原点相连的点才能被更新dist呢？因为原点的dist是0，其他点的dist是+∞，满足dist[2] &gt; dist[1]+c，而+∞并不&gt;+∞+c，所以第一次迭代结束就是不超过一条边走到i节点最短路的距离，依次类推，第二次迭代，只有3会被更新，因为只有1、2的dist不是+∞，第二次迭代就是不超过2条边走到i节点的最短距离。这就是为什么k次迭代最多是走了k条边，同时也是为什么一共只用迭代n-1次，因为n个点的有向图，如果能走到，原点到n号点的最短距离最多是n-1次，也就是1-&gt;2-&gt;…-&gt;n直线这种。</p>
<h3 id="SPFA算法（队列优化的Bellman-Ford算法）"><a href="#SPFA算法（队列优化的Bellman-Ford算法）" class="headerlink" title="SPFA算法（队列优化的Bellman-Ford算法）"></a>SPFA算法（队列优化的Bellman-Ford算法）</h3><p>时间复杂度平均情况下O(m)，最坏情况下O(nm)，n表示点数，m表示边数</p>
<p>模板</p>
<p>int n;      &#x2F;&#x2F; 总点数</p>
<p>int h[N], w[N], e[N], ne[N], idx;       &#x2F;&#x2F; 邻接表存储所有边</p>
<p>int dist[N];        &#x2F;&#x2F; 存储每个点到1号点的最短距离</p>
<p>bool st[N];     &#x2F;&#x2F; 存储每个点是否在队列中</p>
<p>&#x2F;&#x2F; 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1</p>
<p>int spfa()</p>
<p>{</p>
<pre><code>memset(dist, 0x3f, sizeof dist);

dist[1] = 0;



queue&lt;int&gt; q;

q.push(1);

st[1] = true;



while (q.size())

&#123;

    auto t = q.front();

    q.pop();



    st[t] = false;



    for (int i = h[t]; i != -1; i = ne[i])

    &#123;

        int j = e[i];

        if (dist[j] &gt; dist[t] + w[i])

        &#123;

            dist[j] = dist[t] + w[i];

            if (!st[j])     // 如果队列中已存在j，则不需要将j重复插入

            &#123;

                q.push(j);

                st[j] = true;

            &#125;

        &#125;

    &#125;

&#125;



if (dist[n] == 0x3f3f3f3f) return -1;

return dist[n];
</code></pre>
<p>}</p>
<h4 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h4><p>const int N &#x3D; 1e6 + 10;</p>
<p>int n, m;&#x2F;&#x2F;节点数量和边数</p>
<p>int h[N], w[N], e[N], ne[N], idx;&#x2F;&#x2F;邻接矩阵存储图</p>
<p>int dist[N];&#x2F;&#x2F;存储距离</p>
<p>bool st[N];&#x2F;&#x2F;存储状态</p>
<p>void add(int a, int b, int c)</p>
<p>{</p>
<pre><code>e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
</code></pre>
<p>}</p>
<p>int spfa()</p>
<p>{</p>
<pre><code>memset(dist, 0x3f, sizeof dist);//距离初始化为无穷大

dist[1] = 0;//初始化1到1的距离为0

queue&lt;int&gt; que;//队列

que.push(1);//1入队



while (que.size())//判断是否存在

&#123;

    int t=que.front();

    que.pop();//获取第一个并出队

    st[t]=false;//第一个取消占用

    for(int i=h[t];i!=-1;i=ne[i])&#123;//遍历第一个可以到达的结点

        int j=e[i];

        if(dist[j]&gt;dist[t]+w[i])&#123;//1号点可到达的节点距离是否大于上次的距离距离加上当前的距离

            dist[j]=dist[t]+w[i];//赋值给可到达的节点

            if(!st[j])&#123;//如果可到达的节点未被占用

                que.push(j);//则入队

                st[j]=true;//占用

            &#125;

        &#125;

    &#125;

&#125;



return dist[n];
</code></pre>
<p>}</p>
<p>int main()</p>
<p>{</p>
<pre><code>scanf(&quot;%d%d&quot;, &amp;n, &amp;m);



memset(h, -1, sizeof h);

while (m -- )

&#123;

    int a, b, c;

    scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);

    add(a, b, c);

&#125;



int t=spfa();

if(t==0x3f3f3f3f)cout&lt;&lt;&quot;impossible&quot;&lt;&lt;endl;

else printf(&quot;%d\n&quot;,t);



return 0;
</code></pre>
<p>}</p>
<h4 id="应用：spfa判断图中是否存在负权"><a href="#应用：spfa判断图中是否存在负权" class="headerlink" title="应用：spfa判断图中是否存在负权"></a>应用：spfa判断图中是否存在负权</h4><p>int n;      &#x2F;&#x2F; 总点数</p>
<p>int h[N], w[N], e[N], ne[N], idx;       &#x2F;&#x2F; 邻接表存储所有边</p>
<p>int dist[N], cnt[N];        &#x2F;&#x2F; dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数</p>
<p>bool st[N];     &#x2F;&#x2F; 存储每个点是否在队列中</p>
<p>&#x2F;&#x2F; 如果存在负环，则返回true，否则返回false。</p>
<p>bool spfa()</p>
<p>{</p>
<pre><code>// 不需要初始化dist数组

// 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。



queue&lt;int&gt; q;

for (int i = 1; i &lt;= n; i ++ )

&#123;

    q.push(i);

    st[i] = true;

&#125;



while (q.size())

&#123;

    auto t = q.front();

    q.pop();



    st[t] = false;



    for (int i = h[t]; i != -1; i = ne[i])

    &#123;

        int j = e[i];

        if (dist[j] &gt; dist[t] + w[i])

        &#123;

            dist[j] = dist[t] + w[i];

            cnt[j] = cnt[t] + 1;

            if (cnt[j] &gt;= n) return true;       // 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环

            if (!st[j])

            &#123;

                q.push(j);

                st[j] = true;

            &#125;

        &#125;

    &#125;

&#125;



return false;
</code></pre>
<p>}</p>
<h3 id="floyd算法"><a href="#floyd算法" class="headerlink" title="floyd算法"></a>floyd算法</h3><p>时间复杂度O(n3)，n表示点数</p>
<p>视频讲解：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV14R4y1x7GB/">https://www.bilibili.com/video/BV14R4y1x7GB/</a></p>
<p>模板</p>
<p>初始化：</p>
<pre><code>for (int i = 1; i &lt;= n; i ++ )

    for (int j = 1; j &lt;= n; j ++ )

        if (i == j) d[i][j] = 0;

        else d[i][j] = INF;
</code></pre>
<p>&#x2F;&#x2F; 算法结束后，d[a][b]表示a到b的最短距离</p>
<p>void floyd()</p>
<p>{</p>
<pre><code>for (int k = 1; k &lt;= n; k ++ )//k为中转节点

    for (int i = 1; i &lt;= n; i ++ )

        for (int j = 1; j &lt;= n; j ++ )

            d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
</code></pre>
<p>}</p>
<p>应用</p>
<p>using namespace std;</p>
<p>const int N &#x3D; 210, INF &#x3D; 1e9;</p>
<p>int n, m, Q;</p>
<p>int d[N][N];</p>
<p>void floyd()</p>
<p>{</p>
<pre><code>for (int k = 1; k &lt;= n; k ++ )//k为中转节点

    for (int i = 1; i &lt;= n; i ++ )

        for (int j = 1; j &lt;= n; j ++ )

            d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
</code></pre>
<p>}</p>
<p>int main()</p>
<p>{</p>
<pre><code>scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;Q);



for (int i = 1; i &lt;= n; i ++ )

    for (int j = 1; j &lt;= n; j ++ )

        if (i == j) d[i][j] = 0;

        else d[i][j] = INF;



while (m -- )

&#123;

    int a, b, c;

    scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);

    d[a][b] = min(d[a][b], c);

&#125;



floyd();



while (Q -- )

&#123;

    int a, b;

    scanf(&quot;%d%d&quot;, &amp;a, &amp;b);



    int t = d[a][b];

    if (t &gt; INF / 2) puts(&quot;impossible&quot;);

    else printf(&quot;%d\n&quot;, t);

&#125;



return 0;
</code></pre>
<p>}</p>
<h3 id="最短路算法总结"><a href="#最短路算法总结" class="headerlink" title="最短路算法总结"></a>最短路算法总结</h3><p>最短路</p>
<p>单源最短路：给定V中的一个顶点，称为源。要计算从源到其他所有各顶点的最短路径长度。这里的长度就是指路上各边权之和。这个问题通常称为单源最短路径 问题。</p>
<p>所有边权都是正数：</p>
<p>朴素Dijkstra算法 O(n^2) 适合稠密图，贪心思想</p>
<p>堆优化版的Dijkstra算法 O(mlogn)适合稀疏图，贪心思想</p>
<p>​ 存在负权边：</p>
<p>​ Bellman-ford O(nm)，动态规划思想</p>
<p>​ SPFA 一般：O(m)，最坏O(nm)</p>
<p>多源汇最短路：任意两点最短路径被称为多源最短路径，即给定任意两个点，一个出发点，一个到达点，求这两个点的之间的最短路径，就是任意两点最短路径问题</p>
<p>Floyd算法 O(n^3)</p>
<h3 id="prim算法"><a href="#prim算法" class="headerlink" title="prim算法"></a>prim算法</h3><p>时间复杂度是O(n2+m)，n表示点数，m表示边数</p>
<p>int n;      &#x2F;&#x2F; n表示点数</p>
<p>int g[N][N];        &#x2F;&#x2F; 邻接矩阵，存储所有边</p>
<p>int dist[N];        &#x2F;&#x2F; 存储其他点到当前最小生成树的距离</p>
<p>bool st[N];     &#x2F;&#x2F; 存储每个点是否已经在生成树中</p>
<p>&#x2F;&#x2F; 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和</p>
<p>int prim()</p>
<p>{</p>
<pre><code>memset(dist, 0x3f, sizeof dist);



int res = 0;

for (int i = 0; i &lt; n; i ++ )

&#123;

    int t = -1;

    for (int j = 1; j &lt;= n; j ++ )

        if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))

            t = j;



    if (i &amp;&amp; dist[t] == INF) return INF;



    if (i) res += dist[t];

    st[t] = true;



    for (int j = 1; j &lt;= n; j ++ ) dist[j] = min(dist[j], g[t][j]);

&#125;



return res;
</code></pre>
<p>}</p>
<p>应用</p>
<p>const int N &#x3D; 510, INF &#x3D; 0x3f3f3f3f;</p>
<p>int n, m;</p>
<p>int g[N][N];</p>
<p>int dist[N];</p>
<p>bool st[N];</p>
<p>int prim()</p>
<p>{</p>
<pre><code>memset(dist, 0x3f, sizeof dist);



int res = 0;

for (int i = 0; i &lt; n; i ++ )

&#123;

    int t = -1;

    for (int j = 1; j &lt;= n; j ++ )

        if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))

            t = j;



    if (i &amp;&amp; dist[t] == INF) return INF;



    if (i) res += dist[t];

    st[t] = true;



    for (int j = 1; j &lt;= n; j ++ ) dist[j] = min(dist[j], g[t][j]);

&#125;



return res;
</code></pre>
<p>}</p>
<p>int main()</p>
<p>{</p>
<pre><code>scanf(&quot;%d%d&quot;, &amp;n, &amp;m);



memset(g, 0x3f, sizeof g);



while (m -- )

&#123;

    int a, b, c;

    scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);

    g[a][b] = g[b][a] = min(g[a][b], c);

&#125;



int t = prim();



if (t == INF) puts(&quot;impossible&quot;);

else printf(&quot;%d\n&quot;, t);



return 0;
</code></pre>
<p>}</p>
<h3 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h3><p>时间复杂度O(mlogm)，n表示点数，m表示边数</p>
<p>int n, m;       &#x2F;&#x2F; n是点数，m是边数</p>
<p>int p[N];       &#x2F;&#x2F; 并查集的父节点数组</p>
<p>struct Edge     &#x2F;&#x2F; 存储边</p>
<p>{</p>
<pre><code>int a, b, w;

bool operator&lt; (const Edge &amp;W)const

&#123;

    return w &lt; W.w;

&#125;
</code></pre>
<p>}edges[M];</p>
<p>int find(int x)     &#x2F;&#x2F; 并查集核心操作</p>
<p>{</p>
<pre><code>if (p[x] != x) p[x] = find(p[x]);

return p[x];
</code></pre>
<p>}</p>
<p>int kruskal()</p>
<p>{</p>
<pre><code>sort(edges, edges + m);



for (int i = 1; i &lt;= n; i ++ ) p[i] = i;    // 初始化并查集



int res = 0, cnt = 0;

for (int i = 0; i &lt; m; i ++ )

&#123;

    int a = edges[i].a, b = edges[i].b, w = edges[i].w;



    a = find(a), b = find(b);

    if (a != b)     // 如果两个连通块不连通，则将这两个连通块合并

    &#123;

        p[a] = b;

        res += w;

        cnt ++ ;

    &#125;

&#125;

if (cnt &lt; n - 1) return INF;

return res;
</code></pre>
<p>}</p>
<p>应用</p>
<p>#include <cstring></p>
<p>#include <iostream></p>
<p>#include <algorithm></p>
<p>using namespace std;</p>
<p>const int N &#x3D; 100010, M &#x3D; 200010, INF &#x3D; 0x3f3f3f3f;</p>
<p>int n, m;</p>
<p>int p[N];</p>
<p>struct Edge</p>
<p>{</p>
<pre><code>int a, b, w;



bool operator&lt; (const Edge &amp;W)const

&#123;

    return w &lt; W.w;

&#125;
</code></pre>
<p>}edges[M];</p>
<p>int find(int x)</p>
<p>{</p>
<pre><code>if (p[x] != x) p[x] = find(p[x]);

return p[x];
</code></pre>
<p>}</p>
<p>int kruskal()</p>
<p>{</p>
<pre><code>sort(edges, edges + m);



for (int i = 1; i &lt;= n; i ++ ) p[i] = i;    // 初始化并查集



int res = 0, cnt = 0;

for (int i = 0; i &lt; m; i ++ )

&#123;

    int a = edges[i].a, b = edges[i].b, w = edges[i].w;



    a = find(a), b = find(b);

    if (a != b)

    &#123;

        p[a] = b;

        res += w;

        cnt ++ ;

    &#125;

&#125;



if (cnt &lt; n - 1) return INF;

return res;
</code></pre>
<p>}</p>
<p>int main()</p>
<p>{</p>
<pre><code>scanf(&quot;%d%d&quot;, &amp;n, &amp;m);



for (int i = 0; i &lt; m; i ++ )

&#123;

    int a, b, w;

    scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;w);

    edges[i] = &#123;a, b, w&#125;;

&#125;



int t = kruskal();



if (t == INF) puts(&quot;impossible&quot;);

else printf(&quot;%d\n&quot;, t);



return 0;
</code></pre>
<p>}</p>
<h3 id="染色法判别二分图"><a href="#染色法判别二分图" class="headerlink" title="染色法判别二分图"></a>染色法判别二分图</h3><p>什么叫二分图</p>
<p>有两顶点集且图中每条边的的两个顶点分别位于两个顶点集中，每个顶点集中没有边直接相连接！</p>
<p>说人话的定义：图中点通过移动能分成左右两部分，左侧的点只和右侧的点相连，右侧的点只和左侧的点相连。</p>
<p>下图就是个二分图：</p>
<p>时间复杂度是O(n+m)，n表示点数，m表示边数</p>
<p>int n;      &#x2F;&#x2F; n表示点数</p>
<p>int h[N], e[M], ne[M], idx;     &#x2F;&#x2F; 邻接表存储图</p>
<p>int color[N];       &#x2F;&#x2F; 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色</p>
<p>&#x2F;&#x2F; 参数：u表示当前节点，c表示当前点的颜色</p>
<p>bool dfs(int u, int c)</p>
<p>{</p>
<pre><code>color[u] = c;

for (int i = h[u]; i != -1; i = ne[i])

&#123;

    int j = e[i];

    if (color[j] == -1)

    &#123;

        if (!dfs(j, !c)) return false;

    &#125;

    else if (color[j] == c) return false;

&#125;



return true;
</code></pre>
<p>}</p>
<p>bool check()</p>
<p>{</p>
<pre><code>memset(color, -1, sizeof color);

bool flag = true;

for (int i = 1; i &lt;= n; i ++ )

    if (color[i] == -1)

        if (!dfs(i, 0))

        &#123;

            flag = false;

            break;

        &#125;

return flag;
</code></pre>
<p>}</p>
<h4 id="应用-3"><a href="#应用-3" class="headerlink" title="应用"></a>应用</h4><p>using namespace std;</p>
<p>const int N &#x3D; 100010, M &#x3D; 200010;&#x2F;&#x2F; 由于是无向图, 顶点数最大是N，那么边数M最大是顶点数的2倍</p>
<p>int n, m;</p>
<p>int h[N], e[M], ne[M], idx;</p>
<p>int color[N];</p>
<p>void add(int a, int b)</p>
<p>{</p>
<pre><code>e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
</code></pre>
<p>}</p>
<p>bool dfs(int u, int c)</p>
<p>{</p>
<pre><code>color[u] = c;



for (int i = h[u]; i != -1; i = ne[i])

&#123;

    int j = e[i];

    if (!color[j])

    &#123;

        if (!dfs(j, 3 - c)) return false;

    &#125;

    else if (color[j] == c) return false;

&#125;



return true;
</code></pre>
<p>}</p>
<p>int main()</p>
<p>{</p>
<pre><code>scanf(&quot;%d%d&quot;, &amp;n, &amp;m);



memset(h, -1, sizeof h);



while (m -- )

&#123;

    int a, b;

    scanf(&quot;%d%d&quot;, &amp;a, &amp;b);

    add(a, b), add(b, a);// 无向图，a-&gt;b, b-&gt;a

&#125;



bool flag = true;

for (int i = 1; i &lt;= n; i ++ )

    if (!color[i])

    &#123;

        if (!dfs(i, 1))

        &#123;

            flag = false;

            break;

        &#125;

    &#125;



if (flag) puts(&quot;Yes&quot;);

else puts(&quot;No&quot;);



return 0;
</code></pre>
<p>}</p>
<h3 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h3><p>要了解匈牙利算法必须先理解下面的概念：</p>
<p>匹配：在图论中，一个「匹配」是一个边的集合，其中任意两条边都没有公共顶点。</p>
<p>最大匹配：一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配。</p>
<p>下面是一些补充概念：</p>
<p>完美匹配：如果一个图的某个匹配中，所有的顶点都是匹配点，那么它就是一个完美匹配。</p>
<p>交替路：从一个未匹配点出发，依次经过非匹配边、匹配边、非匹配边…形成的路径叫交替路。</p>
<p>增广路：从一个未匹配点出发，走交替路，如果途径另一个未匹配点（出发的点不算），则这条交替 路称为增广路（agumenting path）。</p>
<p>时间复杂度O(nm)，n表示点数，m表示边数</p>
<p>&#x2F;&#x2F;遍历自己喜欢的女孩int n1, n2;     &#x2F;&#x2F; n1表示第一个集合中的点数，n2表示第二个集合中的点数</p>
<p>int h[N], e[M], ne[M], idx;     &#x2F;&#x2F; 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边</p>
<p>int match[N];       &#x2F;&#x2F; 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个</p>
<p>bool st[N];     &#x2F;&#x2F; 表示第二个集合中的每个点是否已经被遍历过</p>
<p>void add(int a, int b)</p>
<p>{</p>
<pre><code>e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
</code></pre>
<p>}</p>
<p>bool find(int x)</p>
<p>{</p>
<pre><code>//遍历自己喜欢的女孩

for (int i = h[x]; i != -1; i = ne[i])

&#123;

    int j = e[i];

    if (!st[j])//如果在这一轮模拟匹配中,这个女孩尚未被预定

    &#123;

        st[j] = true;//那x就预定这个女孩了

        //如果女孩j没有男朋友，或者她原来的男朋友能够预定其它喜欢的女孩。配对成功

        if (match[j] == 0 || find(match[j]))

        &#123;

            match[j] = x;

            return true;

        &#125;

    &#125;

&#125;

//自己中意的全部都被预定了。配对失败。

return false;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点</p>
<p>int res &#x3D; 0;</p>
<p>for (int i &#x3D; 1; i &lt;&#x3D; n1; i ++ )</p>
<p>{</p>
<pre><code>memset(st, false, sizeof st);

if (find(i)) res ++ ;
</code></pre>
<p>}</p>
<p>应用：二分图的最大匹配</p>
<p>匈牙利算法图示化</p>
<p>相关题解：[AcWing 861. 二分图的最大匹配—-图解 - AcWing]：<a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/179030/">https://www.acwing.com/solution/content/179030/</a></p>
<p>using namespace std;</p>
<p>const int N &#x3D; 510, M &#x3D; 100010;</p>
<p>int n1, n2, m;</p>
<p>int h[N], e[M], ne[M], idx;</p>
<p>int match[N];</p>
<p>bool st[N];</p>
<p>void add(int a, int b)</p>
<p>{</p>
<pre><code>e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
</code></pre>
<p>}</p>
<p>bool find(int x)</p>
<p>{</p>
<pre><code> // 和各个点尝试能否匹配

for (int i = h[x]; i != -1; i = ne[i])

&#123;

    int j = e[i];

    if (!st[j])//打标记

    &#123;

        st[j] = true;

        // 当前尝试点没有被匹配或者和当前尝试点匹配的那个点可以换另一个匹配

        if (match[j] == 0 || find(match[j]))

        &#123;

            // 和当前尝试点匹配在一起

            match[j] = x;

            return true;

        &#125;

    &#125;

&#125;

return false;
</code></pre>
<p>}</p>
<p>int main()</p>
<p>{</p>
<pre><code>scanf(&quot;%d%d%d&quot;, &amp;n1, &amp;n2, &amp;m);



memset(h, -1, sizeof h);

// 保存图，因为只从一遍找另一边，所以该无向图只需要存储一个方向

while (m -- )

&#123;

    int a, b;

    scanf(&quot;%d%d&quot;, &amp;a, &amp;b);

    add(a, b);

&#125;



int res = 0;

//为各个点找匹配

for (int i = 1; i &lt;= n1; i ++ )

&#123;

    memset(st, false, sizeof st);

    //找到匹配

    if (find(i)) res ++ ;

&#125;



printf(&quot;%d\n&quot;, res);



return 0;
</code></pre>
<p>}</p>
<h2 id="四、数学知识"><a href="#四、数学知识" class="headerlink" title="四、数学知识"></a>四、数学知识</h2><p>算法的数学知识定理证明可以在这里查阅：[数学部分简介 - OI Wiki (oi-wiki.org)]：<a target="_blank" rel="noopener" href="https://oi-wiki.org/math/">https://oi-wiki.org/math/</a></p>
<h3 id="试除法判定质数"><a href="#试除法判定质数" class="headerlink" title="试除法判定质数"></a>试除法判定质数</h3><p>bool is_prime(int x)</p>
<p>{</p>
<pre><code>if (x &lt; 2) return false;

for (int i = 2; i &lt;= x / i; i ++ )

    if (x % i == 0)

        return false;

return true;
</code></pre>
<p>}</p>
<h3 id="试除法分解质因数"><a href="#试除法分解质因数" class="headerlink" title="试除法分解质因数"></a>试除法分解质因数</h3><p>void divide(int x)</p>
<p>{</p>
<pre><code>for (int i = 2; i &lt;= x / i; i ++ )

    if (x % i == 0)//i 一定是质数

    &#123;

        int s = 0;

        while (x % i == 0) x /= i, s ++ ;

        cout &lt;&lt; i &lt;&lt; &#39; &#39; &lt;&lt; s &lt;&lt; endl;

    &#125;

if (x &gt; 1) cout &lt;&lt; x &lt;&lt; &#39; &#39; &lt;&lt; 1 &lt;&lt; endl;

cout &lt;&lt; endl;
</code></pre>
<p>}</p>
<h3 id="埃氏筛法求质数"><a href="#埃氏筛法求质数" class="headerlink" title="埃氏筛法求质数"></a>埃氏筛法求质数</h3><p>int primes[N], cnt;     &#x2F;&#x2F; primes[]存储所有素数</p>
<p>bool st[N];         &#x2F;&#x2F; st[x]存储x是否被筛掉</p>
<p>void get_primes(int n)</p>
<p>{</p>
<pre><code>for (int i = 2; i &lt;= n; i ++ )

&#123;

    if (st[i]) continue;

    primes[cnt ++ ] = i;

    for (int j = i + i; j &lt;= n; j += i)

        st[j] = true;

&#125;
</code></pre>
<p>}</p>
<h3 id="线性筛法求质数"><a href="#线性筛法求质数" class="headerlink" title="线性筛法求质数"></a>线性筛法求质数</h3><p>算法动画讲解：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1LR4y1Z7pm">https://www.bilibili.com/video/BV1LR4y1Z7pm</a></p>
<p>int primes[N], cnt;     &#x2F;&#x2F; primes[]存储所有素数</p>
<p>bool st[N];         &#x2F;&#x2F; st[x]存储x是否被筛掉</p>
<p>void get_primes(int n)</p>
<p>{</p>
<pre><code>for (int i = 2; i &lt;= n; i ++ )

&#123;

    if (!st[i]) primes[cnt ++ ] = i;

    for (int j = 0; primes[j] &lt;= n / i; j ++ )

    &#123;

        st[primes[j] * i] = true;

        if (i % primes[j] == 0) break;

    &#125;

&#125;
</code></pre>
<p>}</p>
<h3 id="试除法求所有约数"><a href="#试除法求所有约数" class="headerlink" title="试除法求所有约数"></a>试除法求所有约数</h3><p>vector<int> get_divisors(int x)</p>
<p>{</p>
<pre><code>vector&lt;int&gt; res;

for (int i = 1; i &lt;= x / i; i ++ )

    if (x % i == 0)

    &#123;

        res.push_back(i);

        if (i != x / i) res.push_back(x / i);

    &#125;

sort(res.begin(), res.end());

return res;
</code></pre>
<p>}</p>
<h3 id="约数个数"><a href="#约数个数" class="headerlink" title="约数个数"></a>约数个数</h3><p><strong>约数个数定理和约数和定理公式推导</strong>：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV13R4y1o777">https://www.bilibili.com/video/BV13R4y1o777</a></p>
<p><strong>约数个数定理推导</strong>：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1NY41187GM">https://www.bilibili.com/video/BV1NY41187GM</a></p>
<p>约数个数.png</p>
<p>using namespace std;</p>
<p>typedef long long LL;</p>
<p>const int N &#x3D; 110, mod &#x3D; 1e9 + 7;</p>
<p>int main()</p>
<p>{</p>
<pre><code>int n;

cin &gt;&gt; n;

unordered_map&lt;int, int&gt; primes;

while (n -- )

&#123;

    int x;

    cin &gt;&gt; x;

    for (int i = 2; i &lt;= x / i; i ++ )

        while (x % i == 0)

        &#123;

            x /= i;

            primes[i] ++ ;

        &#125;

    if (x &gt; 1) primes[x] ++ ;

&#125;

LL res = 1;

for (auto p : primes) res = res * (p.second + 1) % mod;

cout &lt;&lt; res &lt;&lt; endl;

return 0;
</code></pre>
<p>}</p>
<h3 id="约数之和"><a href="#约数之和" class="headerlink" title="约数之和"></a>约数之和</h3><p><strong>约数个数定理和约数和定理公式推导</strong>：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV13R4y1o777">https://www.bilibili.com/video/BV13R4y1o777</a></p>
<p>约数之和.png</p>
<p>using namespace std;</p>
<p>typedef long long LL;</p>
<p>const int N &#x3D; 110, mod &#x3D; 1e9 + 7;</p>
<p>int main()</p>
<p>{</p>
<pre><code>int n;

cin &gt;&gt; n;

unordered_map&lt;int, int&gt; primes;

while (n -- )

&#123;

    int x;

    cin &gt;&gt; x;

    for (int i = 2; i &lt;= x / i; i ++ )

        while (x % i == 0)

        &#123;

            x /= i;

            primes[i] ++ ;

        &#125;

    if (x &gt; 1) primes[x] ++ ;

&#125;

LL res = 1;

for (auto p : primes)

&#123;

    LL a = p.first, b = p.second;

    LL t = 1;

    while (b -- ) t = (t * a + 1) % mod;//遍历b次后得到t=p^b+p^(b-1)+...+p+1

    res = res * t % mod;

&#125;

cout &lt;&lt; res &lt;&lt; endl;

return 0;
</code></pre>
<p>}</p>
<p>代码第26行解释：</p>
<p>约数之和小公式推导.png</p>
<h3 id="欧几里得算法-求最大公约数"><a href="#欧几里得算法-求最大公约数" class="headerlink" title="欧几里得算法(求最大公约数)"></a>欧几里得算法(求最大公约数)</h3><p>int gcd(int a, int b)</p>
<p>{</p>
<pre><code>return b ? gcd(b, a % b) : a;
</code></pre>
<p>}</p>
<h3 id="最小公倍数"><a href="#最小公倍数" class="headerlink" title="最小公倍数"></a>最小公倍数</h3><p>int lcm(int a, int b)</p>
<p>{</p>
<pre><code>return abs(a * b) / gcd(a, b);
</code></pre>
<p>}</p>
<h3 id="求欧拉函数"><a href="#求欧拉函数" class="headerlink" title="求欧拉函数"></a>求欧拉函数</h3><p>前置知识</p>
<p>互质：互质是公约数只有1的两个整数，叫做互质整数。</p>
<p>欧拉函数定义</p>
<p>1∼N−1</p>
<p>中与N互质的数的个数被称为欧拉函数，记为ϕ(N)。</p>
<p>若在算数基本定理中，N&#x3D;pa11pa22…pamm，则：</p>
<p>ϕ(N)&#x3D;N⋅p1−1p1⋅p2−1p2⋅…⋅pm−1pm</p>
<p>欧拉函数推导</p>
<p>首先我们要知道1,2,3…N−1,N与N互质的个数是1∼N数列去除N的质因子的倍数。</p>
<p>例如N&#x3D;10,即1,2,3,4,5,6,7,8,9,10去除N的质因子的倍数,</p>
<p>则1,\bcancel2,3,\bcancel4,\bcancel5,\bcancel6,7,\bcancel8,9,\bcancel10.</p>
<p>显然，1,3,7,9与10互质。</p>
<p>由上方结论使用容斥原理进行数学推导如下：</p>
<h4 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h4><p>int phi(int x)</p>
<p>{</p>
<pre><code>int res = x;

for (int i = 2; i &lt;= x / i; i ++ )

    if (x % i == 0)

    &#123;

        res = res / i * (i - 1);

        while (x % i == 0) x /= i;

    &#125;

if (x &gt; 1) res = res / x * (x - 1);



return res;
</code></pre>
<p>}</p>
<h3 id="线性筛法求欧拉函数"><a href="#线性筛法求欧拉函数" class="headerlink" title="线性筛法求欧拉函数"></a>线性筛法求欧拉函数</h3><p>int primes[N], cnt;     &#x2F;&#x2F; primes[]存储所有素数</p>
<p>int euler[N];           &#x2F;&#x2F; 存储每个数的欧拉函数</p>
<p>bool st[N];         &#x2F;&#x2F; st[x]存储x是否被筛掉</p>
<p>void get_eulers(int n)  &#x2F;&#x2F; 线性筛法求1~n的欧拉函数</p>
<p>{</p>
<pre><code>euler[1] = 1;

for (int i = 2; i &lt;= n; i ++ )

&#123;

    if (!st[i])

    &#123;

        primes[cnt ++ ] = i;

        euler[i] = i - 1;

    &#125;

    for (int j = 0; primes[j] &lt;= n / i; j ++ )

    &#123;

        int t = primes[j] * i;

        st[t] = true;

        if (i % primes[j] == 0)

        &#123;

            euler[t] = euler[i] * primes[j];

            break;

        &#125;

        euler[t] = euler[i] * (primes[j] - 1);

    &#125;

&#125;
</code></pre>
<p>}</p>
<h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><p>快速幂公式证明：[快速幂 - OI Wiki (oi-wiki.org)]：<a target="_blank" rel="noopener" href="https://oi-wiki.org/math/binary-exponentiation/">https://oi-wiki.org/math/binary-exponentiation/</a></p>
<p>&#x2F;&#x2F; 求 m^k mod p，时间复杂度 O(logk)。</p>
<p>&#x2F;&#x2F; m为底数，k为幂</p>
<p>int qmi(int m, int k, int p)</p>
<p>{</p>
<pre><code>int res = 1 % p, t = m;

while (k)

&#123;

    if (k&amp;1) res = res * t % p;

    t = t * t % p;

    k &gt;&gt;= 1;

&#125;

return res;
</code></pre>
<p>}</p>
<h3 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h3><p><strong>扩展欧几里得算法讲解：</strong><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1KU4y1a7E2/">https://www.bilibili.com/video/BV1KU4y1a7E2/</a></p>
<p><strong>优秀题解：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/1393">https://www.acwing.com/solution/content/1393</a></p>
<p><strong>优秀博客：</strong><a target="_blank" rel="noopener" href="https://blog.csdn.net/mango114514/article/details/121048335">https://blog.csdn.net/mango114514/article/details/121048335</a></p>
<p>x的第一个正解就是(x%k+k)%k</p>
<p>其中，k&#x3D;b&#x2F;gcd(a,b)</p>
<p>&#x2F;&#x2F; 求x, y，使得ax + by &#x3D; gcd(a, b)</p>
<p>int exgcd(int a, int b, int &amp;x, int &amp;y)</p>
<p>{</p>
<pre><code>if (!b)

&#123;

    x = 1, y = 0;

    return a;

&#125;

int d = exgcd(b, a % b, y, x);

y -= (a/b) * x;

return d;
</code></pre>
<p>}</p>
<h3 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h3><p><strong>中国剩余定理讲解：</strong><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1AN4y1N7Su/">https://www.bilibili.com/video/BV1AN4y1N7Su/</a></p>
<p>中国剩余定理.png</p>
<p>LL exgcd(LL a,LL b,LL &amp;x,LL &amp;y){</p>
<pre><code>if(b==0)&#123;

    x=1,y=0; 

    return a;

&#125;

LL d=exgcd(b,a%b,y,x);

y -= (a/b) * x;

return d;
</code></pre>
<p>}</p>
<p>LL CRT(LL m[],LL r[]){</p>
<pre><code>LL m=1,ans=0;

for(int i=1;i&lt;=n;i++)M*=m[i];

for(int i=1;i&lt;=n;i++)&#123;

    LL c=M/m[i],x,y;

    exgcd(c,m[i],x,y);

    ans=(ans+r[i]*c*x%M)%M;

&#125;

return (ans%M+M)%M;
</code></pre>
<p>}</p>
<h3 id="扩展中国剩余定理"><a href="#扩展中国剩余定理" class="headerlink" title="扩展中国剩余定理"></a>扩展中国剩余定理</h3><p><strong>扩展中国剩余定理讲解：</strong><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Ut4y1F7HG/">https://www.bilibili.com/video/BV1Ut4y1F7HG/</a></p>
<p>扩展中国剩余定理.png</p>
<p>LL exgcd(LL a,LL b,LL &amp;x,LL &amp;y){</p>
<pre><code>if(b==0)&#123;

    x=1,y=0; 

    return a;

&#125;

LL d=exgcd(b,a%b,y,x);

y -= (a/b) * x;

return d;
</code></pre>
<p>}</p>
<p>LL EXCRT(LL m[],LL r[]){</p>
<pre><code>LL m1,m2,r1,r2,p,q;

m1=m[1],r1=r[1];

for(int i=2;i&lt;=n;i++)&#123;

    m2=m[i],r2=r[i];

    LL d = exgcd(m1,m2,p,q);

    if((r2-r1)%d)&#123;

        return -1;

    &#125;

    p=p*(r2-r1)/d;//特解

    p=(p%(m2/d)+m2/d)%(m2/d);

    r1=m1*p+r1;

    m1=m1*m2/d;

&#125;

return (r1%m1+m1)%m1;
</code></pre>
<p>}</p>
<h3 id="高斯消元法"><a href="#高斯消元法" class="headerlink" title="高斯消元法"></a>高斯消元法</h3><p>高斯消元 O(n3)</p>
<p>求解例如下面方程组</p>
<p>⎧⎩⎨⎪⎪⎪⎪⎪⎪a11x1+a12x2+…+a1nxn&#x3D;b1a21x1+a22x2+…+a2nxn&#x3D;b2⋮⋮⋮⋮an1x1+an2x2+…+annxn&#x3D;bn</p>
<p><strong>高斯消元讲解：</strong><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Kd4y127vZ/">https://www.bilibili.com/video/BV1Kd4y127vZ/</a></p>
<h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><p>&#x2F;&#x2F; a[N][N]是增广矩阵</p>
<p>int gauss()</p>
<p>{</p>
<pre><code>int c, r;

for (c = 0, r = 0; c &lt; n; c ++ )

&#123;

    int t = r;

    for (int i = r; i &lt; n; i ++ )   // 找到绝对值最大的行

        if (fabs(a[i][c]) &gt; fabs(a[t][c]))

            t = i;



    if (fabs(a[t][c]) &lt; eps) continue;



    for (int i = c; i &lt;= n; i ++ ) swap(a[t][i], a[r][i]);      // 将绝对值最大的行换到最顶端

    for (int i = n; i &gt;= c; i -- ) a[r][i] /= a[r][c];      // 将当前行的首位变成1

    for (int i = r + 1; i &lt; n; i ++ )       // 用当前行将下面所有的列消成0

        if (fabs(a[i][c]) &gt; eps)

            for (int j = n; j &gt;= c; j -- )

                a[i][j] -= a[r][j] * a[i][c];



    r ++ ;

&#125;



if (r &lt; n)

&#123;

    for (int i = r; i &lt; n; i ++ )

        if (fabs(a[i][n]) &gt; eps)

            return 2; // 无解

    return 1; // 有无穷多组解

&#125;



for (int i = n - 1; i &gt;= 0; i -- )

    for (int j = i + 1; j &lt; n; j ++ )

        a[i][n] -= a[i][j] * a[j][n];



return 0; // 有唯一解
</code></pre>
<p>}</p>
<h4 id="应用-4"><a href="#应用-4" class="headerlink" title="应用"></a>应用</h4><p>using namespace std;</p>
<p>const int N &#x3D; 110;</p>
<p>const double eps &#x3D; 1e-6;</p>
<p>int n;</p>
<p>double a[N][N];</p>
<p>int gauss()</p>
<p>{</p>
<pre><code>int c, r;// c 代表 列 col ， r 代表 行 row

for (c = 0, r = 0; c &lt; n; c ++ )

&#123;

    int t = r;// 先找到当前这一列，绝对值最大的一个数字所在的行号

    for (int i = r; i &lt; n; i ++ )

        if (fabs(a[i][c]) &gt; fabs(a[t][c]))

            t = i;



    if (fabs(a[t][c]) &lt; eps) continue;// 如果当前这一列的最大数都是 0 ，那么所有数都是 0，就没必要去算了，因为它的约束方程，可能在上面几行



    for (int i = c; i &lt; n + 1; i ++ ) swap(a[t][i], a[r][i]);//// 把当前这一行，换到最上面（不是第一行，是第 r 行）去

    for (int i = n; i &gt;= c; i -- ) a[r][i] /= a[r][c];// 把当前这一行的第一个数，变成 1， 方程两边同时除以 第一个数，必须要到着算，不然第一个数直接变1，系数就被篡改，后面的数字没法算

    for (int i = r + 1; i &lt; n; i ++ )// 把当前列下面的所有数，全部消成 0

        if (fabs(a[i][c]) &gt; eps)// 如果非0 再操作，已经是 0就没必要操作了

            for (int j = n; j &gt;= c; j -- )// 从后往前，当前行的每个数字，都减去对应列 * 行首非0的数字，这样就能保证第一个数字是 a[i][0] -= 1*a[i][0];

                a[i][j] -= a[r][j] * a[i][c];



    r ++ ;// 这一行的工作做完，换下一行

&#125;



if (r &lt; n)// 说明剩下方程的个数是小于 n 的，说明不是唯一解，判断是无解还是无穷多解

&#123;// 因为已经是阶梯型，所以 r ~ n-1 的值应该都为 0

    for (int i = r; i &lt; n; i ++ )// 

        if (fabs(a[i][n]) &gt; eps)// a[i][n] 代表 b_i ,即 左边=0，右边=b_i,0 != b_i, 所以无解。

            return 2;

    return 1;// 否则， 0 = 0，就是r ~ n-1的方程都是多余方程

&#125;

// 唯一解 ↓，从下往上回代，得到方程的解

for (int i = n - 1; i &gt;= 0; i -- )

    for (int j = i + 1; j &lt; n; j ++ )

        a[i][n] -= a[j][n] * a[i][j];//因为只要得到解，所以只用对 b_i 进行操作，中间的值，可以不用操作，因为不用输出



return 0;
</code></pre>
<p>}</p>
<p>int main()</p>
<p>{</p>
<pre><code>cin &gt;&gt; n;

for (int i = 0; i &lt; n; i ++ )

    for (int j = 0; j &lt; n + 1; j ++ )

        cin &gt;&gt; a[i][j];



int t = gauss();



if (t == 0)

&#123;

    for (int i = 0; i &lt; n; i ++ ) printf(&quot;%.2lf\n&quot;, a[i][n]);

&#125;

else if (t == 1) puts(&quot;Infinite group solutions&quot;);

else puts(&quot;No solution&quot;);

return 0;
</code></pre>
<p>}</p>
<h3 id="求组合数"><a href="#求组合数" class="headerlink" title="求组合数"></a>求组合数</h3><h4 id="递推法求组合数"><a href="#递推法求组合数" class="headerlink" title="递推法求组合数"></a>递推法求组合数</h4><p><strong>排列组合详细讲解：</strong><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1e7411J7SC/">https://www.bilibili.com/video/BV1e7411J7SC/</a></p>
<p>杨辉三角.png</p>
<p>杨辉三角组合数.png</p>
<p>&#x2F;&#x2F; c[a][b] 表示从a个苹果中选b个的方案数</p>
<p>int c[N][N];</p>
<p>for (int i &#x3D; 0; i &lt; N; i ++ )</p>
<pre><code>for (int j = 0; j &lt;= i; j ++ )

    if (!j) c[i][j] = 1;

    else c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;
</code></pre>
<p>&#x2F;&#x2F;本质上杨辉三角</p>
<h4 id="通过预处理逆元的方式求组合数"><a href="#通过预处理逆元的方式求组合数" class="headerlink" title="通过预处理逆元的方式求组合数"></a>通过预处理逆元的方式求组合数</h4><h4 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h4><p>&#x2F;&#x2F; 首先预处理出所有阶乘取模的余数fact[N]，以及所有阶乘取模的逆元infact[N]</p>
<p>&#x2F;&#x2F; 如果取模的数是质数，可以用费马小定理求逆元</p>
<p>int qmi(int a, int k, int p)    &#x2F;&#x2F; 快速幂模板</p>
<p>{</p>
<pre><code>int res = 1;

while (k)

&#123;

    if (k &amp; 1) res = (LL)res * a % p;

    a = (LL)a * a % p;

    k &gt;&gt;= 1;

&#125;

return res;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; 预处理阶乘的余数和阶乘逆元的余数</p>
<p>fact[0] &#x3D; infact[0] &#x3D; 1;</p>
<p>for (int i &#x3D; 1; i &lt; N; i ++ )</p>
<p>{</p>
<pre><code>fact[i] = (LL)fact[i - 1] * i % mod;

infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
</code></pre>
<p>}</p>
<h4 id="应用-5"><a href="#应用-5" class="headerlink" title="应用"></a>应用</h4><p>using namespace std;</p>
<p>typedef long long LL;</p>
<p>const int N &#x3D; 100010,mod&#x3D;1e9+7;&#x2F;&#x2F;1e9+7是质数所以与[1,1e9+7)中的数互质</p>
<p>int fact[N],infact[N];</p>
<p>int qmi(int a,int k,int p){</p>
<pre><code>int res=1;

while(k)&#123;

    if(k&amp;1)res=(LL)res*a%p;

    a=(LL)a*a%p;

    k&gt;&gt;=1;

&#125;

return res;
</code></pre>
<p>}</p>
<p>int main()</p>
<p>{</p>
<pre><code>fact[0]=infact[0]=1;

for (int i = 1; i &lt;= N; i ++ )&#123;

    fact[i]=(LL)fact[i-1]*i%mod;

    infact[i]=(LL)infact[i-1]*qmi(i,mod-2,mod)%mod;

&#125;



int n;

scanf(&quot;%d&quot;,&amp;n);

while (n -- )&#123;

    int a,b;

    scanf(&quot;%d%d&quot;, &amp;a, &amp;b);

    printf(&quot;%d\n&quot;,(LL)fact[a]*infact[b]%mod*infact[a-b]%mod);

&#125;

return 0;
</code></pre>
<p>}</p>
<h3 id="Lucas定理求组合数"><a href="#Lucas定理求组合数" class="headerlink" title="Lucas定理求组合数"></a>Lucas定理求组合数</h3><p><strong>Lucas定理证明：</strong><a target="_blank" rel="noopener" href="https://blog.csdn.net/Qiuker_jl/article/details/109528164">https://blog.csdn.net/Qiuker_jl/article/details/109528164</a></p>
<h4 id="模板-2"><a href="#模板-2" class="headerlink" title="模板"></a>模板</h4><p>&#x2F;&#x2F; 若p是质数，则对于任意整数 1 &lt;&#x3D; m &lt;&#x3D; n，有：</p>
<p>&#x2F;&#x2F; C(n, m) &#x3D; C(n % p, m % p) * C(n &#x2F; p, m &#x2F; p) (mod p)</p>
<p>int qmi(int a, int k, int p)  &#x2F;&#x2F; 快速幂模板</p>
<p>{</p>
<pre><code>int res = 1 % p;

while (k)

&#123;

    if (k &amp; 1) res = (LL)res * a % p;

    a = (LL)a * a % p;

    k &gt;&gt;= 1;

&#125;

return res;
</code></pre>
<p>}</p>
<p>int C(int a, int b, int p)  &#x2F;&#x2F; 通过定理求组合数C(a, b)</p>
<p>{</p>
<pre><code>if (a &lt; b) return 0;



LL x = 1, y = 1;  // x是分子，y是分母

for (int i = a, j = 1; j &lt;= b; i --, j ++ )

&#123;

    x = (LL)x * i % p;

    y = (LL) y * j % p;

&#125;



return x * (LL)qmi(y, p - 2, p) % p;
</code></pre>
<p>}</p>
<p>int lucas(LL a, LL b, int p)</p>
<p>{</p>
<pre><code>if (a &lt; p &amp;&amp; b &lt; p) return C(a, b, p);

return (LL)C(a % p, b % p, p) * lucas(a / p, b / p, p) % p;
</code></pre>
<p>}</p>
<h4 id="应用-6"><a href="#应用-6" class="headerlink" title="应用"></a>应用</h4><p>using namespace std;</p>
<p>typedef long long LL;</p>
<p>int qmi(int a,int k,int p)</p>
<p>{</p>
<pre><code>int res = 1;

while(k)

&#123;

    if(k&amp;1)res = (LL)res*a%p;

    a = (LL)a*a%p;

    k&gt;&gt;=1;

&#125;

return res;
</code></pre>
<p>}</p>
<p>int C(int a,int b,int p)&#x2F;&#x2F;自变量类型int</p>
<p>{</p>
<pre><code>if(b&gt;a)return 0;//漏了边界条件

int res = 1;

// a!/(b!(a-b)!) = (a-b+1)*...*a / b! 分子有b项

for(int i=1,j=a;i&lt;=b;i++,j--)//i&lt;=b而不是&lt;

&#123;

    res = (LL)res*j%p;

    res = (LL)res*qmi(i,p-2,p)%p;

&#125;

return res;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F;对公式敲</p>
<p>int lucas(LL a,LL b,int p)</p>
<p>{</p>
<pre><code>if(a&lt;p &amp;&amp; b&lt;p)return C(a,b,p);//lucas递归终点是C_&#123;bk&#125;^&#123;ak&#125;

return (LL)C(a%p,b%p,p)*lucas(a/p,b/p,p)%p;//a%p后肯定是&lt;p的,所以可以用C(),但a/p后不一定&lt;p 所以用lucas继续递归
</code></pre>
<p>}</p>
<p>int main()</p>
<p>{</p>
<pre><code>int n;

cin &gt;&gt; n;

while(n--)

&#123;

    LL a,b;

    int p;

    cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;

    cout &lt;&lt; lucas(a,b,p) &lt;&lt; endl;

&#125;

return 0;
</code></pre>
<p>}</p>
<h3 id="分解质因数法求组合数"><a href="#分解质因数法求组合数" class="headerlink" title="分解质因数法求组合数"></a>分解质因数法求组合数</h3><h4 id="模板-3"><a href="#模板-3" class="headerlink" title="模板"></a>模板</h4><p>当我们需要求出组合数的真实值，而非对某个数的余数时，分解质因数的方式比较好用：</p>
<pre><code>1. 筛法求出范围内的所有质数

2. 通过 C(a, b) = a! / b! / (a - b)! 这个公式求出每个质因子的次数。 n! 中p的次数是 n / p + n / p^2 + n / p^3 + ...

3. 用高精度乘法将所有质因子相乘
</code></pre>
<p>int primes[N], cnt;     &#x2F;&#x2F; 存储所有质数</p>
<p>int sum[N];     &#x2F;&#x2F; 存储每个质数的次数</p>
<p>bool st[N];     &#x2F;&#x2F; 存储每个数是否已被筛掉</p>
<p>void get_primes(int n)      &#x2F;&#x2F; 线性筛法求素数</p>
<p>{</p>
<pre><code>for (int i = 2; i &lt;= n; i ++ )

&#123;

    if (!st[i]) primes[cnt ++ ] = i;

    for (int j = 0; primes[j] &lt;= n / i; j ++ )

    &#123;

        st[primes[j] * i] = true;

        if (i % primes[j] == 0) break;

    &#125;

&#125;
</code></pre>
<p>}</p>
<p>int get(int n, int p)       &#x2F;&#x2F; 求n！中的次数</p>
<p>{</p>
<pre><code>int res = 0;

while (n)

&#123;

    res += n / p;

    n /= p;

&#125;

return res;
</code></pre>
<p>}</p>
<p>vector<int> mul(vector<int> a, int b)       &#x2F;&#x2F; 高精度乘低精度模板</p>
<p>{</p>
<pre><code>vector&lt;int&gt; c;

int t = 0;

for (int i = 0; i &lt; a.size(); i ++ )

&#123;

    t += a[i] * b;

    c.push_back(t % 10);

    t /= 10;

&#125;



while (t)

&#123;

    c.push_back(t % 10);

    t /= 10;

&#125;



return c;
</code></pre>
<p>}</p>
<p>get_primes(a);  &#x2F;&#x2F; 预处理范围内的所有质数</p>
<p>for (int i &#x3D; 0; i &lt; cnt; i ++ )     &#x2F;&#x2F; 求每个质因数的次数</p>
<p>{</p>
<pre><code>int p = primes[i];

sum[i] = get(a, p) - get(b, p) - get(a - b, p);
</code></pre>
<p>}</p>
<p>vector<int> res;</p>
<p>res.push_back(1);</p>
<p>for (int i &#x3D; 0; i &lt; cnt; i ++ )     &#x2F;&#x2F; 用高精度乘法将所有质因子相乘</p>
<pre><code>for (int j = 0; j &lt; sum[i]; j ++ )

    res = mul(res, primes[i]);
</code></pre>
<h4 id="应用-7"><a href="#应用-7" class="headerlink" title="应用"></a>应用</h4><p>using namespace std;</p>
<p>const int N &#x3D; 5010;</p>
<p>int primes[N],cnt&#x3D;0;</p>
<p>&#x2F;&#x2F; v[i] 记录数字 i 为素数还是合数，v[i]&#x3D;true时 i 为合数，否则 i 为素数</p>
<p>bool v[N];</p>
<p>&#x2F;&#x2F; sum[i]&#x3D;c 表示质数 i 的个数为 c</p>
<p>int sum[N];</p>
<p>&#x2F;&#x2F; 线性筛法</p>
<p>void get_primes(int n)</p>
<p>{</p>
<pre><code>for(int i=2;i&lt;=n;++i)

&#123;

    // i为质数，则存在primes中

    if(!v[i])primes[cnt++]=i;

    // 给当前数i乘上一个质因子pj

    for(int j=0;primes[j]&lt;=n/i;++j)

    &#123;

        v[primes[j]*i]=true;

        if(i%primes[j]==0)break;

    &#125;

&#125;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; 计算 n 里面含有质数 p 的个数，这里的计算是不重不漏的。</p>
<p>&#x2F;&#x2F; p^k的倍数会被计算k次：第一次算p的倍数时，被加一次；第二次算p^2的倍数时，被加一次；第三次算p^3的倍数时，被加一次…第k次算p^k的倍数时，被加一次。总共被加了k次，是不重不漏的。</p>
<p>int get(int n,int p)</p>
<p>{</p>
<pre><code>int res=0;

while(n)

&#123;

    res+=n/p;

    n/=p;

&#125;

return res;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; A * b：把 b 看成一个整体，然后与 A 中每一位相乘，A中的数字采用小端存储，即低位数字存储在数组的前面，高位数字存储在数组的后面</p>
<p>vector<int> mul(const vector<int>&amp; A,const int b)</p>
<p>{</p>
<pre><code>if(b==0)return &#123;0&#125;;

vector&lt;int&gt; res;

// t 表示乘法进位，这里的进位不限于0 1，可以为任意数字

for(int i=0,t=0,n=A.size();i&lt;n||t&gt;0;++i)

&#123;

    // 获得当前位的乘积和

    if(i&lt;n)t+=A[i]*b;

    // 添加个位数字

    res.push_back(t%10);

    // 保留进位

    t/=10;

&#125;



 // 如 1234 * 0 = 0000，需要删除前导0

while(res.size()&gt;1&amp;&amp;res.back()==0)res.pop_back();

return res;
</code></pre>
<p>}</p>
<p>int main()</p>
<p>{</p>
<pre><code>int a,b;cin&gt;&gt;a&gt;&gt;b;



// 将 a 分解质因数

get_primes(a);



for(int i=0;i&lt;cnt;++i)

&#123;

    // 当前的质数为 p

    int p=primes[i];

    // 用分子里面 p 的个数减去分母里面 p 的个数。这里的计算组合数的公式为a!/(b!*(a-b)!)，因此用 a 里面 p 的个数减去 b 里面 p 的个数和 (a-b) 里面 p 的个数。

    sum[i]=get(a,p)-get(b,p)-get(a-b,p);

&#125;



// 使用高精度乘法把所有质因子乘到一块去就好了

vector&lt;int&gt; res=&#123;1&#125;;

for(int i=0;i&lt;cnt;++i)

    // res*p^k，这里是k个p相乘，不是k*p，所以需要使用一个循环

    for(int j=0;j&lt;sum[i];++j)

        res=mul(res,primes[i]);



// 倒序打印 res 即可，由于采用小端存储，所以高位在后，从后往前打印即可

for(int i=res.size()-1;i&gt;=0;i--)printf(&quot;%d&quot;,res[i]);

return 0;
</code></pre>
<p>}</p>
<h3 id="容斥原理应用"><a href="#容斥原理应用" class="headerlink" title="容斥原理应用"></a>容斥原理应用</h3><p>经典例题：[890. 能被整除的数 - AcWing题库]：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/892/">https://www.acwing.com/problem/content/892/</a></p>
<p>AC代码：</p>
<p> using namespace std;</p>
<p> typedef long long LL;</p>
<p> const int N &#x3D; 20;</p>
<p> int p[N], n, m;</p>
<p> int main() {</p>
<p> cin &gt;&gt; n &gt;&gt; m;</p>
<p> for(int i &#x3D; 0; i &lt; m; i++) cin &gt;&gt; p[i];</p>
<p> int res &#x3D; 0;</p>
<p> &#x2F;&#x2F;枚举从1 到 1111…(m个1)的每一个集合状态, (至少选中一个集合)</p>
<p> for(int i &#x3D; 1; i &lt; 1 &lt;&lt; m; i++) {</p>
<p>   int t &#x3D; 1;             &#x2F;&#x2F;选中集合对应质数的乘积</p>
<p>   int s &#x3D; 0;             &#x2F;&#x2F;选中的集合数量</p>
<p>   &#x2F;&#x2F;枚举当前状态的每一位</p>
<p>   for(int j &#x3D; 0; j &lt; m; j++){</p>
<pre><code>   //选中一个集合

   if(i &gt;&gt; j &amp; 1)&#123;

       //乘积大于n, 则n/t = 0, 跳出这轮循环

       if((LL)t * p[j] &gt; n)&#123;    

           t = -1;

           break;

       &#125;

       s++;                  //有一个1，集合数量+1

       t *= p[j];

   &#125;
</code></pre>
<p>   }</p>
<p>   if(t &#x3D;&#x3D; -1) continue;  </p>
<p>   if(s &amp; 1) res +&#x3D; n &#x2F; t;              &#x2F;&#x2F;选中奇数个集合, 则系数应该是1, n&#x2F;t为当前这种状态的集合数量</p>
<p>   else res -&#x3D; n &#x2F; t;                      &#x2F;&#x2F;反之则为 -1</p>
<p> }</p>
<p> cout &lt;&lt; res &lt;&lt; endl;</p>
<p> return 0;</p>
<p> }</p>
<p>详细题解：[AcWing 890. 能被整除的数 - AcWing]：<a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/29702/">https://www.acwing.com/solution/content/29702/</a></p>
<h3 id="博弈论"><a href="#博弈论" class="headerlink" title="博弈论"></a>博弈论</h3><h4 id="NIM游戏"><a href="#NIM游戏" class="headerlink" title="NIM游戏"></a>NIM游戏</h4><p>定理1：必胜态的后继状态至少存在一个必败态</p>
<p>定理2：必败态的后继状态均为必胜态</p>
<p><strong>NIM游戏科普：</strong>[尼姆游戏（学霸就是这样欺负人的）_哔哩哔哩_bilibili]：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1ek4y1q7JD/">https://www.bilibili.com/video/BV1ek4y1q7JD/</a></p>
<p>[再看nim游戏_哔哩哔哩_bilibili]：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1nt4y1C7Sk/">https://www.bilibili.com/video/BV1nt4y1C7Sk/</a></p>
<p>经典例题：[P2197 【模板】nim 游戏 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)]：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2197">https://www.luogu.com.cn/problem/P2197</a></p>
<p>AC代码：</p>
<p> using namespace std;</p>
<p> int T;</p>
<p> int main() {</p>
<pre><code> cin &gt;&gt; T;

 while (T--) &#123;

     int n;

     scanf(&quot;%d&quot;, &amp;n);

     int ans = 0;

     for (int i = 0; i &lt; n; i++) &#123;

         int k;

         scanf(&quot;%d&quot;, &amp;k);

         ans ^= k;

     &#125;

     if (ans)

         puts(&quot;Yes&quot;);

     else

         puts(&quot;No&quot;);

 &#125;

 return 0;
</code></pre>
<p> }</p>
<p>结论：</p>
<p>若初态为必胜态(a1⊕a2⊕…⊕an≠0</p>
<p>).则先手必胜</p>
<p>若初态为必败态(a1⊕a2⊕…⊕an&#x3D;0</p>
<p>).则先手必败</p>
<p>视频讲解：[581 尼姆（Nim）游戏【博弈论】_哔哩哔哩_bilibili]：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1ns4y1D7dg/">https://www.bilibili.com/video/BV1ns4y1D7dg/</a></p>
<p>台阶型NIM游戏</p>
<p>经典例题：[892. 台阶-Nim游戏 - AcWing题库]：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/894/">https://www.acwing.com/problem/content/894/</a></p>
<p>AC代码：</p>
<p> using namespace std;</p>
<p> const int N &#x3D; 100010;</p>
<p> int main()</p>
<p> {</p>
<pre><code>  int n;

  scanf(&quot;%d&quot;, &amp;n);
</code></pre>
<p>   int res &#x3D; 0;</p>
<pre><code>  for (int i = 1; i &lt;= n; i ++ )

  &#123;

      int x;

      scanf(&quot;%d&quot;, &amp;x);

      if (i &amp; 1) res ^= x;

  &#125;

  if (res) puts(&quot;Yes&quot;);
</code></pre>
<p>   else puts(“No”);</p>
<pre><code>  return 0;
</code></pre>
<p> }</p>
<p>结论：若奇数台阶上的a1⊕a3⊕a5⊕…≠0，则先手必胜，反之先手必败。</p>
<p>视频讲解：[582 台阶型 Nim游戏【博弈论】_哔哩哔哩_bilibili]：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV18M411M7TC/">https://www.bilibili.com/video/BV18M411M7TC/</a></p>
<p>集合型NIM游戏</p>
<p>经典例题：[893. 集合-Nim游戏 - AcWing题库]：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/895/">https://www.acwing.com/problem/content/895/</a></p>
<p>AC代码：</p>
<p> using namespace std;</p>
<p> const int N&#x3D;110,M&#x3D;10010;</p>
<p> int n,m;</p>
<p> int f[M],s[N];&#x2F;&#x2F;s存储的是可供选择的集合,f存储的是所有可能出现过的情况的sg值</p>
<p> int sg(int x)</p>
<p> {</p>
<pre><code>  if(f[x]!=-1) return f[x];

  //因为取石子数目的集合是已经确定了的,所以每个数的sg值也都是确定的,如果存储过了,直接返回即可

  unordered_set&lt;int&gt; S;

  //set代表的是有序集合(注:因为在函数内部定义,所以下一次递归中的S不与本次相同)

  for(int i=0;i&lt;m;i++)

  &#123;

      int sum=s[i];

      if(x&gt;=sum) S.insert(sg(x-sum));

      //先延伸到终点的sg值后,再从后往前排查出所有数的sg值

  &#125;

  for(int i=0;;i++)

  //循环完之后可以进行选出最小的没有出现的自然数的操作

   if(!S.count(i))

    return f[x]=i;
</code></pre>
<p> }</p>
<p> int main()</p>
<p> {</p>
<pre><code>  cin&gt;&gt;m;

  for(int i=0;i&lt;m;i++)

  cin&gt;&gt;s[i];



  cin&gt;&gt;n;

  memset(f,-1,sizeof(f));//初始化f均为-1,方便在sg函数中查看x是否被记录过



  int res=0;

  for(int i=0;i&lt;n;i++)

  &#123;

      int x;

      cin&gt;&gt;x;

      res^=sg(x);

      //观察异或值的变化,基本原理与Nim游戏相同

  &#125;



  if(res) printf(&quot;Yes&quot;);

  else printf(&quot;No&quot;);



  return 0;
</code></pre>
<p> }</p>
<p>思路：转换成有向图游戏</p>
<p>视频讲解：[583 有向图游戏 SG函数【博弈论】_哔哩哔哩_bilibili]：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1eT411B7A8/">https://www.bilibili.com/video/BV1eT411B7A8/</a></p>
<h2 id="五、动态规划"><a href="#五、动态规划" class="headerlink" title="五、动态规划"></a>五、动态规划</h2><p>动态规划三大特征：最优子结构、无后效性、重复子问题</p>
<p>闫式dp分析法.jpg</p>
<h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><p>01背包每件物品只能装一次</p>
<p>完全背包每件物品可以装无限次</p>
<p>多重背包每件物品只能装有限次（多次）</p>
<p>分组背包每组只能选择一件物品装入（01背包升级）</p>
<p>相关链接：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/166439661">https://zhuanlan.zhihu.com/p/166439661</a></p>
<p>01背包问题</p>
<p>01背包每件物品只能装一次</p>
<p>视频讲解：[408 背包DP【模板】01背包_哔哩哔哩_bilibili]：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1kp4y1e794/">https://www.bilibili.com/video/BV1kp4y1e794/</a></p>
<p>01背包DP分析.png</p>
<p>01背包.png</p>
<p>using namespace std;</p>
<p>const int N&#x3D;1010;</p>
<p>int n,m;</p>
<p>int v[N],w[N];&#x2F;&#x2F;v代表体积，w代表价值</p>
<p>int f[N][N];</p>
<p>int main(){</p>
<pre><code>cin&gt;&gt;n&gt;&gt;m;

for(int i=1;i&lt;=n;i++)cin&gt;&gt;v[i]&gt;&gt;w[i];

for(int i=1;i&lt;=n;i++)//i代表这n件物品

&#123;

    for(int j=1;j&lt;=m;j++)&#123;//j代表背包容量

        if(v[i]&gt;j)//如果v[i]的容量大于当前的背包容量则不装进行下一个

            f[i][j]=f[i-1][j];

        else f[i][j]=max(f[i-1][j],f[i-1][j-v[i]]+w[i]);//如果v[i]的容量小于当前背包容量则可以选择装与不装得到最大值 

    &#125;

&#125;



cout&lt;&lt;f[n][m]&lt;&lt;endl;//输出最后的一个一定是最大的

return 0;
</code></pre>
<p>}</p>
<p>01背包，使用滚动数组，倒序遍历</p>
<p>using namespace std;</p>
<p>const int N&#x3D;1010;</p>
<p>int n,m;</p>
<p>int v[N],w[N];&#x2F;&#x2F;v代表体积，w代表价值</p>
<p>int dp[N];</p>
<p>int main(){</p>
<pre><code>cin&gt;&gt;n&gt;&gt;m;

for(int i=1;i&lt;=n;i++)//i代表这n件物品

&#123;

    cin&gt;&gt;v[i]&gt;&gt;w[i];//在线算法

    for(int j=m;j&gt;=v[i];j--)&#123;//j代表背包容量，滚动数组必须倒序遍历

        dp[j]=max(dp[j],dp[j-v[i]]+w[i]);//滚动数组

    &#125;

&#125;

cout&lt;&lt;dp[m]&lt;&lt;endl;//输出最后的一个一定是最大的

return 0;
</code></pre>
<p>}</p>
<p>状态转移方程：dp[j]&#x3D;max(dp[j],dp[j-v[i]]+w[i]);</p>
<h4 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h4><p>完全背包每件物品可以装无限次</p>
<p>视频讲解：[409 背包DP 完全背包【动态规划】_哔哩哔哩_bilibili]：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV15v411y7Qz/">https://www.bilibili.com/video/BV15v411y7Qz/</a></p>
<p>using namespace std;</p>
<p>int v[N],w[N];</p>
<p>int dp[N];</p>
<p>int main(){</p>
<pre><code>int n,m;

cin&gt;&gt;n&gt;&gt;m;

for(int i=1;i&lt;=n;i++)&#123;//遍历物品

    cin&gt;&gt;v[i]&gt;&gt;w[i];//在线算法

    for(int j=v[i];j&lt;=m;j++)&#123;//正序遍历背包容量

        dp[j]=max(dp[j],dp[j-v[i]]+w[i]);//滚动数组

    &#125;

&#125;

cout&lt;&lt;dp[m]&lt;&lt;endl;//输出答案

return 0;
</code></pre>
<p>}</p>
<p>完全背包问题和01背包优化版的区别在于第二重循环的v[i]和m做交换</p>
<p>状态转移方程：dp[j]&#x3D;max(dp[j],dp[j-v[i]]+w[i]);</p>
<h4 id="多重背包问题1"><a href="#多重背包问题1" class="headerlink" title="多重背包问题1"></a>多重背包问题1</h4><p>多重背包每件物品只能装有限次（多次）</p>
<p>using namespace std;</p>
<p>int n,m;</p>
<p>int v[N],w[N],s[N];</p>
<p>int dp[N][N];</p>
<p>int main(){</p>
<pre><code>cin&gt;&gt;n&gt;&gt;m;

for(int i=1;i&lt;=n;i++)cin&gt;&gt;v[i]&gt;&gt;w[i]&gt;&gt;s[i];

for(int i=1;i&lt;=n;i++)//物品

    for(int j=0;j&lt;=m;j++)//背包容量

        for(int k=0;k&lt;=s[i]&amp;&amp;k*v[i]&lt;=j;k++)

            dp[i][j]=max(dp[i][j],dp[i-1][j-v[i]*k]+w[i]*k);

cout&lt;&lt;dp[n][m]&lt;&lt;endl;

return 0;
</code></pre>
<p>}</p>
<p>状态转移方程：dp[i][j]&#x3D;max(dp[i][j],dp[i-1][j-v[i]*k]+w[i]*k);k为第i个物品的个数</p>
<h4 id="多重背包问题2-二进制优化"><a href="#多重背包问题2-二进制优化" class="headerlink" title="多重背包问题2(二进制优化)"></a>多重背包问题2(二进制优化)</h4><p>思路：转换成2进制，再用01背包求解</p>
<p>视频讲解：[410 背包DP 多重背包 二进制优化【动态规划】_哔哩哔哩_bilibili]：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1MA41177cg/">https://www.bilibili.com/video/BV1MA41177cg/</a></p>
<p>using namespace std;</p>
<p>const int N &#x3D; 12010, M &#x3D; 2010;</p>
<p>int n, m;</p>
<p>int v[N], w[N];</p>
<p>int f[M];</p>
<p>int main()</p>
<p>{</p>
<pre><code>cin &gt;&gt; n &gt;&gt; m;



int cnt = 0;

for (int i = 1; i &lt;= n; i ++ )

&#123;

    int a, b, s;

    cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;

    int k = 1;

    while (k &lt;= s)

    &#123;

        cnt ++ ;

        v[cnt] = a * k;

        w[cnt] = b * k;

        s -= k;

        k *= 2;

    &#125;

    if (s &gt; 0)

    &#123;

        cnt ++ ;

        v[cnt] = a * s;

        w[cnt] = b * s;

    &#125;

&#125;//二进制优化操作



n = cnt;



for (int i = 1; i &lt;= n; i ++ )

    for (int j = m; j &gt;= v[i]; j -- )

        f[j] = max(f[j], f[j - v[i]] + w[i]);



cout &lt;&lt; f[m] &lt;&lt; endl;



return 0;
</code></pre>
<p>}</p>
<h4 id="分组背包问题"><a href="#分组背包问题" class="headerlink" title="分组背包问题"></a>分组背包问题</h4><p>分组背包每组只能选择一件物品装入</p>
<p>视频讲解：[416 背包DP 分组背包【动态规划】_哔哩哔哩_bilibili]：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV16a411w77X/">https://www.bilibili.com/video/BV16a411w77X/</a></p>
<p>using namespace std;</p>
<p>const int N&#x3D;110;</p>
<p>int f[N];</p>
<p>int v[N][N],w[N][N],s[N];</p>
<p>int n,m,k;</p>
<p>int main(){</p>
<pre><code>cin&gt;&gt;n&gt;&gt;m;

for(int i=0;i&lt;n;i++)&#123;

    cin&gt;&gt;s[i];

    for(int j=0;j&lt;s[i];j++)&#123;

        cin&gt;&gt;v[i][j]&gt;&gt;w[i][j];

    &#125;

&#125;



for(int i=0;i&lt;n;i++)&#123;

    for(int j=m;j&gt;=0;j--)&#123;

        for(int k=0;k&lt;s[i];k++)&#123;    //for(int k=s[i];k&gt;=1;k--)也可以

            if(j&gt;=v[i][k])

                f[j]=max(f[j],f[j-v[i][k]]+w[i][k]);  

        &#125;

    &#125;

&#125;

cout&lt;&lt;f[m]&lt;&lt;endl;
</code></pre>
<p>}</p>
<p>状态转移方程：f[j]&#x3D;max(f[j],f[j-v[i][k]]+w[i][k]);</p>
<p>线性DP</p>
<p>数字三角形</p>
<p>视频讲解：[402 线性DP 数字三角形【动态规划】_哔哩哔哩_bilibili]：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Rk4y1173p/">https://www.bilibili.com/video/BV1Rk4y1173p/</a></p>
<p>数字三角形DP分析.png</p>
<p>using namespace std;</p>
<p>const int N&#x3D;510,INF&#x3D;1e9;</p>
<p>int n;</p>
<p>int a[N][N];</p>
<p>int f[N][N];</p>
<p>int main(){</p>
<pre><code>scanf(&quot;%d&quot;,&amp;n);

for(int i=1;i&lt;=n;i++)&#123;

    for(int j=1;j&lt;=i;j++)&#123;

        scanf(&quot;%d&quot;,&amp;a[i][j]);

    &#125;

&#125;

for(int i=0;i&lt;=n;i++)&#123;

    for(int j=0;j&lt;=i+1;j++)&#123;

        f[i][j]=-INF;

    &#125;

&#125;

f[1][1]=a[1][1];

for(int i=2;i&lt;=n;i++)

    for(int j=1;j&lt;=i;j++)

        f[i][j]=max(f[i-1][j-1]+a[i][j],f[i-1][j]+a[i][j]);//状态转移方程

int res=-INF;

for(int i=1;i&lt;=n;i++)res=max(res,f[n][i]);

printf(&quot;%d&quot;,res);

return 0;
</code></pre>
<p>}</p>
<p>状态转移方程：f[i][j]&#x3D;max(f[i-1][j-1]+a[i][j],f[i-1][j]+a[i][j]);</p>
<h3 id="最长上升子序列1"><a href="#最长上升子序列1" class="headerlink" title="最长上升子序列1"></a>最长上升子序列1</h3><p>视频讲解：[403 线性DP 最长上升子序列【动态规划】_哔哩哔哩_bilibili]：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1KK4y1e7t7/">https://www.bilibili.com/video/BV1KK4y1e7t7/</a></p>
<p>using namespace std;</p>
<p>const int N &#x3D; 1010;</p>
<p>int n;</p>
<p>int a[N],f[N];</p>
<p>int main()</p>
<p>{</p>
<pre><code>scanf(&quot;%d&quot;, &amp;n);

for (int i = 1; i &lt;= n; i ++ )scanf(&quot;%d&quot;,&amp;a[i]);

for (int i = 1; i &lt;= n; i ++ )&#123;

    f[i]=1;//只有a[i]一个数

    for (int j = 1; j &lt;= i; j ++ )

        if(a[j]&lt;a[i])

            f[i]=max(f[i],f[j]+1);

&#125;

int res=0;

for (int i = 1; i &lt;= n; i ++ )res=max(res,f[i]);

printf(&quot;%d\n&quot;,res);

return 0;
</code></pre>
<p>}</p>
<p>状态转移方程：if(a[j]&lt;a[i])f[i]&#x3D;max(f[i],f[j]+1);</p>
<h4 id="最长上升子序列2-二分优化"><a href="#最长上升子序列2-二分优化" class="headerlink" title="最长上升子序列2(二分优化)"></a>最长上升子序列2(二分优化)</h4><p>视频讲解：[404 线性DP 最长上升子序列 二分优化_哔哩哔哩_bilibili]：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Kp4y1e77H/">https://www.bilibili.com/video/BV1Kp4y1e77H/</a></p>
<p>using namespace std;</p>
<p>const int N &#x3D; 100010;</p>
<p>int n;</p>
<p>int a[N];</p>
<p>int q[N];</p>
<p>int main()</p>
<p>{</p>
<pre><code>scanf(&quot;%d&quot;, &amp;n);

for (int i = 0; i &lt; n; i ++ ) scanf(&quot;%d&quot;, &amp;a[i]);



int len = 0;

for (int i = 0; i &lt; n; i ++ )

&#123;

    int l = 0, r = len;

    while (l &lt; r)

    &#123;

        int mid = l + r + 1 &gt;&gt; 1;

        if (q[mid] &lt; a[i]) l = mid;

        else r = mid - 1;

    &#125;

    len = max(len, r + 1);

    q[r + 1] = a[i];//替换或添加

&#125;



printf(&quot;%d\n&quot;, len);



return 0;
</code></pre>
<p>}</p>
<h4 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h4><p>视频讲解：[405 线性DP 最长公共子序列【动态规划】_哔哩哔哩_bilibili]：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1EK411K7Eb/">https://www.bilibili.com/video/BV1EK411K7Eb/</a></p>
<p>using namespace std;</p>
<p>const int N&#x3D;1010;</p>
<p>int n,m;</p>
<p>char a[N],b[N];</p>
<p>int f[N][N];</p>
<p>int main()</p>
<p>{</p>
<pre><code>cin&gt;&gt;n&gt;&gt;m&gt;&gt;a+1&gt;&gt;b+1;

for (int i = 1; i &lt;= n; i ++ )&#123;

    for (int j = 1; j &lt;= m; j ++ )&#123;

        f[i][j]=max(f[i-1][j],f[i][j-1]);

        if(a[i]==b[j])f[i][j]=max(f[i][j],f[i-1][j-1]+1);

    &#125;

&#125;

cout&lt;&lt;f[n][m]&lt;&lt;endl;

return 0;
</code></pre>
<p>}</p>
<p>状态转移方程：</p>
<p>f[i][j]&#x3D;max(f[i-1][j],f[i][j-1]);</p>
<p>if(a[i]&#x3D;&#x3D;b[j])f[i][j]&#x3D;max(f[i][j],f[i-1][j-1]+1);</p>
<h4 id="最短编辑距离"><a href="#最短编辑距离" class="headerlink" title="最短编辑距离"></a>最短编辑距离</h4><p>给定两个字符串 A和 B，现在要将 A 经过若干操作变为 B，可进行的操作有：</p>
<p>删除–将字符串 A中的某个字符删除。</p>
<p>插入–在字符串 A 的某个位置插入某个字符。</p>
<p>替换–将字符串 A中的某个字符替换为另一个字符。</p>
<p>现在请你求出，将 A变为 B 至少需要进行多少次操作。</p>
<p>视频讲解：[407 线性DP 编辑距离【动态规划】_哔哩哔哩_bilibili]：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1gk4y1177j/">https://www.bilibili.com/video/BV1gk4y1177j/</a></p>
<p>闫氏DP分析法【最短编辑距离】.png</p>
<p>using namespace std;</p>
<p>const int N &#x3D; 1010;</p>
<p>int n,m;</p>
<p>char a[N],b[N];</p>
<p>int f[N][N];</p>
<p>int main()</p>
<p>{</p>
<pre><code>scanf(&quot;%d%s&quot;, &amp;n, a+1);

scanf(&quot;%d%s&quot;, &amp;m, b+1);



for (int i = 0; i &lt;= m; i ++ )f[0][i]=i;

for (int i = 0; i &lt;= n; i ++ )f[i][0]=i;//初始化字符串的编辑操作

for (int i = 1; i &lt;= n; i ++ )&#123;

    for (int j = 1; j &lt;= m; j ++ )&#123;

        f[i][j]=min(f[i-1][j]+1,f[i][j-1]+1);

        if(a[i]==b[j])f[i][j]=min(f[i][j],f[i-1][j-1]);

        else f[i][j]=min(f[i][j],f[i-1][j-1]+1);//状态转移方程

    &#125;

&#125;

printf(&quot;%d\n&quot;,f[n][m]);

return 0;
</code></pre>
<p>}</p>
<p>状态转移方程:</p>
<p>f[i][j]&#x3D;min(f[i-1][j]+1,f[i][j-1]+1);</p>
<p>if(a[i]&#x3D;&#x3D;b[j])f[i][j]&#x3D;min(f[i][j],f[i-1][j-1]);</p>
<p>else f[i][j]&#x3D;min(f[i][j],f[i-1][j-1]+1);&#x2F;&#x2F;状态转移方程</p>
<h3 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h3><h4 id="石子合并"><a href="#石子合并" class="headerlink" title="石子合并"></a>石子合并</h4><p>每堆石子有一定的质量，可以用一个整数来描述，现在要将这 N堆石子合并成为一堆。</p>
<p>每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同。</p>
<p>视频讲解：[428 区间DP【模板】石子合并_哔哩哔哩_bilibili]：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1gz4y1y7Rv/">https://www.bilibili.com/video/BV1gz4y1y7Rv/</a></p>
<p>闫氏DP分析法</p>
<p>using namespace std;</p>
<p>const int N &#x3D; 310;</p>
<p>int n;</p>
<p>int s[N];</p>
<p>int f[N][N];&#x2F;&#x2F;状态表示：集合f[l][r]为[l,r]区间；属性：所堆成的最小值</p>
<p>int main()</p>
<p>{</p>
<pre><code>scanf(&quot;%d&quot;, &amp;n);

for (int i = 1; i &lt;= n; i ++ )scanf(&quot;%d&quot;,&amp;s[i]);

for (int i = 1; i &lt;= n; i ++ )s[i]+=s[i-1];//前缀和用来求一段区间的和



for (int len = 2; len &lt;= n; len ++ )//区间长度为len//枚举长度

    for (int i = 1; i+len-1 &lt;= n; i ++ )&#123;//意思就是i在区间[1,n-len+1]中去//枚举区间

        int l=i,r=i+len-1;//区间在[i,i+len-1]中间长度为len//设置l和r的区间

        f[l][r]=1e9;//初始化最大值

        for (int k = l; k &lt; r; k ++ )//枚举分界点//不取r

            f[l][r]=min(f[l][r],f[l][k]+f[k+1][r]+s[r]-s[l-1]);//找到最小值状态转移方程为f[l][k]+f[k+1][r]+s[r]-s[l-1];

    &#125;

printf(&quot;%d\n&quot;,f[1][n]);//输出区间[1,n]的最小值

return 0;
</code></pre>
<p>}</p>
<p>状态转移方程找到最小值状态转移方程为f[l][r]&#x3D;min(f[l][r],f[l][k]+f[k+1][r]+s[r]-s[l-1])</p>
<h3 id="计数类DP"><a href="#计数类DP" class="headerlink" title="计数类DP"></a>计数类DP</h3><h4 id="整数划分"><a href="#整数划分" class="headerlink" title="整数划分"></a>整数划分</h4><p>一个正整数 n 可以表示成若干个正整数之和，我们将这样的一种表示称为正整数 n 的一种划分。</p>
<p>现在给定一个正整数 n，请你求出 n共有多少种不同的划分方法。</p>
<p>完全背包写法</p>
<p>&#x2F;&#x2F;完全背包的写法</p>
<p>using namespace std;</p>
<p>const int M&#x3D;1e9+7;</p>
<p>int f[1010],n;</p>
<p>int main()</p>
<p>{</p>
<pre><code>cin&gt;&gt;n;

f[0]=1;

for (int i = 1; i &lt;= n; i ++ )

    for (int j = i; j &lt;= n; j ++ )&#123;

        f[j]=(f[j-i]+f[j])%M;

    &#125;

cout&lt;&lt;f[n]&lt;&lt;endl;

return 0;
</code></pre>
<p>}</p>
<p>状态转移方程：f[j]&#x3D;(f[j-i]+f[j])</p>
<h3 id="数位统计DP"><a href="#数位统计DP" class="headerlink" title="数位统计DP"></a>数位统计DP</h3><h4 id="计数问题"><a href="#计数问题" class="headerlink" title="计数问题"></a>计数问题</h4><p>题目链接：[338. 计数问题 - AcWing题库]：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/340/">https://www.acwing.com/problem/content/340/</a></p>
<p>计数问题分类讨论.png</p>
<p>using namespace std;</p>
<p>&#x2F;&#x2F;因为我们举的分类中，有需要求一串数字中某个区间的数字，例如abcdefg有一个分类需要求出efg+1</p>
<p>int get(vector<int> num,int l,int r){</p>
<pre><code>int res=0;

for(int i=l;i&gt;=r;i--)res=res*10+num[i];//这里从小到大枚举的是因为下面count的时候读入数据是从最低为读到最高位，那么此时在num里，最高位存的就是数字的最低位，那么假如我们要求efg，那就是从2算到0

return res;
</code></pre>
<p>}</p>
<p>int power10(int i)&#x2F;&#x2F;这里有power10是因为有一个分类需要求得十次方得值</p>
<p>{</p>
<pre><code>int res=1;

while(i--)res*=10;

return res;
</code></pre>
<p>}</p>
<p>int count(int n,int x){</p>
<pre><code>if(!n)return 0;//n=0则返回0

vector&lt;int&gt; num;//num用来存储数中的每一位数字

while(n)&#123;

    num.push_back(n%10);

    n/=10;

&#125;

n=num.size();//得出它的长度

int res=0;

for (int i = n-1-!x; i &gt;=0; i -- )

//这里需要注意，我们的长度需要减一，是因为num是从0开始存储，而长度是元素的个数，因此需要减1才能读到正确的数值，而!x出现的原因是因为我们不能让前导零出现，如果此时需要我们列举的是0得出现的次数，那么我们自然不能让他们出现第一位，而是从第二位开始枚举

&#123;

    if(i&lt;n-1)//其实这里可以不同if判断，因为for循环里面实际上就已经达成了if得判断，但为了方便理解还是加上if来理解，这里i要小于n-1的原因是因为我们不能越界只有7位数就最高从七位数开始读起

    &#123;

        res+=get(num,n-1,i+1)*power10(i);//这里就是第一个分类，000~abc-1，那么此时情况个数就会是abc*103,这里的3取决于后面的efg的长度，假如他是efgh，那么就是4

        //这里的n-1,i+1,自己将数组列出然后根据分类标准就可以得出为什么l是n-1,r=i+1

        if(!x)res-=power10(i);//假如此时我们要列举的是0出现的次数，因为不能出现前导零，这样是不合法也不符合我们的分类情况，例如abcdefg我们列举d，那么他就得从001~abc-1，这样就不会直接到efg，而是会到0efg，因为前面不是前导零，自然就可以列举这个时候0出现的次数，所以要减掉1个power10

    &#125;

    if(num[i]==x)res+=get(num,i-1,0)+1;

    else if(num[i]&gt;x)res+=power10(i);

&#125;

return res;//返回res，即出现次数
</code></pre>
<p>}</p>
<p>int main()</p>
<p>{</p>
<pre><code>int a,b;

while(cin&gt;&gt;a&gt;&gt;b,a||b)&#123;

    if(a&gt;b)swap(a,b);//a大于b则交换a，b使得变成合法参数

    for(int i=0;i&lt;10;i++)

        cout&lt;&lt;count(b,i)-count(a-1,i)&lt;&lt;&#39; &#39;;//使用前缀和思想解决[a,b]的i出现的次数

    cout&lt;&lt;endl;

&#125;

return 0;
</code></pre>
<p>}</p>
<h3 id="状态压缩DP"><a href="#状态压缩DP" class="headerlink" title="状态压缩DP"></a>状态压缩DP</h3><h4 id="蒙德里安的梦想"><a href="#蒙德里安的梦想" class="headerlink" title="蒙德里安的梦想"></a>蒙德里安的梦想</h4><p>题目链接：[U204941 蒙德里安的梦想 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)]：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/U204941">https://www.luogu.com.cn/problem/U204941</a></p>
<p>视频讲解：[431 状态压缩DP 蒙德里安的梦想【动态规划】_哔哩哔哩_bilibili]：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1cv411b7EG/">https://www.bilibili.com/video/BV1cv411b7EG/</a></p>
<p>using namespace std;</p>
<p>const int N &#x3D; 12,M&#x3D;1&lt;&lt;N;</p>
<p>int n,m;</p>
<p>long long f[N][M];</p>
<p>bool st[M];</p>
<p>int main()</p>
<p>{</p>
<pre><code>int n,m;

while(cin&gt;&gt;n&gt;&gt;m,n||m)&#123;

    memset(f, 0, sizeof f);

    //预处理：判断合并列的状态i是否合法

    //如果合并列的某行是1表示横放，是0表示竖放

    //如果合并列不存在连续的奇数个0，即为合法状态

    for (int i = 0; i &lt; 1&lt;&lt;n; i ++ )&#123;

        st[i]=true;

        int cnt=0;//记录合并列中连续0的个数

        for (int j = 0; j &lt; n; j ++ )&#123;

            if(i&gt;&gt;j&amp;1)&#123;//如果是1

                if(cnt&amp;1)&#123;//如果连续0的个数是奇数

                    st[i]=false;//记录i不合法

                    break;

                &#125;

            &#125;else cnt++;//如果是0，记录0的个数

        &#125;

        if(cnt&amp;1)st[i]=false;//处理高位0的个数

    &#125;

    //状态计算

    f[0][0]=1;//第0列不横放是一种合法的方案

    for (int i = 1; i &lt;= m; i ++ )//阶段：枚举列

        for (int j = 0; j &lt; 1&lt;&lt;n; j ++ )//状态：枚举i列的状态

            for (int k = 0; k &lt; 1&lt;&lt;n; k ++ )//状态：枚举i-1列的状态

                //两列状态兼容：不出现重叠的1，不出现连续奇数个0

                if((j&amp;k)==0&amp;&amp;st[j|k])

                    f[i][j]+=f[i-1][k];

    cout&lt;&lt;f[m][0]&lt;&lt;endl;//第m列不横放，既答案

&#125;

return 0;
</code></pre>
<p>}</p>
<p>状态转移方程：</p>
<p>if((j&amp;k)&#x3D;&#x3D;0&amp;&amp;st[j|k])</p>
<p> f[i][j]+&#x3D;f[i-1][k];</p>
<h4 id="最短Hamilton路径"><a href="#最短Hamilton路径" class="headerlink" title="最短Hamilton路径"></a>最短Hamilton路径</h4><p>题目链接：[U122241 最短Hamilton路径 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)]：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/U122241">https://www.luogu.com.cn/problem/U122241</a></p>
<p>using namespace std;</p>
<p>const int N &#x3D; 20,M &#x3D; 1 &lt;&lt; N;</p>
<p>int n;</p>
<p>int w[N][N];</p>
<p>int f[M][N];&#x2F;&#x2F;第一维表示是否访问到该点的压缩状态，第二维是走到点j</p>
<pre><code>        //f[i][j]表示状态为i并且到j的最短路径
</code></pre>
<p>int main(){</p>
<pre><code>cin&gt;&gt;n;

for (int i = 0; i &lt; n; i ++ )

    for (int j = 0; j &lt; n; j ++ )//读入i到j的距离

        cin&gt;&gt;w[i][j];

memset(f, 0x3f, sizeof f);

f[1][0]=0;

for (int i = 0; i &lt; 1 &lt;&lt; n; i ++ )//枚举压缩的状态

    for (int j = 0; j &lt; n; j ++ )//枚举到0~j的点

        if(i &gt;&gt; j &amp; 1)//该状态存在j点

            for (int k = 0; k &lt; n; k ++ )//枚举从j倒数第二个点k

                if(i &gt;&gt; k &amp; 1)//倒数点k存在

                    f[i][j]=min(f[i][j],f[i-(1&lt;&lt;j)][k]+w[k][j]);//状态转移方程，在f[i][j]和状态去掉j的点f[i-(i&lt;&lt;j)][k]+w[k][j]取最小值

cout&lt;&lt;f[(1&lt;&lt;n)-1][n-1]&lt;&lt;endl;//输出状态全满也就是所有点都经过且到最后一个点的最短距离

return 0;
</code></pre>
<p>}</p>
<p>状态转移方程：</p>
<p>f[i][j]&#x3D;min(f[i][j],f[i-(1&lt;&lt;j)][k]+w[k][j]);</p>
<h3 id="树形DP"><a href="#树形DP" class="headerlink" title="树形DP"></a>树形DP</h3><h4 id="没有上司的舞会"><a href="#没有上司的舞会" class="headerlink" title="没有上司的舞会"></a>没有上司的舞会</h4><p>题目：[P1352 没有上司的舞会 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)]：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1352">https://www.luogu.com.cn/problem/P1352</a></p>
<p>视频讲解：[417 树形DP 没有上司的舞会【动态规划】_哔哩哔哩_bilibili]：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1eK411N7Ly/">https://www.bilibili.com/video/BV1eK411N7Ly/</a></p>
<p>using namespace std;</p>
<p>const int N &#x3D; 6010;</p>
<p>int n;</p>
<p>int w[N];&#x2F;&#x2F;每个节点的高兴度</p>
<p>int h[N], e[N], ne[N], idx;&#x2F;&#x2F;邻接表存储树</p>
<p>bool st[N];&#x2F;&#x2F;判断是否有父节点</p>
<p>int f[N][2];</p>
<p>void add(int a, int b)  &#x2F;&#x2F; 添加一条边a-&gt;b</p>
<p>{</p>
<pre><code>e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
</code></pre>
<p>}</p>
<p>void dfs(int u){</p>
<pre><code>f[u][0]=0;

f[u][1]=w[u];//初始化f[u][1]，当第二维是0则不选该点即高兴度为0，同理f[u][1]=w[u];

for (int i = h[u]; i!=-1 ; i =ne[i] )&#123;//遍历u的子节点进行深度优先遍历

    int j=e[i];

    dfs(j);

    //状态转移方程

    f[u][0]+=max(f[j][0],f[j][1]);//f[u][0]表示不选择父节点u，所以在f[j][0]和f[j][1]取最大值

    f[u][1]+=f[j][0];//f[u][1]表示选择根节点u，所以累加不选择子节点的f[j][0]

&#125;
</code></pre>
<p>}</p>
<p>int main()</p>
<p>{</p>
<pre><code>cin&gt;&gt;n;

for (int i = 1; i &lt;= n; i ++ )cin&gt;&gt;w[i];

memset(h, -1, sizeof h);

for (int i = 0; i &lt; n-1; i ++ )&#123;

    int a,b;

    cin&gt;&gt;a&gt;&gt;b;

    add(b,a);

    st[a]=true;//存储是否存在父节点

&#125;

int root=1;

while(st[root])root++;//判断是否是根节点

dfs(root);//dfs对f[i][j]进行状态转移计算

cout&lt;&lt;max(f[root][0],f[root][1])&lt;&lt;endl;//取选与不选根节点的最大值

return 0;
</code></pre>
<p>}</p>
<p>状态转移方程：</p>
<p>f[u][0]+&#x3D;max(f[j][0],f[j][1]);</p>
<p>f[u][1]+&#x3D;f[j][0];</p>
<h3 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h3><h4 id="滑雪"><a href="#滑雪" class="headerlink" title="滑雪"></a>滑雪</h4><p>题目链接：[P1434 [SHOI2002] 滑雪 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)]：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1434">https://www.luogu.com.cn/problem/P1434</a></p>
<p>using namespace std;</p>
<p>const int N &#x3D; 310;</p>
<p>int n,m;</p>
<p>int h[N][N];</p>
<p>int f[N][N];</p>
<p>int dx[4]&#x3D;{-1,0,1,0},dy[4]&#x3D;{0,1,0,-1};</p>
<p>int dp(int x,int y){</p>
<pre><code>int &amp;v=f[x][y];

if(v!=-1)return v;//记忆化搜索核心

v=1;

for (int i = 0; i &lt; 4; i ++ )&#123;

    int a=x+dx[i],b=y+dy[i];

    if(a&gt;=1&amp;&amp;a&lt;=n&amp;&amp;b&gt;=1&amp;&amp;b&lt;=m&amp;&amp;h[a][b]&lt;h[x][y])//判断是否越界且上一个经过的点的高度是否大于当前高度

        v=max(v,dp(a,b)+1);

&#125;

return v;
</code></pre>
<p>}</p>
<p>int main()</p>
<p>{</p>
<pre><code>scanf(&quot;%d%d&quot;, &amp;n, &amp;m);

for (int i = 1; i &lt;= n; i ++ )

    for (int j = 1; j &lt;= m; j ++ )

        scanf(&quot;%d&quot;, &amp;h[i][j]);

memset(f, -1, sizeof f);

int res=0;

for (int i = 1; i &lt;= n; i ++ )

    for (int j = 1; j &lt;= m; j ++ )

        res=max(res,dp(i,j));

printf(&quot;%d\n&quot;,res);

return 0;
</code></pre>
<p>}</p>
<p>状态转移方程：v&#x3D;max(v,dp(a,b)+1);</p>
<h2 id="六、贪心"><a href="#六、贪心" class="headerlink" title="六、贪心"></a>六、贪心</h2><p>一个贪心算法总是做出当前最好的选择，也就是说，它期望通过局部最优选择从而得到全局最优的解决方案。—《算法导论》</p>
<h3 id="区间问题"><a href="#区间问题" class="headerlink" title="区间问题"></a>区间问题</h3><h4 id="区间选点"><a href="#区间选点" class="headerlink" title="区间选点"></a>区间选点</h4><p>给定 N个闭区间[ai,bi]，请你在数轴上选择尽量少的点，使得每个区间内至少包含一个选出的点</p>
<p>输出选择的点的最小数量。</p>
<p>using namespace std;</p>
<p>const int N &#x3D; 100010;</p>
<p>int n;</p>
<p>struct Range{</p>
<pre><code>int l,r;

bool operator &lt;(const Range&amp; W)const&#123;

    return r&lt;W.r;

&#125;//重载小于号
</code></pre>
<p>}range[N];</p>
<p>int main()</p>
<p>{</p>
<pre><code>scanf(&quot;%d&quot;, &amp;n);

for (int i = 0; i &lt; n; i ++ )&#123;

    int l,r;

    scanf(&quot;%d%d&quot;, &amp;l, &amp;r);

    range[i]=&#123;l,r&#125;;//读入l,r

&#125;

sort(range,range+n);//按右端点进行排序

int res=0,ed=-2e9;//ed代表上一个点的右端点

for (int i = 0; i &lt; n; i ++ )&#123;

    if(range[i].l&gt;ed)&#123;

        res++;//点的数量加一

        ed=range[i].r;

    &#125;

&#125;

printf(&quot;%d\n&quot;,res);

return 0;
</code></pre>
<p>}</p>
<h4 id="最大不相交区间数量"><a href="#最大不相交区间数量" class="headerlink" title="最大不相交区间数量"></a>最大不相交区间数量</h4><p>给定 N个闭区间 [ai,bi]，请你在数轴上选择若干区间，使得选中的区间之间互不相交（包括端点）。</p>
<p>输出可选取区间的最大数量。</p>
<p>结论：最大不相交区间数量&#x3D;最少覆盖区间点数</p>
<p>为什么最大不相交区间数&#x3D;最少覆盖区间点数呢？</p>
<p>因为如果几个区间能被同一个点覆盖</p>
<p>说明他们相交了，所以有几个点就是有几个不相交区间</p>
<p>using namespace std;</p>
<p>const int N &#x3D; 100010;</p>
<p>int n;</p>
<p>struct Range{</p>
<pre><code>int l,r;

bool operator &lt;(const Range&amp; W)const&#123;

    return r&lt;W.r;

&#125;
</code></pre>
<p>}range[N];</p>
<p>int main()</p>
<p>{</p>
<pre><code>scanf(&quot;%d&quot;, &amp;n);

for (int i = 0; i &lt; n; i ++ )&#123;

    int l,r;

    scanf(&quot;%d%d&quot;, &amp;l, &amp;r);

    range[i]=&#123;l,r&#125;;

&#125;

sort(range,range+n);

int res=0,ed=-2e9;

for (int i = 0; i &lt; n; i ++ )&#123;

    if(range[i].l&gt;ed)&#123;

        res++;

        ed=range[i].r;

    &#125;

&#125;

printf(&quot;%d\n&quot;,res);

return 0;
</code></pre>
<p>}</p>
<h3 id="区间分组"><a href="#区间分组" class="headerlink" title="区间分组"></a>区间分组</h3><p>区间分组.png</p>
<p>using namespace std;</p>
<p>const int N &#x3D; 1e5+10;</p>
<p>int n;</p>
<p>struct Range{</p>
<pre><code>int l,r;

bool operator&lt;(const Range &amp;W)const&#123;

    return l&lt;W.l;

&#125;//按左端点排序
</code></pre>
<p>}range[N];</p>
<p>int main()</p>
<p>{</p>
<pre><code>scanf(&quot;%d&quot;, &amp;n);

for (int i = 0; i &lt; n; i ++ )&#123;

    int l,r;

    scanf(&quot;%d%d&quot;, &amp;l, &amp;r);

    range[i]=&#123;l,r&#125;;

&#125;

sort(range,range+n);//sort排序

priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; heap;//小根堆维护所有组的右端点最小值

for (int i = 0; i &lt; n; i ++ )&#123;//从左往右枚举

    auto r=range[i];//选择当前区间

    if(heap.empty()||heap.top()&gt;=r.l)heap.push(r.r);

    else&#123;

        heap.pop();

        heap.push(r.r);

    &#125;

&#125;

printf(&quot;%d\n&quot;,heap.size());

return 0;
</code></pre>
<p>}</p>
<h3 id="排序不等式"><a href="#排序不等式" class="headerlink" title="排序不等式"></a>排序不等式</h3><h4 id="排队打水"><a href="#排队打水" class="headerlink" title="排队打水"></a>排队打水</h4><p>有 n个人排队到 1 个水龙头处打水，第 i 个人装满水桶所需的时间是 ti，请问如何安排他们的打水顺序才能使所有人的等待时间之和最小？</p>
<p>t[i]从小到大排序：</p>
<p>计算公式：t[0]×(n−1)+t[1]×(n−2)+t[2]×(n−3)…+t[n]×0</p>
<p>using namespace std;</p>
<p>typedef long long LL;</p>
<p>const int N &#x3D; 1e5 + 10;</p>
<p>int t[N];</p>
<p>int main() {</p>
<pre><code>int n;

scanf(&quot;%d&quot;, &amp;n);

for (int i = 0; i &lt; n; i++)

    scanf(&quot;%d&quot;, &amp;t[i]);

sort(t, t + n);//排序

LL  ans = 0;

for (int i = 0; i &lt; n; i++) &#123;

    ans += t[i] * (n - i - 1);//计算

&#125;

printf(&quot;%lld&quot;, ans);

return 0;
</code></pre>
<p>}</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>算法总结</p><p><a href="https://mr-xiongyq.github.io/2024/06/13/算法总结/">https://mr-xiongyq.github.io/2024/06/13/算法总结/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Xiongyuqi</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2024-06-13</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2024-06-27</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2024/06/27/%E9%9D%A2%E7%BB%8F/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">面经</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2024/06/06/KMP%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"><span class="level-item">KMP字符串匹配</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div><script>var disqus_config = function () {
            this.page.url = 'https://mr-xiongyq.github.io/2024/06/13/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/';
            this.page.identifier = '2024/06/13/算法总结/';
        };
        (function() {
            var d = document, s = d.createElement('script');  
            s.src = '//' + 'my-hexo-blog-8' + '.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/icon.jpg" alt="Xiongyuqi"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Xiongyuqi</p><p class="is-size-6 is-block">Edward</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Dalian</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">52</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">3</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">25</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/Mr-xiongyq" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/Mr-xiongyq"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="QQ" href="https://user.qzone.qq.com/1398404939/infocenter"><i class="fab fa-qq"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:xiongxixi666@gmail.com"><i class="fas fa-envelope"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"><span class="level-start"><span class="level-item">算法题解</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">编程语言</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"><span class="level-start"><span class="level-item">C++</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-09-24T14:06:11.000Z">2024-09-24</time></p><p class="title"><a href="/2024/09/24/%E5%A4%84%E7%90%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E5%BA%94%E7%9A%84%E4%BB%A3%E7%A0%81/">处理字符串对应的代码</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-09-24T13:54:49.000Z">2024-09-24</time></p><p class="title"><a href="/2024/09/24/C-%E5%A4%84%E7%90%86%E5%AD%97%E7%AC%A6%E4%B8%B2/">C++处理字符串</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-09-20T15:54:32.000Z">2024-09-20</time></p><p class="title"><a href="/2024/09/20/c-stl%E5%AF%B9%E5%BA%94%E4%BB%A3%E7%A0%81/">c++ stl对应代码</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-09-20T15:52:49.000Z">2024-09-20</time></p><p class="title"><a href="/2024/09/20/c-stl%E7%9B%B8%E5%85%B3/">c++stl相关</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-09-15T08:24:21.000Z">2024-09-15</time></p><p class="title"><a href="/2024/09/15/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%8B%9F%E9%A2%98/">算法模拟题</a></p></div></article></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/09/"><span class="level-start"><span class="level-item">九月 2024</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/08/"><span class="level-start"><span class="level-item">八月 2024</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/07/"><span class="level-start"><span class="level-item">七月 2024</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/06/"><span class="level-start"><span class="level-item">六月 2024</span></span><span class="level-end"><span class="level-item tag">22</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/05/"><span class="level-start"><span class="level-item">五月 2024</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/03/"><span class="level-start"><span class="level-item">三月 2024</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C++</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Computer/"><span class="tag">Computer</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C%E8%AF%AD%E8%A8%80/"><span class="tag">C语言</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BB%A3%E7%A0%81/"><span class="tag">代码</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/"><span class="tag">代码实现</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A0%86%E6%A0%88/"><span class="tag">堆栈</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"><span class="tag">字符串</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"><span class="tag">字符串处理</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AD%97%E7%AC%A6%E5%A4%84%E7%90%86/"><span class="tag">字符处理</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%8E%92%E5%BA%8F/"><span class="tag">排序</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0/"><span class="tag">数学函数</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="tag">数据结构</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%97%A5%E5%B8%B8/"><span class="tag">日常</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag">19</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"><span class="tag">算法设计</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E3%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"><span class="tag">算法设计、动态规划</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%A6%82%E5%BF%B5/"><span class="tag">算法设计概念</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BC%96%E7%A8%8B/"><span class="tag">编程</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AF%81%E6%98%8E%E9%A2%98/"><span class="tag">证明题</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%BE%93%E5%85%A5%E6%96%B9%E6%B3%95/"><span class="tag">输入方法</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%9D%A2%E7%BB%8F/"><span class="tag">面经</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%9D%A2%E7%BB%8F1-swimtransformer/"><span class="tag">面经1-swimtransformer</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%9D%A2%E7%BB%8F2-attention-%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/"><span class="tag">面经2-attention(注意力机制)</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/"><span class="tag">面试真题</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/"><span class="tag">面试经验</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Blogs" height="28"></a><p class="is-size-7"><span>&copy; 2024 Xiongyuqi</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="GitHub上下载" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://npm.elemecdn.com/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://npm.elemecdn.com/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://npm.elemecdn.com/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://npm.elemecdn.com/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://npm.elemecdn.com/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://npm.elemecdn.com/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/javascript" id="MathJax-script" async>MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      },
      svg: {
        fontCache: 'global'
      },
      chtml: {
        matchFontHeight: false
      }
    };</script><script src="https://npm.elemecdn.com/mathjax@3.2.2/es5/tex-mml-chtml.js"></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>